{"ast":null,"code":"/**\n * interact.js v1.2.8\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n(function (realWindow) {\n  'use strict'; // return early if there's no window to work with (eg. Node.js)\n\n  if (!realWindow) {\n    return;\n  }\n\n  var // get wrapped window if using Shadow DOM polyfill\n  window = function () {\n    // create a TextNode\n    var el = realWindow.document.createTextNode(''); // check if it's wrapped by a polyfill\n\n    if (el.ownerDocument !== realWindow.document && typeof realWindow.wrap === 'function' && realWindow.wrap(el) === el) {\n      // return wrapped window\n      return realWindow.wrap(realWindow);\n    } // no Shadow DOM polyfil or native implementation\n\n\n    return realWindow;\n  }(),\n      document = window.document,\n      DocumentFragment = window.DocumentFragment || blank,\n      SVGElement = window.SVGElement || blank,\n      SVGSVGElement = window.SVGSVGElement || blank,\n      SVGElementInstance = window.SVGElementInstance || blank,\n      HTMLElement = window.HTMLElement || window.Element,\n      PointerEvent = window.PointerEvent || window.MSPointerEvent,\n      pEventTypes,\n      hypot = Math.hypot || function (x, y) {\n    return Math.sqrt(x * x + y * y);\n  },\n      tmpXY = {},\n      // reduce object creation in getXY()\n  documents = [],\n      // all documents being listened to\n  interactables = [],\n      // all set interactables\n  interactions = [],\n      // all interactions\n  dynamicDrop = false,\n      // {\n  //      type: {\n  //          selectors: ['selector', ...],\n  //          contexts : [document, ...],\n  //          listeners: [[listener, useCapture], ...]\n  //      }\n  //  }\n  delegatedEvents = {},\n      defaultOptions = {\n    base: {\n      accept: null,\n      actionChecker: null,\n      styleCursor: true,\n      preventDefault: 'auto',\n      origin: {\n        x: 0,\n        y: 0\n      },\n      deltaSource: 'page',\n      allowFrom: null,\n      ignoreFrom: null,\n      _context: document,\n      dropChecker: null\n    },\n    drag: {\n      enabled: false,\n      manualStart: true,\n      max: Infinity,\n      maxPerElement: 1,\n      snap: null,\n      restrict: null,\n      inertia: null,\n      autoScroll: null,\n      axis: 'xy'\n    },\n    drop: {\n      enabled: false,\n      accept: null,\n      overlap: 'pointer'\n    },\n    resize: {\n      enabled: false,\n      manualStart: false,\n      max: Infinity,\n      maxPerElement: 1,\n      snap: null,\n      restrict: null,\n      inertia: null,\n      autoScroll: null,\n      square: false,\n      preserveAspectRatio: false,\n      axis: 'xy',\n      // use default margin\n      margin: NaN,\n      // object with props left, right, top, bottom which are\n      // true/false values to resize when the pointer is over that edge,\n      // CSS selectors to match the handles for each direction\n      // or the Elements for each handle\n      edges: null,\n      // a value of 'none' will limit the resize rect to a minimum of 0x0\n      // 'negate' will alow the rect to have negative width/height\n      // 'reposition' will keep the width/height positive by swapping\n      // the top and bottom edges and/or swapping the left and right edges\n      invert: 'none'\n    },\n    gesture: {\n      manualStart: false,\n      enabled: false,\n      max: Infinity,\n      maxPerElement: 1,\n      restrict: null\n    },\n    perAction: {\n      manualStart: false,\n      max: Infinity,\n      maxPerElement: 1,\n      snap: {\n        enabled: false,\n        endOnly: false,\n        range: Infinity,\n        targets: null,\n        offsets: null,\n        relativePoints: null\n      },\n      restrict: {\n        enabled: false,\n        endOnly: false\n      },\n      autoScroll: {\n        enabled: false,\n        container: null,\n        // the item that is scrolled (Window or HTMLElement)\n        margin: 60,\n        speed: 300 // the scroll speed in pixels per second\n\n      },\n      inertia: {\n        enabled: false,\n        resistance: 10,\n        // the lambda in exponential decay\n        minSpeed: 100,\n        // target speed must be above this for inertia to start\n        endSpeed: 10,\n        // the speed at which inertia is slow enough to stop\n        allowResume: true,\n        // allow resuming an action in inertia phase\n        zeroResumeDelta: true,\n        // if an action is resumed after launch, set dx/dy to 0\n        smoothEndDuration: 300 // animate to snap/restrict endOnly if there's no inertia\n\n      }\n    },\n    _holdDuration: 600\n  },\n      // Things related to autoScroll\n  autoScroll = {\n    interaction: null,\n    i: null,\n    // the handle returned by window.setInterval\n    x: 0,\n    y: 0,\n    // Direction each pulse is to scroll in\n    // scroll the window by the values in scroll.x/y\n    scroll: function () {\n      var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n          container = options.container || getWindow(autoScroll.interaction.element),\n          now = new Date().getTime(),\n          // change in time in seconds\n      dtx = (now - autoScroll.prevTimeX) / 1000,\n          dty = (now - autoScroll.prevTimeY) / 1000,\n          vx,\n          vy,\n          sx,\n          sy; // displacement\n\n      if (options.velocity) {\n        vx = options.velocity.x;\n        vy = options.velocity.y;\n      } else {\n        vx = vy = options.speed;\n      }\n\n      sx = vx * dtx;\n      sy = vy * dty;\n\n      if (sx >= 1 || sy >= 1) {\n        if (isWindow(container)) {\n          container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n        } else if (container) {\n          container.scrollLeft += autoScroll.x * sx;\n          container.scrollTop += autoScroll.y * sy;\n        }\n\n        if (sx >= 1) autoScroll.prevTimeX = now;\n        if (sy >= 1) autoScroll.prevTimeY = now;\n      }\n\n      if (autoScroll.isScrolling) {\n        cancelFrame(autoScroll.i);\n        autoScroll.i = reqFrame(autoScroll.scroll);\n      }\n    },\n    isScrolling: false,\n    prevTimeX: 0,\n    prevTimeY: 0,\n    start: function (interaction) {\n      autoScroll.isScrolling = true;\n      cancelFrame(autoScroll.i);\n      autoScroll.interaction = interaction;\n      autoScroll.prevTimeX = new Date().getTime();\n      autoScroll.prevTimeY = new Date().getTime();\n      autoScroll.i = reqFrame(autoScroll.scroll);\n    },\n    stop: function () {\n      autoScroll.isScrolling = false;\n      cancelFrame(autoScroll.i);\n    }\n  },\n      // Does the browser support touch input?\n  supportsTouch = 'ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch,\n      // Does the browser support PointerEvents\n  // Avoid PointerEvent bugs introduced in Chrome 55\n  supportsPointerEvent = PointerEvent && !/Chrome/.test(navigator.userAgent),\n      // Less Precision with touch input\n  margin = supportsTouch || supportsPointerEvent ? 20 : 10,\n      pointerMoveTolerance = 1,\n      // for ignoring browser's simulated mouse events\n  prevTouchTime = 0,\n      // Allow this many interactions to happen simultaneously\n  maxInteractions = Infinity,\n      // Check if is IE9 or older\n  actionCursors = document.all && !window.atob ? {\n    drag: 'move',\n    resizex: 'e-resize',\n    resizey: 's-resize',\n    resizexy: 'se-resize',\n    resizetop: 'n-resize',\n    resizeleft: 'w-resize',\n    resizebottom: 's-resize',\n    resizeright: 'e-resize',\n    resizetopleft: 'se-resize',\n    resizebottomright: 'se-resize',\n    resizetopright: 'ne-resize',\n    resizebottomleft: 'ne-resize',\n    gesture: ''\n  } : {\n    drag: 'move',\n    resizex: 'ew-resize',\n    resizey: 'ns-resize',\n    resizexy: 'nwse-resize',\n    resizetop: 'ns-resize',\n    resizeleft: 'ew-resize',\n    resizebottom: 'ns-resize',\n    resizeright: 'ew-resize',\n    resizetopleft: 'nwse-resize',\n    resizebottomright: 'nwse-resize',\n    resizetopright: 'nesw-resize',\n    resizebottomleft: 'nesw-resize',\n    gesture: ''\n  },\n      actionIsEnabled = {\n    drag: true,\n    resize: true,\n    gesture: true\n  },\n      // because Webkit and Opera still use 'mousewheel' event type\n  wheelEvent = 'onmousewheel' in document ? 'mousewheel' : 'wheel',\n      eventTypes = ['dragstart', 'dragmove', 'draginertiastart', 'dragend', 'dragenter', 'dragleave', 'dropactivate', 'dropdeactivate', 'dropmove', 'drop', 'resizestart', 'resizemove', 'resizeinertiastart', 'resizeend', 'gesturestart', 'gesturemove', 'gestureinertiastart', 'gestureend', 'down', 'move', 'up', 'cancel', 'tap', 'doubletap', 'hold'],\n      globalEvents = {},\n      // Opera Mobile must be handled differently\n  isOperaMobile = navigator.appName == 'Opera' && supportsTouch && navigator.userAgent.match('Presto'),\n      // scrolling doesn't change the result of getClientRects on iOS 7\n  isIOS7 = /iP(hone|od|ad)/.test(navigator.platform) && /OS 7[^\\d]/.test(navigator.appVersion),\n      // prefix matchesSelector\n  prefixedMatchesSelector = 'matches' in Element.prototype ? 'matches' : 'webkitMatchesSelector' in Element.prototype ? 'webkitMatchesSelector' : 'mozMatchesSelector' in Element.prototype ? 'mozMatchesSelector' : 'oMatchesSelector' in Element.prototype ? 'oMatchesSelector' : 'msMatchesSelector',\n      // will be polyfill function if browser is IE8\n  ie8MatchesSelector,\n      // native requestAnimationFrame or polyfill\n  reqFrame = realWindow.requestAnimationFrame,\n      cancelFrame = realWindow.cancelAnimationFrame,\n      // Events wrapper\n  events = function () {\n    var useAttachEvent = 'attachEvent' in window && !('addEventListener' in window),\n        addEvent = useAttachEvent ? 'attachEvent' : 'addEventListener',\n        removeEvent = useAttachEvent ? 'detachEvent' : 'removeEventListener',\n        on = useAttachEvent ? 'on' : '',\n        elements = [],\n        targets = [],\n        attachedListeners = [];\n\n    function add(element, type, listener, useCapture) {\n      var elementIndex = indexOf(elements, element),\n          target = targets[elementIndex];\n\n      if (!target) {\n        target = {\n          events: {},\n          typeCount: 0\n        };\n        elementIndex = elements.push(element) - 1;\n        targets.push(target);\n        attachedListeners.push(useAttachEvent ? {\n          supplied: [],\n          wrapped: [],\n          useCount: []\n        } : null);\n      }\n\n      if (!target.events[type]) {\n        target.events[type] = [];\n        target.typeCount++;\n      }\n\n      if (!contains(target.events[type], listener)) {\n        var ret;\n\n        if (useAttachEvent) {\n          var listeners = attachedListeners[elementIndex],\n              listenerIndex = indexOf(listeners.supplied, listener);\n\n          var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n            if (!event.immediatePropagationStopped) {\n              event.target = event.srcElement;\n              event.currentTarget = element;\n              event.preventDefault = event.preventDefault || preventDef;\n              event.stopPropagation = event.stopPropagation || stopProp;\n              event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n              if (/mouse|click/.test(event.type)) {\n                event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n                event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n              }\n\n              listener(event);\n            }\n          };\n\n          ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\n          if (listenerIndex === -1) {\n            listeners.supplied.push(listener);\n            listeners.wrapped.push(wrapped);\n            listeners.useCount.push(1);\n          } else {\n            listeners.useCount[listenerIndex]++;\n          }\n        } else {\n          ret = element[addEvent](type, listener, useCapture || false);\n        }\n\n        target.events[type].push(listener);\n        return ret;\n      }\n    }\n\n    function remove(element, type, listener, useCapture) {\n      var i,\n          elementIndex = indexOf(elements, element),\n          target = targets[elementIndex],\n          listeners,\n          listenerIndex,\n          wrapped = listener;\n\n      if (!target || !target.events) {\n        return;\n      }\n\n      if (useAttachEvent) {\n        listeners = attachedListeners[elementIndex];\n        listenerIndex = indexOf(listeners.supplied, listener);\n        wrapped = listeners.wrapped[listenerIndex];\n      }\n\n      if (type === 'all') {\n        for (type in target.events) {\n          if (target.events.hasOwnProperty(type)) {\n            remove(element, type, 'all');\n          }\n        }\n\n        return;\n      }\n\n      if (target.events[type]) {\n        var len = target.events[type].length;\n\n        if (listener === 'all') {\n          for (i = 0; i < len; i++) {\n            remove(element, type, target.events[type][i], Boolean(useCapture));\n          }\n\n          return;\n        } else {\n          for (i = 0; i < len; i++) {\n            if (target.events[type][i] === listener) {\n              element[removeEvent](on + type, wrapped, useCapture || false);\n              target.events[type].splice(i, 1);\n\n              if (useAttachEvent && listeners) {\n                listeners.useCount[listenerIndex]--;\n\n                if (listeners.useCount[listenerIndex] === 0) {\n                  listeners.supplied.splice(listenerIndex, 1);\n                  listeners.wrapped.splice(listenerIndex, 1);\n                  listeners.useCount.splice(listenerIndex, 1);\n                }\n              }\n\n              break;\n            }\n          }\n        }\n\n        if (target.events[type] && target.events[type].length === 0) {\n          target.events[type] = null;\n          target.typeCount--;\n        }\n      }\n\n      if (!target.typeCount) {\n        targets.splice(elementIndex, 1);\n        elements.splice(elementIndex, 1);\n        attachedListeners.splice(elementIndex, 1);\n      }\n    }\n\n    function preventDef() {\n      this.returnValue = false;\n    }\n\n    function stopProp() {\n      this.cancelBubble = true;\n    }\n\n    function stopImmProp() {\n      this.cancelBubble = true;\n      this.immediatePropagationStopped = true;\n    }\n\n    return {\n      add: add,\n      remove: remove,\n      useAttachEvent: useAttachEvent,\n      _elements: elements,\n      _targets: targets,\n      _attachedListeners: attachedListeners\n    };\n  }();\n\n  function blank() {}\n\n  function isElement(o) {\n    if (!o || typeof o !== 'object') {\n      return false;\n    }\n\n    var _window = getWindow(o) || window;\n\n    return /object|function/.test(typeof _window.Element) ? o instanceof _window.Element //DOM2\n    : o.nodeType === 1 && typeof o.nodeName === \"string\";\n  }\n\n  function isWindow(thing) {\n    return thing === window || !!(thing && thing.Window) && thing instanceof thing.Window;\n  }\n\n  function isDocFrag(thing) {\n    return !!thing && thing instanceof DocumentFragment;\n  }\n\n  function isArray(thing) {\n    return isObject(thing) && typeof thing.length !== undefined && isFunction(thing.splice);\n  }\n\n  function isObject(thing) {\n    return !!thing && typeof thing === 'object';\n  }\n\n  function isFunction(thing) {\n    return typeof thing === 'function';\n  }\n\n  function isNumber(thing) {\n    return typeof thing === 'number';\n  }\n\n  function isBool(thing) {\n    return typeof thing === 'boolean';\n  }\n\n  function isString(thing) {\n    return typeof thing === 'string';\n  }\n\n  function trySelector(value) {\n    if (!isString(value)) {\n      return false;\n    } // an exception will be raised if it is invalid\n\n\n    document.querySelector(value);\n    return true;\n  }\n\n  function extend(dest, source) {\n    for (var prop in source) {\n      dest[prop] = source[prop];\n    }\n\n    return dest;\n  }\n\n  var prefixedPropREs = {\n    webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n  };\n\n  function pointerExtend(dest, source) {\n    for (var prop in source) {\n      var deprecated = false; // skip deprecated prefixed properties\n\n      for (var vendor in prefixedPropREs) {\n        if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n          deprecated = true;\n          break;\n        }\n      }\n\n      if (!deprecated) {\n        dest[prop] = source[prop];\n      }\n    }\n\n    return dest;\n  }\n\n  function copyCoords(dest, src) {\n    dest.page = dest.page || {};\n    dest.page.x = src.page.x;\n    dest.page.y = src.page.y;\n    dest.client = dest.client || {};\n    dest.client.x = src.client.x;\n    dest.client.y = src.client.y;\n    dest.timeStamp = src.timeStamp;\n  }\n\n  function setEventXY(targetObj, pointers, interaction) {\n    var pointer = pointers.length > 1 ? pointerAverage(pointers) : pointers[0];\n    getPageXY(pointer, tmpXY, interaction);\n    targetObj.page.x = tmpXY.x;\n    targetObj.page.y = tmpXY.y;\n    getClientXY(pointer, tmpXY, interaction);\n    targetObj.client.x = tmpXY.x;\n    targetObj.client.y = tmpXY.y;\n    targetObj.timeStamp = new Date().getTime();\n  }\n\n  function setEventDeltas(targetObj, prev, cur) {\n    targetObj.page.x = cur.page.x - prev.page.x;\n    targetObj.page.y = cur.page.y - prev.page.y;\n    targetObj.client.x = cur.client.x - prev.client.x;\n    targetObj.client.y = cur.client.y - prev.client.y;\n    targetObj.timeStamp = new Date().getTime() - prev.timeStamp; // set pointer velocity\n\n    var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n    targetObj.page.speed = hypot(targetObj.page.x, targetObj.page.y) / dt;\n    targetObj.page.vx = targetObj.page.x / dt;\n    targetObj.page.vy = targetObj.page.y / dt;\n    targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n    targetObj.client.vx = targetObj.client.x / dt;\n    targetObj.client.vy = targetObj.client.y / dt;\n  }\n\n  function isNativePointer(pointer) {\n    return pointer instanceof window.Event || supportsTouch && window.Touch && pointer instanceof window.Touch;\n  } // Get specified X/Y coords for mouse or event.touches[0]\n\n\n  function getXY(type, pointer, xy) {\n    xy = xy || {};\n    type = type || 'page';\n    xy.x = pointer[type + 'X'];\n    xy.y = pointer[type + 'Y'];\n    return xy;\n  }\n\n  function getPageXY(pointer, page) {\n    page = page || {}; // Opera Mobile handles the viewport and scrolling oddly\n\n    if (isOperaMobile && isNativePointer(pointer)) {\n      getXY('screen', pointer, page);\n      page.x += window.scrollX;\n      page.y += window.scrollY;\n    } else {\n      getXY('page', pointer, page);\n    }\n\n    return page;\n  }\n\n  function getClientXY(pointer, client) {\n    client = client || {};\n\n    if (isOperaMobile && isNativePointer(pointer)) {\n      // Opera Mobile handles the viewport and scrolling oddly\n      getXY('screen', pointer, client);\n    } else {\n      getXY('client', pointer, client);\n    }\n\n    return client;\n  }\n\n  function getScrollXY(win) {\n    win = win || window;\n    return {\n      x: win.scrollX || win.document.documentElement.scrollLeft,\n      y: win.scrollY || win.document.documentElement.scrollTop\n    };\n  }\n\n  function getPointerId(pointer) {\n    return isNumber(pointer.pointerId) ? pointer.pointerId : pointer.identifier;\n  }\n\n  function getActualElement(element) {\n    return element instanceof SVGElementInstance ? element.correspondingUseElement : element;\n  }\n\n  function getWindow(node) {\n    if (isWindow(node)) {\n      return node;\n    }\n\n    var rootNode = node.ownerDocument || node;\n    return rootNode.defaultView || rootNode.parentWindow || window;\n  }\n\n  function getElementClientRect(element) {\n    var clientRect = element instanceof SVGElement ? element.getBoundingClientRect() : element.getClientRects()[0];\n    return clientRect && {\n      left: clientRect.left,\n      right: clientRect.right,\n      top: clientRect.top,\n      bottom: clientRect.bottom,\n      width: clientRect.width || clientRect.right - clientRect.left,\n      height: clientRect.height || clientRect.bottom - clientRect.top\n    };\n  }\n\n  function getElementRect(element) {\n    var clientRect = getElementClientRect(element);\n\n    if (!isIOS7 && clientRect) {\n      var scroll = getScrollXY(getWindow(element));\n      clientRect.left += scroll.x;\n      clientRect.right += scroll.x;\n      clientRect.top += scroll.y;\n      clientRect.bottom += scroll.y;\n    }\n\n    return clientRect;\n  }\n\n  function getTouchPair(event) {\n    var touches = []; // array of touches is supplied\n\n    if (isArray(event)) {\n      touches[0] = event[0];\n      touches[1] = event[1];\n    } // an event\n    else {\n        if (event.type === 'touchend') {\n          if (event.touches.length === 1) {\n            touches[0] = event.touches[0];\n            touches[1] = event.changedTouches[0];\n          } else if (event.touches.length === 0) {\n            touches[0] = event.changedTouches[0];\n            touches[1] = event.changedTouches[1];\n          }\n        } else {\n          touches[0] = event.touches[0];\n          touches[1] = event.touches[1];\n        }\n      }\n\n    return touches;\n  }\n\n  function pointerAverage(pointers) {\n    var average = {\n      pageX: 0,\n      pageY: 0,\n      clientX: 0,\n      clientY: 0,\n      screenX: 0,\n      screenY: 0\n    };\n    var prop;\n\n    for (var i = 0; i < pointers.length; i++) {\n      for (prop in average) {\n        average[prop] += pointers[i][prop];\n      }\n    }\n\n    for (prop in average) {\n      average[prop] /= pointers.length;\n    }\n\n    return average;\n  }\n\n  function touchBBox(event) {\n    if (!event.length && !(event.touches && event.touches.length > 1)) {\n      return;\n    }\n\n    var touches = getTouchPair(event),\n        minX = Math.min(touches[0].pageX, touches[1].pageX),\n        minY = Math.min(touches[0].pageY, touches[1].pageY),\n        maxX = Math.max(touches[0].pageX, touches[1].pageX),\n        maxY = Math.max(touches[0].pageY, touches[1].pageY);\n    return {\n      x: minX,\n      y: minY,\n      left: minX,\n      top: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  }\n\n  function touchDistance(event, deltaSource) {\n    deltaSource = deltaSource || defaultOptions.deltaSource;\n    var sourceX = deltaSource + 'X',\n        sourceY = deltaSource + 'Y',\n        touches = getTouchPair(event);\n    var dx = touches[0][sourceX] - touches[1][sourceX],\n        dy = touches[0][sourceY] - touches[1][sourceY];\n    return hypot(dx, dy);\n  }\n\n  function touchAngle(event, prevAngle, deltaSource) {\n    deltaSource = deltaSource || defaultOptions.deltaSource;\n    var sourceX = deltaSource + 'X',\n        sourceY = deltaSource + 'Y',\n        touches = getTouchPair(event),\n        dx = touches[0][sourceX] - touches[1][sourceX],\n        dy = touches[0][sourceY] - touches[1][sourceY],\n        angle = 180 * Math.atan(dy / dx) / Math.PI;\n\n    if (isNumber(prevAngle)) {\n      var dr = angle - prevAngle,\n          drClamped = dr % 360;\n\n      if (drClamped > 315) {\n        angle -= 360 + angle / 360 | 0 * 360;\n      } else if (drClamped > 135) {\n        angle -= 180 + angle / 360 | 0 * 360;\n      } else if (drClamped < -315) {\n        angle += 360 + angle / 360 | 0 * 360;\n      } else if (drClamped < -135) {\n        angle += 180 + angle / 360 | 0 * 360;\n      }\n    }\n\n    return angle;\n  }\n\n  function getOriginXY(interactable, element) {\n    var origin = interactable ? interactable.options.origin : defaultOptions.origin;\n\n    if (origin === 'parent') {\n      origin = parentElement(element);\n    } else if (origin === 'self') {\n      origin = interactable.getRect(element);\n    } else if (trySelector(origin)) {\n      origin = closest(element, origin) || {\n        x: 0,\n        y: 0\n      };\n    }\n\n    if (isFunction(origin)) {\n      origin = origin(interactable && element);\n    }\n\n    if (isElement(origin)) {\n      origin = getElementRect(origin);\n    }\n\n    origin.x = 'x' in origin ? origin.x : origin.left;\n    origin.y = 'y' in origin ? origin.y : origin.top;\n    return origin;\n  } // http://stackoverflow.com/a/5634528/2280888\n\n\n  function _getQBezierValue(t, p1, p2, p3) {\n    var iT = 1 - t;\n    return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n  }\n\n  function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n    return {\n      x: _getQBezierValue(position, startX, cpX, endX),\n      y: _getQBezierValue(position, startY, cpY, endY)\n    };\n  } // http://gizma.com/easing/\n\n\n  function easeOutQuad(t, b, c, d) {\n    t /= d;\n    return -c * t * (t - 2) + b;\n  }\n\n  function nodeContains(parent, child) {\n    while (child) {\n      if (child === parent) {\n        return true;\n      }\n\n      child = child.parentNode;\n    }\n\n    return false;\n  }\n\n  function closest(child, selector) {\n    var parent = parentElement(child);\n\n    while (isElement(parent)) {\n      if (matchesSelector(parent, selector)) {\n        return parent;\n      }\n\n      parent = parentElement(parent);\n    }\n\n    return null;\n  }\n\n  function parentElement(node) {\n    var parent = node.parentNode;\n\n    if (isDocFrag(parent)) {\n      // skip past #shado-root fragments\n      while ((parent = parent.host) && isDocFrag(parent)) {}\n\n      return parent;\n    }\n\n    return parent;\n  }\n\n  function inContext(interactable, element) {\n    return interactable._context === element.ownerDocument || nodeContains(interactable._context, element);\n  }\n\n  function testIgnore(interactable, interactableElement, element) {\n    var ignoreFrom = interactable.options.ignoreFrom;\n\n    if (!ignoreFrom || !isElement(element)) {\n      return false;\n    }\n\n    if (isString(ignoreFrom)) {\n      return matchesUpTo(element, ignoreFrom, interactableElement);\n    } else if (isElement(ignoreFrom)) {\n      return nodeContains(ignoreFrom, element);\n    }\n\n    return false;\n  }\n\n  function testAllow(interactable, interactableElement, element) {\n    var allowFrom = interactable.options.allowFrom;\n\n    if (!allowFrom) {\n      return true;\n    }\n\n    if (!isElement(element)) {\n      return false;\n    }\n\n    if (isString(allowFrom)) {\n      return matchesUpTo(element, allowFrom, interactableElement);\n    } else if (isElement(allowFrom)) {\n      return nodeContains(allowFrom, element);\n    }\n\n    return false;\n  }\n\n  function checkAxis(axis, interactable) {\n    if (!interactable) {\n      return false;\n    }\n\n    var thisAxis = interactable.options.drag.axis;\n    return axis === 'xy' || thisAxis === 'xy' || thisAxis === axis;\n  }\n\n  function checkSnap(interactable, action) {\n    var options = interactable.options;\n\n    if (/^resize/.test(action)) {\n      action = 'resize';\n    }\n\n    return options[action].snap && options[action].snap.enabled;\n  }\n\n  function checkRestrict(interactable, action) {\n    var options = interactable.options;\n\n    if (/^resize/.test(action)) {\n      action = 'resize';\n    }\n\n    return options[action].restrict && options[action].restrict.enabled;\n  }\n\n  function checkAutoScroll(interactable, action) {\n    var options = interactable.options;\n\n    if (/^resize/.test(action)) {\n      action = 'resize';\n    }\n\n    return options[action].autoScroll && options[action].autoScroll.enabled;\n  }\n\n  function withinInteractionLimit(interactable, element, action) {\n    var options = interactable.options,\n        maxActions = options[action.name].max,\n        maxPerElement = options[action.name].maxPerElement,\n        activeInteractions = 0,\n        targetCount = 0,\n        targetElementCount = 0;\n\n    for (var i = 0, len = interactions.length; i < len; i++) {\n      var interaction = interactions[i],\n          otherAction = interaction.prepared.name,\n          active = interaction.interacting();\n\n      if (!active) {\n        continue;\n      }\n\n      activeInteractions++;\n\n      if (activeInteractions >= maxInteractions) {\n        return false;\n      }\n\n      if (interaction.target !== interactable) {\n        continue;\n      }\n\n      targetCount += otherAction === action.name | 0;\n\n      if (targetCount >= maxActions) {\n        return false;\n      }\n\n      if (interaction.element === element) {\n        targetElementCount++;\n\n        if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n          return false;\n        }\n      }\n    }\n\n    return maxInteractions > 0;\n  } // Test for the element that's \"above\" all other qualifiers\n\n\n  function indexOfDeepestElement(elements) {\n    var dropzone,\n        deepestZone = elements[0],\n        index = deepestZone ? 0 : -1,\n        parent,\n        deepestZoneParents = [],\n        dropzoneParents = [],\n        child,\n        i,\n        n;\n\n    for (i = 1; i < elements.length; i++) {\n      dropzone = elements[i]; // an element might belong to multiple selector dropzones\n\n      if (!dropzone || dropzone === deepestZone) {\n        continue;\n      }\n\n      if (!deepestZone) {\n        deepestZone = dropzone;\n        index = i;\n        continue;\n      } // check if the deepest or current are document.documentElement or document.rootElement\n      // - if the current dropzone is, do nothing and continue\n\n\n      if (dropzone.parentNode === dropzone.ownerDocument) {\n        continue;\n      } // - if deepest is, update with the current dropzone and continue to next\n      else if (deepestZone.parentNode === dropzone.ownerDocument) {\n          deepestZone = dropzone;\n          index = i;\n          continue;\n        }\n\n      if (!deepestZoneParents.length) {\n        parent = deepestZone;\n\n        while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n          deepestZoneParents.unshift(parent);\n          parent = parent.parentNode;\n        }\n      } // if this element is an svg element and the current deepest is\n      // an HTMLElement\n\n\n      if (deepestZone instanceof HTMLElement && dropzone instanceof SVGElement && !(dropzone instanceof SVGSVGElement)) {\n        if (dropzone === deepestZone.parentNode) {\n          continue;\n        }\n\n        parent = dropzone.ownerSVGElement;\n      } else {\n        parent = dropzone;\n      }\n\n      dropzoneParents = [];\n\n      while (parent.parentNode !== parent.ownerDocument) {\n        dropzoneParents.unshift(parent);\n        parent = parent.parentNode;\n      }\n\n      n = 0; // get (position of last common ancestor) + 1\n\n      while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n        n++;\n      }\n\n      var parents = [dropzoneParents[n - 1], dropzoneParents[n], deepestZoneParents[n]];\n      child = parents[0].lastChild;\n\n      while (child) {\n        if (child === parents[1]) {\n          deepestZone = dropzone;\n          index = i;\n          deepestZoneParents = [];\n          break;\n        } else if (child === parents[2]) {\n          break;\n        }\n\n        child = child.previousSibling;\n      }\n    }\n\n    return index;\n  }\n\n  function Interaction() {\n    this.target = null; // current interactable being interacted with\n\n    this.element = null; // the target element of the interactable\n\n    this.dropTarget = null; // the dropzone a drag target might be dropped into\n\n    this.dropElement = null; // the element at the time of checking\n\n    this.prevDropTarget = null; // the dropzone that was recently dragged away from\n\n    this.prevDropElement = null; // the element at the time of checking\n\n    this.prepared = {\n      // action that's ready to be fired on next move event\n      name: null,\n      axis: null,\n      edges: null\n    };\n    this.matches = []; // all selectors that are matched by target element\n\n    this.matchElements = []; // corresponding elements\n\n    this.inertiaStatus = {\n      active: false,\n      smoothEnd: false,\n      ending: false,\n      startEvent: null,\n      upCoords: {},\n      xe: 0,\n      ye: 0,\n      sx: 0,\n      sy: 0,\n      t0: 0,\n      vx0: 0,\n      vys: 0,\n      duration: 0,\n      resumeDx: 0,\n      resumeDy: 0,\n      lambda_v0: 0,\n      one_ve_v0: 0,\n      i: null\n    };\n\n    if (isFunction(Function.prototype.bind)) {\n      this.boundInertiaFrame = this.inertiaFrame.bind(this);\n      this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n    } else {\n      var that = this;\n\n      this.boundInertiaFrame = function () {\n        return that.inertiaFrame();\n      };\n\n      this.boundSmoothEndFrame = function () {\n        return that.smoothEndFrame();\n      };\n    }\n\n    this.activeDrops = {\n      dropzones: [],\n      // the dropzones that are mentioned below\n      elements: [],\n      // elements of dropzones that accept the target draggable\n      rects: [] // the rects of the elements mentioned above\n\n    }; // keep track of added pointers\n\n    this.pointers = [];\n    this.pointerIds = [];\n    this.downTargets = [];\n    this.downTimes = [];\n    this.holdTimers = []; // Previous native pointer move event coordinates\n\n    this.prevCoords = {\n      page: {\n        x: 0,\n        y: 0\n      },\n      client: {\n        x: 0,\n        y: 0\n      },\n      timeStamp: 0\n    }; // current native pointer move event coordinates\n\n    this.curCoords = {\n      page: {\n        x: 0,\n        y: 0\n      },\n      client: {\n        x: 0,\n        y: 0\n      },\n      timeStamp: 0\n    }; // Starting InteractEvent pointer coordinates\n\n    this.startCoords = {\n      page: {\n        x: 0,\n        y: 0\n      },\n      client: {\n        x: 0,\n        y: 0\n      },\n      timeStamp: 0\n    }; // Change in coordinates and time of the pointer\n\n    this.pointerDelta = {\n      page: {\n        x: 0,\n        y: 0,\n        vx: 0,\n        vy: 0,\n        speed: 0\n      },\n      client: {\n        x: 0,\n        y: 0,\n        vx: 0,\n        vy: 0,\n        speed: 0\n      },\n      timeStamp: 0\n    };\n    this.downEvent = null; // pointerdown/mousedown/touchstart event\n\n    this.downPointer = {};\n    this._eventTarget = null;\n    this._curEventTarget = null;\n    this.prevEvent = null; // previous action event\n\n    this.tapTime = 0; // time of the most recent tap event\n\n    this.prevTap = null;\n    this.startOffset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.restrictOffset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.snapOffsets = [];\n    this.gesture = {\n      start: {\n        x: 0,\n        y: 0\n      },\n      startDistance: 0,\n      // distance between two touches of touchStart\n      prevDistance: 0,\n      distance: 0,\n      scale: 1,\n      // gesture.distance / gesture.startDistance\n      startAngle: 0,\n      // angle of line joining two touches\n      prevAngle: 0 // angle of the previous gesture event\n\n    };\n    this.snapStatus = {\n      x: 0,\n      y: 0,\n      dx: 0,\n      dy: 0,\n      realX: 0,\n      realY: 0,\n      snappedX: 0,\n      snappedY: 0,\n      targets: [],\n      locked: false,\n      changed: false\n    };\n    this.restrictStatus = {\n      dx: 0,\n      dy: 0,\n      restrictedX: 0,\n      restrictedY: 0,\n      snap: null,\n      restricted: false,\n      changed: false\n    };\n    this.restrictStatus.snap = this.snapStatus;\n    this.pointerIsDown = false;\n    this.pointerWasMoved = false;\n    this.gesturing = false;\n    this.dragging = false;\n    this.resizing = false;\n    this.resizeAxes = 'xy';\n    this.mouse = false;\n    interactions.push(this);\n  }\n\n  Interaction.prototype = {\n    getPageXY: function (pointer, xy) {\n      return getPageXY(pointer, xy, this);\n    },\n    getClientXY: function (pointer, xy) {\n      return getClientXY(pointer, xy, this);\n    },\n    setEventXY: function (target, ptr) {\n      return setEventXY(target, ptr, this);\n    },\n    pointerOver: function (pointer, event, eventTarget) {\n      if (this.prepared.name || !this.mouse) {\n        return;\n      }\n\n      var curMatches = [],\n          curMatchElements = [],\n          prevTargetElement = this.element;\n      this.addPointer(pointer);\n\n      if (this.target && (testIgnore(this.target, this.element, eventTarget) || !testAllow(this.target, this.element, eventTarget))) {\n        // if the eventTarget should be ignored or shouldn't be allowed\n        // clear the previous target\n        this.target = null;\n        this.element = null;\n        this.matches = [];\n        this.matchElements = [];\n      }\n\n      var elementInteractable = interactables.get(eventTarget),\n          elementAction = elementInteractable && !testIgnore(elementInteractable, eventTarget, eventTarget) && testAllow(elementInteractable, eventTarget, eventTarget) && validateAction(elementInteractable.getAction(pointer, event, this, eventTarget), elementInteractable);\n\n      if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n        elementAction = null;\n      }\n\n      function pushCurMatches(interactable, selector) {\n        if (interactable && inContext(interactable, eventTarget) && !testIgnore(interactable, eventTarget, eventTarget) && testAllow(interactable, eventTarget, eventTarget) && matchesSelector(eventTarget, selector)) {\n          curMatches.push(interactable);\n          curMatchElements.push(eventTarget);\n        }\n      }\n\n      if (elementAction) {\n        this.target = elementInteractable;\n        this.element = eventTarget;\n        this.matches = [];\n        this.matchElements = [];\n      } else {\n        interactables.forEachSelector(pushCurMatches);\n\n        if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n          this.matches = curMatches;\n          this.matchElements = curMatchElements;\n          this.pointerHover(pointer, event, this.matches, this.matchElements);\n          events.add(eventTarget, supportsPointerEvent ? pEventTypes.move : 'mousemove', listeners.pointerHover);\n        } else if (this.target) {\n          if (nodeContains(prevTargetElement, eventTarget)) {\n            this.pointerHover(pointer, event, this.matches, this.matchElements);\n            events.add(this.element, supportsPointerEvent ? pEventTypes.move : 'mousemove', listeners.pointerHover);\n          } else {\n            this.target = null;\n            this.element = null;\n            this.matches = [];\n            this.matchElements = [];\n          }\n        }\n      }\n    },\n    // Check what action would be performed on pointerMove target if a mouse\n    // button were pressed and change the cursor accordingly\n    pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n      var target = this.target;\n\n      if (!this.prepared.name && this.mouse) {\n        var action; // update pointer coords for defaultActionChecker to use\n\n        this.setEventXY(this.curCoords, [pointer]);\n\n        if (matches) {\n          action = this.validateSelector(pointer, event, matches, matchElements);\n        } else if (target) {\n          action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n        }\n\n        if (target && target.options.styleCursor) {\n          if (action) {\n            target._doc.documentElement.style.cursor = getActionCursor(action);\n          } else {\n            target._doc.documentElement.style.cursor = '';\n          }\n        }\n      } else if (this.prepared.name) {\n        this.checkAndPreventDefault(event, target, this.element);\n      }\n    },\n    pointerOut: function (pointer, event, eventTarget) {\n      if (this.prepared.name) {\n        return;\n      } // Remove temporary event listeners for selector Interactables\n\n\n      if (!interactables.get(eventTarget)) {\n        events.remove(eventTarget, supportsPointerEvent ? pEventTypes.move : 'mousemove', listeners.pointerHover);\n      }\n\n      if (this.target && this.target.options.styleCursor && !this.interacting()) {\n        this.target._doc.documentElement.style.cursor = '';\n      }\n    },\n    selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n      var that = this,\n          // copy event to be used in timeout for IE8\n      eventCopy = events.useAttachEvent ? extend({}, event) : event,\n          element = eventTarget,\n          pointerIndex = this.addPointer(pointer),\n          action;\n      this.holdTimers[pointerIndex] = setTimeout(function () {\n        that.pointerHold(events.useAttachEvent ? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n      }, defaultOptions._holdDuration);\n      this.pointerIsDown = true; // Check if the down event hits the current inertia target\n\n      if (this.inertiaStatus.active && this.target.selector) {\n        // climb up the DOM tree from the event target\n        while (isElement(element)) {\n          // if this element is the current inertia target element\n          if (element === this.element // and the prospective action is the same as the ongoing one\n          && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n            // stop inertia so that the next move will be a normal one\n            cancelFrame(this.inertiaStatus.i);\n            this.inertiaStatus.active = false;\n            this.collectEventTargets(pointer, event, eventTarget, 'down');\n            return;\n          }\n\n          element = parentElement(element);\n        }\n      } // do nothing if interacting\n\n\n      if (this.interacting()) {\n        this.collectEventTargets(pointer, event, eventTarget, 'down');\n        return;\n      }\n\n      function pushMatches(interactable, selector, context) {\n        var elements = ie8MatchesSelector ? context.querySelectorAll(selector) : undefined;\n\n        if (inContext(interactable, element) && !testIgnore(interactable, element, eventTarget) && testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, elements)) {\n          that.matches.push(interactable);\n          that.matchElements.push(element);\n        }\n      } // update pointer coords for defaultActionChecker to use\n\n\n      this.setEventXY(this.curCoords, [pointer]);\n      this.downEvent = event;\n\n      while (isElement(element) && !action) {\n        this.matches = [];\n        this.matchElements = [];\n        interactables.forEachSelector(pushMatches);\n        action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n        element = parentElement(element);\n      }\n\n      if (action) {\n        this.prepared.name = action.name;\n        this.prepared.axis = action.axis;\n        this.prepared.edges = action.edges;\n        this.collectEventTargets(pointer, event, eventTarget, 'down');\n        return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n      } else {\n        // do these now since pointerDown isn't being called from here\n        this.downTimes[pointerIndex] = new Date().getTime();\n        this.downTargets[pointerIndex] = eventTarget;\n        pointerExtend(this.downPointer, pointer);\n        copyCoords(this.prevCoords, this.curCoords);\n        this.pointerWasMoved = false;\n      }\n\n      this.collectEventTargets(pointer, event, eventTarget, 'down');\n    },\n    // Determine action to be performed on next pointerMove and add appropriate\n    // style and event Listeners\n    pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n      if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n        this.checkAndPreventDefault(event, this.target, this.element);\n        return;\n      }\n\n      this.pointerIsDown = true;\n      this.downEvent = event;\n      var pointerIndex = this.addPointer(pointer),\n          action; // If it is the second touch of a multi-touch gesture, keep the\n      // target the same and get a new action if a target was set by the\n      // first touch\n\n      if (this.pointerIds.length > 1 && this.target._element === this.element) {\n        var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\n        if (withinInteractionLimit(this.target, this.element, newAction)) {\n          action = newAction;\n        }\n\n        this.prepared.name = null;\n      } // Otherwise, set the target if there is no action prepared\n      else if (!this.prepared.name) {\n          var interactable = interactables.get(curEventTarget);\n\n          if (interactable && !testIgnore(interactable, curEventTarget, eventTarget) && testAllow(interactable, curEventTarget, eventTarget) && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget)) && withinInteractionLimit(interactable, curEventTarget, action)) {\n            this.target = interactable;\n            this.element = curEventTarget;\n          }\n        }\n\n      var target = this.target,\n          options = target && target.options;\n\n      if (target && (forceAction || !this.prepared.name)) {\n        action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n        this.setEventXY(this.startCoords, this.pointers);\n\n        if (!action) {\n          return;\n        }\n\n        if (options.styleCursor) {\n          target._doc.documentElement.style.cursor = getActionCursor(action);\n        }\n\n        this.resizeAxes = action.name === 'resize' ? action.axis : null;\n\n        if (action === 'gesture' && this.pointerIds.length < 2) {\n          action = null;\n        }\n\n        this.prepared.name = action.name;\n        this.prepared.axis = action.axis;\n        this.prepared.edges = action.edges;\n        this.snapStatus.snappedX = this.snapStatus.snappedY = this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n        this.downTimes[pointerIndex] = new Date().getTime();\n        this.downTargets[pointerIndex] = eventTarget;\n        pointerExtend(this.downPointer, pointer);\n        copyCoords(this.prevCoords, this.startCoords);\n        this.pointerWasMoved = false;\n        this.checkAndPreventDefault(event, target, this.element);\n      } // if inertia is active try to resume action\n      else if (this.inertiaStatus.active && curEventTarget === this.element && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n          cancelFrame(this.inertiaStatus.i);\n          this.inertiaStatus.active = false;\n          this.checkAndPreventDefault(event, target, this.element);\n        }\n    },\n    setModifications: function (coords, preEnd) {\n      var target = this.target,\n          shouldMove = true,\n          shouldSnap = checkSnap(target, this.prepared.name) && (!target.options[this.prepared.name].snap.endOnly || preEnd),\n          shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\n      if (shouldSnap) {\n        this.setSnapping(coords);\n      } else {\n        this.snapStatus.locked = false;\n      }\n\n      if (shouldRestrict) {\n        this.setRestriction(coords);\n      } else {\n        this.restrictStatus.restricted = false;\n      }\n\n      if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n        shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n      } else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n        shouldMove = false;\n      }\n\n      return shouldMove;\n    },\n    setStartOffsets: function (action, interactable, element) {\n      var rect = interactable.getRect(element),\n          origin = getOriginXY(interactable, element),\n          snap = interactable.options[this.prepared.name].snap,\n          restrict = interactable.options[this.prepared.name].restrict,\n          width,\n          height;\n\n      if (rect) {\n        this.startOffset.left = this.startCoords.page.x - rect.left;\n        this.startOffset.top = this.startCoords.page.y - rect.top;\n        this.startOffset.right = rect.right - this.startCoords.page.x;\n        this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n        if ('width' in rect) {\n          width = rect.width;\n        } else {\n          width = rect.right - rect.left;\n        }\n\n        if ('height' in rect) {\n          height = rect.height;\n        } else {\n          height = rect.bottom - rect.top;\n        }\n      } else {\n        this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n      }\n\n      this.snapOffsets.splice(0);\n      var snapOffset = snap && snap.offset === 'startCoords' ? {\n        x: this.startCoords.page.x - origin.x,\n        y: this.startCoords.page.y - origin.y\n      } : snap && snap.offset || {\n        x: 0,\n        y: 0\n      };\n\n      if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n        for (var i = 0; i < snap.relativePoints.length; i++) {\n          this.snapOffsets.push({\n            x: this.startOffset.left - width * snap.relativePoints[i].x + snapOffset.x,\n            y: this.startOffset.top - height * snap.relativePoints[i].y + snapOffset.y\n          });\n        }\n      } else {\n        this.snapOffsets.push(snapOffset);\n      }\n\n      if (rect && restrict.elementRect) {\n        this.restrictOffset.left = this.startOffset.left - width * restrict.elementRect.left;\n        this.restrictOffset.top = this.startOffset.top - height * restrict.elementRect.top;\n        this.restrictOffset.right = this.startOffset.right - width * (1 - restrict.elementRect.right);\n        this.restrictOffset.bottom = this.startOffset.bottom - height * (1 - restrict.elementRect.bottom);\n      } else {\n        this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n      }\n    },\n\n    /*\\\n     * Interaction.start\n     [ method ]\n     *\n     * Start an action with the given Interactable and Element as tartgets. The\n     * action must be enabled for the target Interactable and an appropriate number\n     * of pointers must be held down – 1 for drag/resize, 2 for gesture.\n     *\n     * Use it with `interactable.<action>able({ manualStart: false })` to always\n     * [start actions manually](https://github.com/taye/interact.js/issues/114)\n     *\n     - action       (object)  The action to be performed - drag, resize, etc.\n     - interactable (Interactable) The Interactable to target\n     - element      (Element) The DOM Element to target\n     = (object) interact\n     **\n     | interact(target)\n     |   .draggable({\n     |     // disable the default drag start by down->move\n     |     manualStart: true\n     |   })\n     |   // start dragging after the user holds the pointer down\n     |   .on('hold', function (event) {\n     |     var interaction = event.interaction;\n     |\n     |     if (!interaction.interacting()) {\n     |       interaction.start({ name: 'drag' },\n     |                         event.interactable,\n     |                         event.currentTarget);\n     |     }\n     | });\n    \\*/\n    start: function (action, interactable, element) {\n      if (this.interacting() || !this.pointerIsDown || this.pointerIds.length < (action.name === 'gesture' ? 2 : 1)) {\n        return;\n      } // if this interaction had been removed after stopping\n      // add it back\n\n\n      if (indexOf(interactions, this) === -1) {\n        interactions.push(this);\n      } // set the startCoords if there was no prepared action\n\n\n      if (!this.prepared.name) {\n        this.setEventXY(this.startCoords, this.pointers);\n      }\n\n      this.prepared.name = action.name;\n      this.prepared.axis = action.axis;\n      this.prepared.edges = action.edges;\n      this.target = interactable;\n      this.element = element;\n      this.setStartOffsets(action.name, interactable, element);\n      this.setModifications(this.startCoords.page);\n      this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n    },\n    pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n      if (this.inertiaStatus.active) {\n        var pageUp = this.inertiaStatus.upCoords.page;\n        var clientUp = this.inertiaStatus.upCoords.client;\n        var inertiaPosition = {\n          pageX: pageUp.x + this.inertiaStatus.sx,\n          pageY: pageUp.y + this.inertiaStatus.sy,\n          clientX: clientUp.x + this.inertiaStatus.sx,\n          clientY: clientUp.y + this.inertiaStatus.sy\n        };\n        this.setEventXY(this.curCoords, [inertiaPosition]);\n      } else {\n        this.recordPointer(pointer);\n        this.setEventXY(this.curCoords, this.pointers);\n      }\n\n      var duplicateMove = this.curCoords.page.x === this.prevCoords.page.x && this.curCoords.page.y === this.prevCoords.page.y && this.curCoords.client.x === this.prevCoords.client.x && this.curCoords.client.y === this.prevCoords.client.y;\n      var dx,\n          dy,\n          pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer)); // register movement greater than pointerMoveTolerance\n\n      if (this.pointerIsDown && !this.pointerWasMoved) {\n        dx = this.curCoords.client.x - this.startCoords.client.x;\n        dy = this.curCoords.client.y - this.startCoords.client.y;\n        this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n      }\n\n      if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n        if (this.pointerIsDown) {\n          clearTimeout(this.holdTimers[pointerIndex]);\n        }\n\n        this.collectEventTargets(pointer, event, eventTarget, 'move');\n      }\n\n      if (!this.pointerIsDown) {\n        return;\n      }\n\n      if (duplicateMove && this.pointerWasMoved && !preEnd) {\n        this.checkAndPreventDefault(event, this.target, this.element);\n        return;\n      } // set pointer coordinate, time changes and speeds\n\n\n      setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n      if (!this.prepared.name) {\n        return;\n      }\n\n      if (this.pointerWasMoved // ignore movement while inertia is active\n      && (!this.inertiaStatus.active || pointer instanceof InteractEvent && /inertiastart/.test(pointer.type))) {\n        // if just starting an action, calculate the pointer speed now\n        if (!this.interacting()) {\n          setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords); // check if a drag is in the correct axis\n\n          if (this.prepared.name === 'drag') {\n            var absX = Math.abs(dx),\n                absY = Math.abs(dy),\n                targetAxis = this.target.options.drag.axis,\n                axis = absX > absY ? 'x' : absX < absY ? 'y' : 'xy'; // if the movement isn't in the axis of the interactable\n\n            if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n              // cancel the prepared action\n              this.prepared.name = null; // then try to get a drag from another ineractable\n\n              var element = eventTarget; // check element interactables\n\n              while (isElement(element)) {\n                var elementInteractable = interactables.get(element);\n\n                if (elementInteractable && elementInteractable !== this.target && !elementInteractable.options.drag.manualStart && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag' && checkAxis(axis, elementInteractable)) {\n                  this.prepared.name = 'drag';\n                  this.target = elementInteractable;\n                  this.element = element;\n                  break;\n                }\n\n                element = parentElement(element);\n              } // if there's no drag from element interactables,\n              // check the selector interactables\n\n\n              if (!this.prepared.name) {\n                var thisInteraction = this;\n\n                var getDraggable = function (interactable, selector, context) {\n                  var elements = ie8MatchesSelector ? context.querySelectorAll(selector) : undefined;\n\n                  if (interactable === thisInteraction.target) {\n                    return;\n                  }\n\n                  if (inContext(interactable, eventTarget) && !interactable.options.drag.manualStart && !testIgnore(interactable, element, eventTarget) && testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, elements) && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag' && checkAxis(axis, interactable) && withinInteractionLimit(interactable, element, 'drag')) {\n                    return interactable;\n                  }\n                };\n\n                element = eventTarget;\n\n                while (isElement(element)) {\n                  var selectorInteractable = interactables.forEachSelector(getDraggable);\n\n                  if (selectorInteractable) {\n                    this.prepared.name = 'drag';\n                    this.target = selectorInteractable;\n                    this.element = element;\n                    break;\n                  }\n\n                  element = parentElement(element);\n                }\n              }\n            }\n          }\n        }\n\n        var starting = !!this.prepared.name && !this.interacting();\n\n        if (starting && (this.target.options[this.prepared.name].manualStart || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n          this.stop(event);\n          return;\n        }\n\n        if (this.prepared.name && this.target) {\n          if (starting) {\n            this.start(this.prepared, this.target, this.element);\n          }\n\n          var shouldMove = this.setModifications(this.curCoords.page, preEnd); // move if snapping or restriction doesn't prevent it\n\n          if (shouldMove || starting) {\n            this.prevEvent = this[this.prepared.name + 'Move'](event);\n          }\n\n          this.checkAndPreventDefault(event, this.target, this.element);\n        }\n      }\n\n      copyCoords(this.prevCoords, this.curCoords);\n\n      if (this.dragging || this.resizing) {\n        this.autoScrollMove(pointer);\n      }\n    },\n    dragStart: function (event) {\n      var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n      this.dragging = true;\n      this.target.fire(dragEvent); // reset active dropzones\n\n      this.activeDrops.dropzones = [];\n      this.activeDrops.elements = [];\n      this.activeDrops.rects = [];\n\n      if (!this.dynamicDrop) {\n        this.setActiveDrops(this.element);\n      }\n\n      var dropEvents = this.getDropEvents(event, dragEvent);\n\n      if (dropEvents.activate) {\n        this.fireActiveDrops(dropEvents.activate);\n      }\n\n      return dragEvent;\n    },\n    dragMove: function (event) {\n      var target = this.target,\n          dragEvent = new InteractEvent(this, event, 'drag', 'move', this.element),\n          draggableElement = this.element,\n          drop = this.getDrop(dragEvent, event, draggableElement);\n      this.dropTarget = drop.dropzone;\n      this.dropElement = drop.element;\n      var dropEvents = this.getDropEvents(event, dragEvent);\n      target.fire(dragEvent);\n\n      if (dropEvents.leave) {\n        this.prevDropTarget.fire(dropEvents.leave);\n      }\n\n      if (dropEvents.enter) {\n        this.dropTarget.fire(dropEvents.enter);\n      }\n\n      if (dropEvents.move) {\n        this.dropTarget.fire(dropEvents.move);\n      }\n\n      this.prevDropTarget = this.dropTarget;\n      this.prevDropElement = this.dropElement;\n      return dragEvent;\n    },\n    resizeStart: function (event) {\n      var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\n      if (this.prepared.edges) {\n        var startRect = this.target.getRect(this.element);\n        /*\n         * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n         * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n         * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n         * on the active edges and the edge being interacted with.\n         */\n\n        if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n          var linkedEdges = extend({}, this.prepared.edges);\n          linkedEdges.top = linkedEdges.top || linkedEdges.left && !linkedEdges.bottom;\n          linkedEdges.left = linkedEdges.left || linkedEdges.top && !linkedEdges.right;\n          linkedEdges.bottom = linkedEdges.bottom || linkedEdges.right && !linkedEdges.top;\n          linkedEdges.right = linkedEdges.right || linkedEdges.bottom && !linkedEdges.left;\n          this.prepared._linkedEdges = linkedEdges;\n        } else {\n          this.prepared._linkedEdges = null;\n        } // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n\n\n        if (this.target.options.resize.preserveAspectRatio) {\n          this.resizeStartAspectRatio = startRect.width / startRect.height;\n        }\n\n        this.resizeRects = {\n          start: startRect,\n          current: extend({}, startRect),\n          restricted: extend({}, startRect),\n          previous: extend({}, startRect),\n          delta: {\n            left: 0,\n            right: 0,\n            width: 0,\n            top: 0,\n            bottom: 0,\n            height: 0\n          }\n        };\n        resizeEvent.rect = this.resizeRects.restricted;\n        resizeEvent.deltaRect = this.resizeRects.delta;\n      }\n\n      this.target.fire(resizeEvent);\n      this.resizing = true;\n      return resizeEvent;\n    },\n    resizeMove: function (event) {\n      var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n      var edges = this.prepared.edges,\n          invert = this.target.options.resize.invert,\n          invertible = invert === 'reposition' || invert === 'negate';\n\n      if (edges) {\n        var dx = resizeEvent.dx,\n            dy = resizeEvent.dy,\n            start = this.resizeRects.start,\n            current = this.resizeRects.current,\n            restricted = this.resizeRects.restricted,\n            delta = this.resizeRects.delta,\n            previous = extend(this.resizeRects.previous, restricted),\n            originalEdges = edges; // `resize.preserveAspectRatio` takes precedence over `resize.square`\n\n        if (this.target.options.resize.preserveAspectRatio) {\n          var resizeStartAspectRatio = this.resizeStartAspectRatio;\n          edges = this.prepared._linkedEdges;\n\n          if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n            dy = -dx / resizeStartAspectRatio;\n          } else if (originalEdges.left || originalEdges.right) {\n            dy = dx / resizeStartAspectRatio;\n          } else if (originalEdges.top || originalEdges.bottom) {\n            dx = dy * resizeStartAspectRatio;\n          }\n        } else if (this.target.options.resize.square) {\n          edges = this.prepared._linkedEdges;\n\n          if (originalEdges.left && originalEdges.bottom || originalEdges.right && originalEdges.top) {\n            dy = -dx;\n          } else if (originalEdges.left || originalEdges.right) {\n            dy = dx;\n          } else if (originalEdges.top || originalEdges.bottom) {\n            dx = dy;\n          }\n        } // update the 'current' rect without modifications\n\n\n        if (edges.top) {\n          current.top += dy;\n        }\n\n        if (edges.bottom) {\n          current.bottom += dy;\n        }\n\n        if (edges.left) {\n          current.left += dx;\n        }\n\n        if (edges.right) {\n          current.right += dx;\n        }\n\n        if (invertible) {\n          // if invertible, copy the current rect\n          extend(restricted, current);\n\n          if (invert === 'reposition') {\n            // swap edge values if necessary to keep width/height positive\n            var swap;\n\n            if (restricted.top > restricted.bottom) {\n              swap = restricted.top;\n              restricted.top = restricted.bottom;\n              restricted.bottom = swap;\n            }\n\n            if (restricted.left > restricted.right) {\n              swap = restricted.left;\n              restricted.left = restricted.right;\n              restricted.right = swap;\n            }\n          }\n        } else {\n          // if not invertible, restrict to minimum of 0x0 rect\n          restricted.top = Math.min(current.top, start.bottom);\n          restricted.bottom = Math.max(current.bottom, start.top);\n          restricted.left = Math.min(current.left, start.right);\n          restricted.right = Math.max(current.right, start.left);\n        }\n\n        restricted.width = restricted.right - restricted.left;\n        restricted.height = restricted.bottom - restricted.top;\n\n        for (var edge in restricted) {\n          delta[edge] = restricted[edge] - previous[edge];\n        }\n\n        resizeEvent.edges = this.prepared.edges;\n        resizeEvent.rect = restricted;\n        resizeEvent.deltaRect = delta;\n      }\n\n      this.target.fire(resizeEvent);\n      return resizeEvent;\n    },\n    gestureStart: function (event) {\n      var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n      gestureEvent.ds = 0;\n      this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n      this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n      this.gesture.scale = 1;\n      this.gesturing = true;\n      this.target.fire(gestureEvent);\n      return gestureEvent;\n    },\n    gestureMove: function (event) {\n      if (!this.pointerIds.length) {\n        return this.prevEvent;\n      }\n\n      var gestureEvent;\n      gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n      gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n      this.target.fire(gestureEvent);\n      this.gesture.prevAngle = gestureEvent.angle;\n      this.gesture.prevDistance = gestureEvent.distance;\n\n      if (gestureEvent.scale !== Infinity && gestureEvent.scale !== null && gestureEvent.scale !== undefined && !isNaN(gestureEvent.scale)) {\n        this.gesture.scale = gestureEvent.scale;\n      }\n\n      return gestureEvent;\n    },\n    pointerHold: function (pointer, event, eventTarget) {\n      this.collectEventTargets(pointer, event, eventTarget, 'hold');\n    },\n    pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n      clearTimeout(this.holdTimers[pointerIndex]);\n      this.collectEventTargets(pointer, event, eventTarget, 'up');\n      this.collectEventTargets(pointer, event, eventTarget, 'tap');\n      this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n      this.removePointer(pointer);\n    },\n    pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n      clearTimeout(this.holdTimers[pointerIndex]);\n      this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n      this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n      this.removePointer(pointer);\n    },\n    // http://www.quirksmode.org/dom/events/click.html\n    // >Events leading to dblclick\n    //\n    // IE8 doesn't fire down event before dblclick.\n    // This workaround tries to fire a tap and doubletap after dblclick\n    ie8Dblclick: function (pointer, event, eventTarget) {\n      if (this.prevTap && event.clientX === this.prevTap.clientX && event.clientY === this.prevTap.clientY && eventTarget === this.prevTap.target) {\n        this.downTargets[0] = eventTarget;\n        this.downTimes[0] = new Date().getTime();\n        this.collectEventTargets(pointer, event, eventTarget, 'tap');\n      }\n    },\n    // End interact move events and stop auto-scroll unless inertia is enabled\n    pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n      var endEvent,\n          target = this.target,\n          options = target && target.options,\n          inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n          inertiaStatus = this.inertiaStatus;\n\n      if (this.interacting()) {\n        if (inertiaStatus.active && !inertiaStatus.ending) {\n          return;\n        }\n\n        var pointerSpeed,\n            now = new Date().getTime(),\n            inertiaPossible = false,\n            inertia = false,\n            smoothEnd = false,\n            endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n            endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n            dx = 0,\n            dy = 0,\n            startEvent;\n\n        if (this.dragging) {\n          if (options.drag.axis === 'x') {\n            pointerSpeed = Math.abs(this.pointerDelta.client.vx);\n          } else if (options.drag.axis === 'y') {\n            pointerSpeed = Math.abs(this.pointerDelta.client.vy);\n          } else\n            /*options.drag.axis === 'xy'*/\n            {\n              pointerSpeed = this.pointerDelta.client.speed;\n            }\n        } else {\n          pointerSpeed = this.pointerDelta.client.speed;\n        } // check if inertia should be started\n\n\n        inertiaPossible = inertiaOptions && inertiaOptions.enabled && this.prepared.name !== 'gesture' && event !== inertiaStatus.startEvent;\n        inertia = inertiaPossible && now - this.curCoords.timeStamp < 50 && pointerSpeed > inertiaOptions.minSpeed && pointerSpeed > inertiaOptions.endSpeed;\n\n        if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n          var snapRestrict = {};\n          snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\n          if (endSnap) {\n            this.setSnapping(this.curCoords.page, snapRestrict);\n\n            if (snapRestrict.locked) {\n              dx += snapRestrict.dx;\n              dy += snapRestrict.dy;\n            }\n          }\n\n          if (endRestrict) {\n            this.setRestriction(this.curCoords.page, snapRestrict);\n\n            if (snapRestrict.restricted) {\n              dx += snapRestrict.dx;\n              dy += snapRestrict.dy;\n            }\n          }\n\n          if (dx || dy) {\n            smoothEnd = true;\n          }\n        }\n\n        if (inertia || smoothEnd) {\n          copyCoords(inertiaStatus.upCoords, this.curCoords);\n          this.pointers[0] = inertiaStatus.startEvent = startEvent = new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n          inertiaStatus.t0 = now;\n          target.fire(inertiaStatus.startEvent);\n\n          if (inertia) {\n            inertiaStatus.vx0 = this.pointerDelta.client.vx;\n            inertiaStatus.vy0 = this.pointerDelta.client.vy;\n            inertiaStatus.v0 = pointerSpeed;\n            this.calcInertia(inertiaStatus);\n            var page = extend({}, this.curCoords.page),\n                origin = getOriginXY(target, this.element),\n                statusObject;\n            page.x = page.x + inertiaStatus.xe - origin.x;\n            page.y = page.y + inertiaStatus.ye - origin.y;\n            statusObject = {\n              useStatusXY: true,\n              x: page.x,\n              y: page.y,\n              dx: 0,\n              dy: 0,\n              snap: null\n            };\n            statusObject.snap = statusObject;\n            dx = dy = 0;\n\n            if (endSnap) {\n              var snap = this.setSnapping(this.curCoords.page, statusObject);\n\n              if (snap.locked) {\n                dx += snap.dx;\n                dy += snap.dy;\n              }\n            }\n\n            if (endRestrict) {\n              var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\n              if (restrict.restricted) {\n                dx += restrict.dx;\n                dy += restrict.dy;\n              }\n            }\n\n            inertiaStatus.modifiedXe += dx;\n            inertiaStatus.modifiedYe += dy;\n            inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n          } else {\n            inertiaStatus.smoothEnd = true;\n            inertiaStatus.xe = dx;\n            inertiaStatus.ye = dy;\n            inertiaStatus.sx = inertiaStatus.sy = 0;\n            inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n          }\n\n          inertiaStatus.active = true;\n          return;\n        }\n\n        if (endSnap || endRestrict) {\n          // fire a move event at the snapped coordinates\n          this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n        }\n      }\n\n      if (this.dragging) {\n        endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n        var draggableElement = this.element,\n            drop = this.getDrop(endEvent, event, draggableElement);\n        this.dropTarget = drop.dropzone;\n        this.dropElement = drop.element;\n        var dropEvents = this.getDropEvents(event, endEvent);\n\n        if (dropEvents.leave) {\n          this.prevDropTarget.fire(dropEvents.leave);\n        }\n\n        if (dropEvents.enter) {\n          this.dropTarget.fire(dropEvents.enter);\n        }\n\n        if (dropEvents.drop) {\n          this.dropTarget.fire(dropEvents.drop);\n        }\n\n        if (dropEvents.deactivate) {\n          this.fireActiveDrops(dropEvents.deactivate);\n        }\n\n        target.fire(endEvent);\n      } else if (this.resizing) {\n        endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n        target.fire(endEvent);\n      } else if (this.gesturing) {\n        endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n        target.fire(endEvent);\n      }\n\n      this.stop(event);\n    },\n    collectDrops: function (element) {\n      var drops = [],\n          elements = [],\n          i;\n      element = element || this.element; // collect all dropzones and their elements which qualify for a drop\n\n      for (i = 0; i < interactables.length; i++) {\n        if (!interactables[i].options.drop.enabled) {\n          continue;\n        }\n\n        var current = interactables[i],\n            accept = current.options.drop.accept; // test the draggable element against the dropzone's accept setting\n\n        if (isElement(accept) && accept !== element || isString(accept) && !matchesSelector(element, accept)) {\n          continue;\n        } // query for new elements if necessary\n\n\n        var dropElements = current.selector ? current._context.querySelectorAll(current.selector) : [current._element];\n\n        for (var j = 0, len = dropElements.length; j < len; j++) {\n          var currentElement = dropElements[j];\n\n          if (currentElement === element) {\n            continue;\n          }\n\n          drops.push(current);\n          elements.push(currentElement);\n        }\n      }\n\n      return {\n        dropzones: drops,\n        elements: elements\n      };\n    },\n    fireActiveDrops: function (event) {\n      var i, current, currentElement, prevElement; // loop through all active dropzones and trigger event\n\n      for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n        current = this.activeDrops.dropzones[i];\n        currentElement = this.activeDrops.elements[i]; // prevent trigger of duplicate events on same element\n\n        if (currentElement !== prevElement) {\n          // set current element as event target\n          event.target = currentElement;\n          current.fire(event);\n        }\n\n        prevElement = currentElement;\n      }\n    },\n    // Collect a new set of possible drops and save them in activeDrops.\n    // setActiveDrops should always be called when a drag has just started or a\n    // drag event happens while dynamicDrop is true\n    setActiveDrops: function (dragElement) {\n      // get dropzones and their elements that could receive the draggable\n      var possibleDrops = this.collectDrops(dragElement, true);\n      this.activeDrops.dropzones = possibleDrops.dropzones;\n      this.activeDrops.elements = possibleDrops.elements;\n      this.activeDrops.rects = [];\n\n      for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n        this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n      }\n    },\n    getDrop: function (dragEvent, event, dragElement) {\n      var validDrops = [];\n\n      if (dynamicDrop) {\n        this.setActiveDrops(dragElement);\n      } // collect all dropzones and their elements which qualify for a drop\n\n\n      for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n        var current = this.activeDrops.dropzones[j],\n            currentElement = this.activeDrops.elements[j],\n            rect = this.activeDrops.rects[j];\n        validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect) ? currentElement : null);\n      } // get the most appropriate dropzone based on DOM depth and order\n\n\n      var dropIndex = indexOfDeepestElement(validDrops),\n          dropzone = this.activeDrops.dropzones[dropIndex] || null,\n          element = this.activeDrops.elements[dropIndex] || null;\n      return {\n        dropzone: dropzone,\n        element: element\n      };\n    },\n    getDropEvents: function (pointerEvent, dragEvent) {\n      var dropEvents = {\n        enter: null,\n        leave: null,\n        activate: null,\n        deactivate: null,\n        move: null,\n        drop: null\n      };\n\n      if (this.dropElement !== this.prevDropElement) {\n        // if there was a prevDropTarget, create a dragleave event\n        if (this.prevDropTarget) {\n          dropEvents.leave = {\n            target: this.prevDropElement,\n            dropzone: this.prevDropTarget,\n            relatedTarget: dragEvent.target,\n            draggable: dragEvent.interactable,\n            dragEvent: dragEvent,\n            interaction: this,\n            timeStamp: dragEvent.timeStamp,\n            type: 'dragleave'\n          };\n          dragEvent.dragLeave = this.prevDropElement;\n          dragEvent.prevDropzone = this.prevDropTarget;\n        } // if the dropTarget is not null, create a dragenter event\n\n\n        if (this.dropTarget) {\n          dropEvents.enter = {\n            target: this.dropElement,\n            dropzone: this.dropTarget,\n            relatedTarget: dragEvent.target,\n            draggable: dragEvent.interactable,\n            dragEvent: dragEvent,\n            interaction: this,\n            timeStamp: dragEvent.timeStamp,\n            type: 'dragenter'\n          };\n          dragEvent.dragEnter = this.dropElement;\n          dragEvent.dropzone = this.dropTarget;\n        }\n      }\n\n      if (dragEvent.type === 'dragend' && this.dropTarget) {\n        dropEvents.drop = {\n          target: this.dropElement,\n          dropzone: this.dropTarget,\n          relatedTarget: dragEvent.target,\n          draggable: dragEvent.interactable,\n          dragEvent: dragEvent,\n          interaction: this,\n          timeStamp: dragEvent.timeStamp,\n          type: 'drop'\n        };\n        dragEvent.dropzone = this.dropTarget;\n      }\n\n      if (dragEvent.type === 'dragstart') {\n        dropEvents.activate = {\n          target: null,\n          dropzone: null,\n          relatedTarget: dragEvent.target,\n          draggable: dragEvent.interactable,\n          dragEvent: dragEvent,\n          interaction: this,\n          timeStamp: dragEvent.timeStamp,\n          type: 'dropactivate'\n        };\n      }\n\n      if (dragEvent.type === 'dragend') {\n        dropEvents.deactivate = {\n          target: null,\n          dropzone: null,\n          relatedTarget: dragEvent.target,\n          draggable: dragEvent.interactable,\n          dragEvent: dragEvent,\n          interaction: this,\n          timeStamp: dragEvent.timeStamp,\n          type: 'dropdeactivate'\n        };\n      }\n\n      if (dragEvent.type === 'dragmove' && this.dropTarget) {\n        dropEvents.move = {\n          target: this.dropElement,\n          dropzone: this.dropTarget,\n          relatedTarget: dragEvent.target,\n          draggable: dragEvent.interactable,\n          dragEvent: dragEvent,\n          interaction: this,\n          dragmove: dragEvent,\n          timeStamp: dragEvent.timeStamp,\n          type: 'dropmove'\n        };\n        dragEvent.dropzone = this.dropTarget;\n      }\n\n      return dropEvents;\n    },\n    currentAction: function () {\n      return this.dragging && 'drag' || this.resizing && 'resize' || this.gesturing && 'gesture' || null;\n    },\n    interacting: function () {\n      return this.dragging || this.resizing || this.gesturing;\n    },\n    clearTargets: function () {\n      this.target = this.element = null;\n      this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n    },\n    stop: function (event) {\n      if (this.interacting()) {\n        autoScroll.stop();\n        this.matches = [];\n        this.matchElements = [];\n        var target = this.target;\n\n        if (target.options.styleCursor) {\n          target._doc.documentElement.style.cursor = '';\n        } // prevent Default only if were previously interacting\n\n\n        if (event && isFunction(event.preventDefault)) {\n          this.checkAndPreventDefault(event, target, this.element);\n        }\n\n        if (this.dragging) {\n          this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n        }\n      }\n\n      this.clearTargets();\n      this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n      this.prepared.name = this.prevEvent = null;\n      this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0; // remove pointers if their ID isn't in this.pointerIds\n\n      for (var i = 0; i < this.pointers.length; i++) {\n        if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n          this.pointers.splice(i, 1);\n        }\n      }\n    },\n    inertiaFrame: function () {\n      var inertiaStatus = this.inertiaStatus,\n          options = this.target.options[this.prepared.name].inertia,\n          lambda = options.resistance,\n          t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n      if (t < inertiaStatus.te) {\n        var progress = 1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\n        if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n          inertiaStatus.sx = inertiaStatus.xe * progress;\n          inertiaStatus.sy = inertiaStatus.ye * progress;\n        } else {\n          var quadPoint = getQuadraticCurvePoint(0, 0, inertiaStatus.xe, inertiaStatus.ye, inertiaStatus.modifiedXe, inertiaStatus.modifiedYe, progress);\n          inertiaStatus.sx = quadPoint.x;\n          inertiaStatus.sy = quadPoint.y;\n        }\n\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n      } else {\n        inertiaStatus.ending = true;\n        inertiaStatus.sx = inertiaStatus.modifiedXe;\n        inertiaStatus.sy = inertiaStatus.modifiedYe;\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        inertiaStatus.active = inertiaStatus.ending = false;\n      }\n    },\n    smoothEndFrame: function () {\n      var inertiaStatus = this.inertiaStatus,\n          t = new Date().getTime() - inertiaStatus.t0,\n          duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n      if (t < duration) {\n        inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n        inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n      } else {\n        inertiaStatus.ending = true;\n        inertiaStatus.sx = inertiaStatus.xe;\n        inertiaStatus.sy = inertiaStatus.ye;\n        this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n        inertiaStatus.smoothEnd = inertiaStatus.active = inertiaStatus.ending = false;\n      }\n    },\n    addPointer: function (pointer) {\n      var id = getPointerId(pointer),\n          index = this.mouse ? 0 : indexOf(this.pointerIds, id);\n\n      if (index === -1) {\n        index = this.pointerIds.length;\n      }\n\n      this.pointerIds[index] = id;\n      this.pointers[index] = pointer;\n      return index;\n    },\n    removePointer: function (pointer) {\n      var id = getPointerId(pointer),\n          index = this.mouse ? 0 : indexOf(this.pointerIds, id);\n\n      if (index === -1) {\n        return;\n      }\n\n      this.pointers.splice(index, 1);\n      this.pointerIds.splice(index, 1);\n      this.downTargets.splice(index, 1);\n      this.downTimes.splice(index, 1);\n      this.holdTimers.splice(index, 1);\n    },\n    recordPointer: function (pointer) {\n      var index = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n      if (index === -1) {\n        return;\n      }\n\n      this.pointers[index] = pointer;\n    },\n    collectEventTargets: function (pointer, event, eventTarget, eventType) {\n      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer)); // do not fire a tap event if the pointer was moved before being lifted\n\n      if (eventType === 'tap' && (this.pointerWasMoved // or if the pointerup target is different to the pointerdown target\n      || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n        return;\n      }\n\n      var targets = [],\n          elements = [],\n          element = eventTarget;\n\n      function collectSelectors(interactable, selector, context) {\n        var els = ie8MatchesSelector ? context.querySelectorAll(selector) : undefined;\n\n        if (interactable._iEvents[eventType] && isElement(element) && inContext(interactable, element) && !testIgnore(interactable, element, eventTarget) && testAllow(interactable, element, eventTarget) && matchesSelector(element, selector, els)) {\n          targets.push(interactable);\n          elements.push(element);\n        }\n      }\n\n      while (element) {\n        if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n          targets.push(interact(element));\n          elements.push(element);\n        }\n\n        interactables.forEachSelector(collectSelectors);\n        element = parentElement(element);\n      } // create the tap event even if there are no listeners so that\n      // doubletap can still be created and fired\n\n\n      if (targets.length || eventType === 'tap') {\n        this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n      }\n    },\n    firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n      var pointerIndex = this.mouse ? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n          pointerEvent = {},\n          i,\n          // for tap events\n      interval,\n          createNewDoubleTap; // if it's a doubletap then the event properties would have been\n      // copied from the tap event and provided as the pointer argument\n\n      if (eventType === 'doubletap') {\n        pointerEvent = pointer;\n      } else {\n        pointerExtend(pointerEvent, event);\n\n        if (event !== pointer) {\n          pointerExtend(pointerEvent, pointer);\n        }\n\n        pointerEvent.preventDefault = preventOriginalDefault;\n        pointerEvent.stopPropagation = InteractEvent.prototype.stopPropagation;\n        pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n        pointerEvent.interaction = this;\n        pointerEvent.timeStamp = new Date().getTime();\n        pointerEvent.originalEvent = event;\n        pointerEvent.originalPointer = pointer;\n        pointerEvent.type = eventType;\n        pointerEvent.pointerId = getPointerId(pointer);\n        pointerEvent.pointerType = this.mouse ? 'mouse' : !supportsPointerEvent ? 'touch' : isString(pointer.pointerType) ? pointer.pointerType : [,, 'touch', 'pen', 'mouse'][pointer.pointerType];\n      }\n\n      if (eventType === 'tap') {\n        pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n        interval = pointerEvent.timeStamp - this.tapTime;\n        createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap' && this.prevTap.target === pointerEvent.target && interval < 500);\n        pointerEvent.double = createNewDoubleTap;\n        this.tapTime = pointerEvent.timeStamp;\n      }\n\n      for (i = 0; i < targets.length; i++) {\n        pointerEvent.currentTarget = elements[i];\n        pointerEvent.interactable = targets[i];\n        targets[i].fire(pointerEvent);\n\n        if (pointerEvent.immediatePropagationStopped || pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget) {\n          break;\n        }\n      }\n\n      if (createNewDoubleTap) {\n        var doubleTap = {};\n        extend(doubleTap, pointerEvent);\n        doubleTap.dt = interval;\n        doubleTap.type = 'doubletap';\n        this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n        this.prevTap = doubleTap;\n      } else if (eventType === 'tap') {\n        this.prevTap = pointerEvent;\n      }\n    },\n    validateSelector: function (pointer, event, matches, matchElements) {\n      for (var i = 0, len = matches.length; i < len; i++) {\n        var match = matches[i],\n            matchElement = matchElements[i],\n            action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\n        if (action && withinInteractionLimit(match, matchElement, action)) {\n          this.target = match;\n          this.element = matchElement;\n          return action;\n        }\n      }\n    },\n    setSnapping: function (pageCoords, status) {\n      var snap = this.target.options[this.prepared.name].snap,\n          targets = [],\n          target,\n          page,\n          i;\n      status = status || this.snapStatus;\n\n      if (status.useStatusXY) {\n        page = {\n          x: status.x,\n          y: status.y\n        };\n      } else {\n        var origin = getOriginXY(this.target, this.element);\n        page = extend({}, pageCoords);\n        page.x -= origin.x;\n        page.y -= origin.y;\n      }\n\n      status.realX = page.x;\n      status.realY = page.y;\n      page.x = page.x - this.inertiaStatus.resumeDx;\n      page.y = page.y - this.inertiaStatus.resumeDy;\n      var len = snap.targets ? snap.targets.length : 0;\n\n      for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n        var relative = {\n          x: page.x - this.snapOffsets[relIndex].x,\n          y: page.y - this.snapOffsets[relIndex].y\n        };\n\n        for (i = 0; i < len; i++) {\n          if (isFunction(snap.targets[i])) {\n            target = snap.targets[i](relative.x, relative.y, this);\n          } else {\n            target = snap.targets[i];\n          }\n\n          if (!target) {\n            continue;\n          }\n\n          targets.push({\n            x: isNumber(target.x) ? target.x + this.snapOffsets[relIndex].x : relative.x,\n            y: isNumber(target.y) ? target.y + this.snapOffsets[relIndex].y : relative.y,\n            range: isNumber(target.range) ? target.range : snap.range\n          });\n        }\n      }\n\n      var closest = {\n        target: null,\n        inRange: false,\n        distance: 0,\n        range: 0,\n        dx: 0,\n        dy: 0\n      };\n\n      for (i = 0, len = targets.length; i < len; i++) {\n        target = targets[i];\n        var range = target.range,\n            dx = target.x - page.x,\n            dy = target.y - page.y,\n            distance = hypot(dx, dy),\n            inRange = distance <= range; // Infinite targets count as being out of range\n        // compared to non infinite ones that are in range\n\n        if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n          inRange = false;\n        }\n\n        if (!closest.target || (inRange // is the closest target in range?\n        ? closest.inRange && range !== Infinity // the pointer is relatively deeper in this target\n        ? distance / range < closest.distance / closest.range // this target has Infinite range and the closest doesn't\n        : range === Infinity && closest.range !== Infinity || // OR this target is closer that the previous closest\n        distance < closest.distance : // The other is not in range and the pointer is closer to this target\n        !closest.inRange && distance < closest.distance)) {\n          if (range === Infinity) {\n            inRange = true;\n          }\n\n          closest.target = target;\n          closest.distance = distance;\n          closest.range = range;\n          closest.inRange = inRange;\n          closest.dx = dx;\n          closest.dy = dy;\n          status.range = range;\n        }\n      }\n\n      var snapChanged;\n\n      if (closest.target) {\n        snapChanged = status.snappedX !== closest.target.x || status.snappedY !== closest.target.y;\n        status.snappedX = closest.target.x;\n        status.snappedY = closest.target.y;\n      } else {\n        snapChanged = true;\n        status.snappedX = NaN;\n        status.snappedY = NaN;\n      }\n\n      status.dx = closest.dx;\n      status.dy = closest.dy;\n      status.changed = snapChanged || closest.inRange && !status.locked;\n      status.locked = closest.inRange;\n      return status;\n    },\n    setRestriction: function (pageCoords, status) {\n      var target = this.target,\n          restrict = target && target.options[this.prepared.name].restrict,\n          restriction = restrict && restrict.restriction,\n          page;\n\n      if (!restriction) {\n        return status;\n      }\n\n      status = status || this.restrictStatus;\n      page = status.useStatusXY ? page = {\n        x: status.x,\n        y: status.y\n      } : page = extend({}, pageCoords);\n\n      if (status.snap && status.snap.locked) {\n        page.x += status.snap.dx || 0;\n        page.y += status.snap.dy || 0;\n      }\n\n      page.x -= this.inertiaStatus.resumeDx;\n      page.y -= this.inertiaStatus.resumeDy;\n      status.dx = 0;\n      status.dy = 0;\n      status.restricted = false;\n      var rect, restrictedX, restrictedY;\n\n      if (isString(restriction)) {\n        if (restriction === 'parent') {\n          restriction = parentElement(this.element);\n        } else if (restriction === 'self') {\n          restriction = target.getRect(this.element);\n        } else {\n          restriction = closest(this.element, restriction);\n        }\n\n        if (!restriction) {\n          return status;\n        }\n      }\n\n      if (isFunction(restriction)) {\n        restriction = restriction(page.x, page.y, this.element);\n      }\n\n      if (isElement(restriction)) {\n        restriction = getElementRect(restriction);\n      }\n\n      rect = restriction;\n\n      if (!restriction) {\n        restrictedX = page.x;\n        restrictedY = page.y;\n      } // object is assumed to have\n      // x, y, width, height or\n      // left, top, right, bottom\n      else if ('x' in restriction && 'y' in restriction) {\n          restrictedX = Math.max(Math.min(rect.x + rect.width - this.restrictOffset.right, page.x), rect.x + this.restrictOffset.left);\n          restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top);\n        } else {\n          restrictedX = Math.max(Math.min(rect.right - this.restrictOffset.right, page.x), rect.left + this.restrictOffset.left);\n          restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top + this.restrictOffset.top);\n        }\n\n      status.dx = restrictedX - page.x;\n      status.dy = restrictedY - page.y;\n      status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n      status.restricted = !!(status.dx || status.dy);\n      status.restrictedX = restrictedX;\n      status.restrictedY = restrictedY;\n      return status;\n    },\n    checkAndPreventDefault: function (event, interactable, element) {\n      if (!(interactable = interactable || this.target)) {\n        return;\n      }\n\n      var options = interactable.options,\n          prevent = options.preventDefault;\n\n      if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n        // do not preventDefault on pointerdown if the prepared action is a drag\n        // and dragging can only start from a certain direction - this allows\n        // a touch to pan the viewport if a drag isn't in the right direction\n        if (/down|start/i.test(event.type) && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n          return;\n        } // with manualStart, only preventDefault while interacting\n\n\n        if (options[this.prepared.name] && options[this.prepared.name].manualStart && !this.interacting()) {\n          return;\n        }\n\n        event.preventDefault();\n        return;\n      }\n\n      if (prevent === 'always') {\n        event.preventDefault();\n        return;\n      }\n    },\n    calcInertia: function (status) {\n      var inertiaOptions = this.target.options[this.prepared.name].inertia,\n          lambda = inertiaOptions.resistance,\n          inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n      status.x0 = this.prevEvent.pageX;\n      status.y0 = this.prevEvent.pageY;\n      status.t0 = status.startEvent.timeStamp / 1000;\n      status.sx = status.sy = 0;\n      status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n      status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n      status.te = inertiaDur;\n      status.lambda_v0 = lambda / status.v0;\n      status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n    },\n    autoScrollMove: function (pointer) {\n      if (!(this.interacting() && checkAutoScroll(this.target, this.prepared.name))) {\n        return;\n      }\n\n      if (this.inertiaStatus.active) {\n        autoScroll.x = autoScroll.y = 0;\n        return;\n      }\n\n      var top,\n          right,\n          bottom,\n          left,\n          options = this.target.options[this.prepared.name].autoScroll,\n          container = options.container || getWindow(this.element);\n\n      if (isWindow(container)) {\n        left = pointer.clientX < autoScroll.margin;\n        top = pointer.clientY < autoScroll.margin;\n        right = pointer.clientX > container.innerWidth - autoScroll.margin;\n        bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n      } else {\n        var rect = getElementClientRect(container);\n        left = pointer.clientX < rect.left + autoScroll.margin;\n        top = pointer.clientY < rect.top + autoScroll.margin;\n        right = pointer.clientX > rect.right - autoScroll.margin;\n        bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n      }\n\n      autoScroll.x = right ? 1 : left ? -1 : 0;\n      autoScroll.y = bottom ? 1 : top ? -1 : 0;\n\n      if (!autoScroll.isScrolling) {\n        // set the autoScroll properties to those of the target\n        autoScroll.margin = options.margin;\n        autoScroll.speed = options.speed;\n        autoScroll.start(this);\n      }\n    },\n    _updateEventTargets: function (target, currentTarget) {\n      this._eventTarget = target;\n      this._curEventTarget = currentTarget;\n    }\n  };\n\n  function getInteractionFromPointer(pointer, eventType, eventTarget) {\n    var i = 0,\n        len = interactions.length,\n        mouseEvent = /mouse/i.test(pointer.pointerType || eventType) // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n    || pointer.pointerType === 4,\n        interaction;\n    var id = getPointerId(pointer); // try to resume inertia with a new pointer\n\n    if (/down|start/i.test(eventType)) {\n      for (i = 0; i < len; i++) {\n        interaction = interactions[i];\n        var element = eventTarget;\n\n        if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume && interaction.mouse === mouseEvent) {\n          while (element) {\n            // if the element is the interaction element\n            if (element === interaction.element) {\n              return interaction;\n            }\n\n            element = parentElement(element);\n          }\n        }\n      }\n    } // if it's a mouse interaction\n\n\n    if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n      // find a mouse interaction that's not in inertia phase\n      for (i = 0; i < len; i++) {\n        if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n          return interactions[i];\n        }\n      } // find any interaction specifically for mouse.\n      // if the eventType is a mousedown, and inertia is active\n      // ignore the interaction\n\n\n      for (i = 0; i < len; i++) {\n        if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n          return interaction;\n        }\n      } // create a new interaction for mouse\n\n\n      interaction = new Interaction();\n      interaction.mouse = true;\n      return interaction;\n    } // get interaction that has this pointer\n\n\n    for (i = 0; i < len; i++) {\n      if (contains(interactions[i].pointerIds, id)) {\n        return interactions[i];\n      }\n    } // at this stage, a pointerUp should not return an interaction\n\n\n    if (/up|end|out/i.test(eventType)) {\n      return null;\n    } // get first idle interaction\n\n\n    for (i = 0; i < len; i++) {\n      interaction = interactions[i];\n\n      if ((!interaction.prepared.name || interaction.target.options.gesture.enabled) && !interaction.interacting() && !(!mouseEvent && interaction.mouse)) {\n        return interaction;\n      }\n    }\n\n    return new Interaction();\n  }\n\n  function doOnInteractions(method) {\n    return function (event) {\n      var interaction,\n          eventTarget = getActualElement(event.path ? event.path[0] : event.target),\n          curEventTarget = getActualElement(event.currentTarget),\n          i;\n\n      if (supportsTouch && /touch/.test(event.type)) {\n        prevTouchTime = new Date().getTime();\n\n        for (i = 0; i < event.changedTouches.length; i++) {\n          var pointer = event.changedTouches[i];\n          interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\n          if (!interaction) {\n            continue;\n          }\n\n          interaction._updateEventTargets(eventTarget, curEventTarget);\n\n          interaction[method](pointer, event, eventTarget, curEventTarget);\n        }\n      } else {\n        if (!supportsPointerEvent && /mouse/.test(event.type)) {\n          // ignore mouse events while touch interactions are active\n          for (i = 0; i < interactions.length; i++) {\n            if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n              return;\n            }\n          } // try to ignore mouse events that are simulated by the browser\n          // after a touch event\n\n\n          if (new Date().getTime() - prevTouchTime < 500) {\n            return;\n          }\n        }\n\n        interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\n        if (!interaction) {\n          return;\n        }\n\n        interaction._updateEventTargets(eventTarget, curEventTarget);\n\n        interaction[method](event, event, eventTarget, curEventTarget);\n      }\n    };\n  }\n\n  function InteractEvent(interaction, event, action, phase, element, related) {\n    var client,\n        page,\n        target = interaction.target,\n        snapStatus = interaction.snapStatus,\n        restrictStatus = interaction.restrictStatus,\n        pointers = interaction.pointers,\n        deltaSource = (target && target.options || defaultOptions).deltaSource,\n        sourceX = deltaSource + 'X',\n        sourceY = deltaSource + 'Y',\n        options = target ? target.options : defaultOptions,\n        origin = getOriginXY(target, element),\n        starting = phase === 'start',\n        ending = phase === 'end',\n        coords = starting ? interaction.startCoords : interaction.curCoords;\n    element = element || interaction.element;\n    page = extend({}, coords.page);\n    client = extend({}, coords.client);\n    page.x -= origin.x;\n    page.y -= origin.y;\n    client.x -= origin.x;\n    client.y -= origin.y;\n    var relativePoints = options[action].snap && options[action].snap.relativePoints;\n\n    if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n      this.snap = {\n        range: snapStatus.range,\n        locked: snapStatus.locked,\n        x: snapStatus.snappedX,\n        y: snapStatus.snappedY,\n        realX: snapStatus.realX,\n        realY: snapStatus.realY,\n        dx: snapStatus.dx,\n        dy: snapStatus.dy\n      };\n\n      if (snapStatus.locked) {\n        page.x += snapStatus.dx;\n        page.y += snapStatus.dy;\n        client.x += snapStatus.dx;\n        client.y += snapStatus.dy;\n      }\n    }\n\n    if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n      page.x += restrictStatus.dx;\n      page.y += restrictStatus.dy;\n      client.x += restrictStatus.dx;\n      client.y += restrictStatus.dy;\n      this.restrict = {\n        dx: restrictStatus.dx,\n        dy: restrictStatus.dy\n      };\n    }\n\n    this.pageX = page.x;\n    this.pageY = page.y;\n    this.clientX = client.x;\n    this.clientY = client.y;\n    this.x0 = interaction.startCoords.page.x - origin.x;\n    this.y0 = interaction.startCoords.page.y - origin.y;\n    this.clientX0 = interaction.startCoords.client.x - origin.x;\n    this.clientY0 = interaction.startCoords.client.y - origin.y;\n    this.ctrlKey = event.ctrlKey;\n    this.altKey = event.altKey;\n    this.shiftKey = event.shiftKey;\n    this.metaKey = event.metaKey;\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.target = element;\n    this.t0 = interaction.downTimes[0];\n    this.type = action + (phase || '');\n    this.interaction = interaction;\n    this.interactable = target;\n    var inertiaStatus = interaction.inertiaStatus;\n\n    if (inertiaStatus.active) {\n      this.detail = 'inertia';\n    }\n\n    if (related) {\n      this.relatedTarget = related;\n    } // end event dx, dy is difference between start and end points\n\n\n    if (ending) {\n      if (deltaSource === 'client') {\n        this.dx = client.x - interaction.startCoords.client.x;\n        this.dy = client.y - interaction.startCoords.client.y;\n      } else {\n        this.dx = page.x - interaction.startCoords.page.x;\n        this.dy = page.y - interaction.startCoords.page.y;\n      }\n    } else if (starting) {\n      this.dx = 0;\n      this.dy = 0;\n    } // copy properties from previousmove if starting inertia\n    else if (phase === 'inertiastart') {\n        this.dx = interaction.prevEvent.dx;\n        this.dy = interaction.prevEvent.dy;\n      } else {\n        if (deltaSource === 'client') {\n          this.dx = client.x - interaction.prevEvent.clientX;\n          this.dy = client.y - interaction.prevEvent.clientY;\n        } else {\n          this.dx = page.x - interaction.prevEvent.pageX;\n          this.dy = page.y - interaction.prevEvent.pageY;\n        }\n      }\n\n    if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia' && !inertiaStatus.active && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n      inertiaStatus.resumeDx += this.dx;\n      inertiaStatus.resumeDy += this.dy;\n      this.dx = this.dy = 0;\n    }\n\n    if (action === 'resize' && interaction.resizeAxes) {\n      if (options.resize.square) {\n        if (interaction.resizeAxes === 'y') {\n          this.dx = this.dy;\n        } else {\n          this.dy = this.dx;\n        }\n\n        this.axes = 'xy';\n      } else {\n        this.axes = interaction.resizeAxes;\n\n        if (interaction.resizeAxes === 'x') {\n          this.dy = 0;\n        } else if (interaction.resizeAxes === 'y') {\n          this.dx = 0;\n        }\n      }\n    } else if (action === 'gesture') {\n      this.touches = [pointers[0], pointers[1]];\n\n      if (starting) {\n        this.distance = touchDistance(pointers, deltaSource);\n        this.box = touchBBox(pointers);\n        this.scale = 1;\n        this.ds = 0;\n        this.angle = touchAngle(pointers, undefined, deltaSource);\n        this.da = 0;\n      } else if (ending || event instanceof InteractEvent) {\n        this.distance = interaction.prevEvent.distance;\n        this.box = interaction.prevEvent.box;\n        this.scale = interaction.prevEvent.scale;\n        this.ds = this.scale - 1;\n        this.angle = interaction.prevEvent.angle;\n        this.da = this.angle - interaction.gesture.startAngle;\n      } else {\n        this.distance = touchDistance(pointers, deltaSource);\n        this.box = touchBBox(pointers);\n        this.scale = this.distance / interaction.gesture.startDistance;\n        this.angle = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n        this.ds = this.scale - interaction.gesture.prevScale;\n        this.da = this.angle - interaction.gesture.prevAngle;\n      }\n    }\n\n    if (starting) {\n      this.timeStamp = interaction.downTimes[0];\n      this.dt = 0;\n      this.duration = 0;\n      this.speed = 0;\n      this.velocityX = 0;\n      this.velocityY = 0;\n    } else if (phase === 'inertiastart') {\n      this.timeStamp = interaction.prevEvent.timeStamp;\n      this.dt = interaction.prevEvent.dt;\n      this.duration = interaction.prevEvent.duration;\n      this.speed = interaction.prevEvent.speed;\n      this.velocityX = interaction.prevEvent.velocityX;\n      this.velocityY = interaction.prevEvent.velocityY;\n    } else {\n      this.timeStamp = new Date().getTime();\n      this.dt = this.timeStamp - interaction.prevEvent.timeStamp;\n      this.duration = this.timeStamp - interaction.downTimes[0];\n\n      if (event instanceof InteractEvent) {\n        var dx = this[sourceX] - interaction.prevEvent[sourceX],\n            dy = this[sourceY] - interaction.prevEvent[sourceY],\n            dt = this.dt / 1000;\n        this.speed = hypot(dx, dy) / dt;\n        this.velocityX = dx / dt;\n        this.velocityY = dy / dt;\n      } // if normal move or end event, use previous user event coords\n      else {\n          // speed and velocity in pixels per second\n          this.speed = interaction.pointerDelta[deltaSource].speed;\n          this.velocityX = interaction.pointerDelta[deltaSource].vx;\n          this.velocityY = interaction.pointerDelta[deltaSource].vy;\n        }\n    }\n\n    if ((ending || phase === 'inertiastart') && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n      var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n          overlap = 22.5;\n\n      if (angle < 0) {\n        angle += 360;\n      }\n\n      var left = 135 - overlap <= angle && angle < 225 + overlap,\n          up = 225 - overlap <= angle && angle < 315 + overlap,\n          right = !left && (315 - overlap <= angle || angle < 45 + overlap),\n          down = !up && 45 - overlap <= angle && angle < 135 + overlap;\n      this.swipe = {\n        up: up,\n        down: down,\n        left: left,\n        right: right,\n        angle: angle,\n        speed: interaction.prevEvent.speed,\n        velocity: {\n          x: interaction.prevEvent.velocityX,\n          y: interaction.prevEvent.velocityY\n        }\n      };\n    }\n  }\n\n  InteractEvent.prototype = {\n    preventDefault: blank,\n    stopImmediatePropagation: function () {\n      this.immediatePropagationStopped = this.propagationStopped = true;\n    },\n    stopPropagation: function () {\n      this.propagationStopped = true;\n    }\n  };\n\n  function preventOriginalDefault() {\n    this.originalEvent.preventDefault();\n  }\n\n  function getActionCursor(action) {\n    var cursor = '';\n\n    if (action.name === 'drag') {\n      cursor = actionCursors.drag;\n    }\n\n    if (action.name === 'resize') {\n      if (action.axis) {\n        cursor = actionCursors[action.name + action.axis];\n      } else if (action.edges) {\n        var cursorKey = 'resize',\n            edgeNames = ['top', 'bottom', 'left', 'right'];\n\n        for (var i = 0; i < 4; i++) {\n          if (action.edges[edgeNames[i]]) {\n            cursorKey += edgeNames[i];\n          }\n        }\n\n        cursor = actionCursors[cursorKey];\n      }\n    }\n\n    return cursor;\n  }\n\n  function checkResizeEdge(name, value, page, element, interactableElement, rect, margin) {\n    // false, '', undefined, null\n    if (!value) {\n      return false;\n    } // true value, use pointer coords and element rect\n\n\n    if (value === true) {\n      // if dimensions are negative, \"switch\" edges\n      var width = isNumber(rect.width) ? rect.width : rect.right - rect.left,\n          height = isNumber(rect.height) ? rect.height : rect.bottom - rect.top;\n\n      if (width < 0) {\n        if (name === 'left') {\n          name = 'right';\n        } else if (name === 'right') {\n          name = 'left';\n        }\n      }\n\n      if (height < 0) {\n        if (name === 'top') {\n          name = 'bottom';\n        } else if (name === 'bottom') {\n          name = 'top';\n        }\n      }\n\n      if (name === 'left') {\n        return page.x < (width >= 0 ? rect.left : rect.right) + margin;\n      }\n\n      if (name === 'top') {\n        return page.y < (height >= 0 ? rect.top : rect.bottom) + margin;\n      }\n\n      if (name === 'right') {\n        return page.x > (width >= 0 ? rect.right : rect.left) - margin;\n      }\n\n      if (name === 'bottom') {\n        return page.y > (height >= 0 ? rect.bottom : rect.top) - margin;\n      }\n    } // the remaining checks require an element\n\n\n    if (!isElement(element)) {\n      return false;\n    }\n\n    return isElement(value) // the value is an element to use as a resize handle\n    ? value === element // otherwise check if element matches value as selector\n    : matchesUpTo(element, value, interactableElement);\n  }\n\n  function defaultActionChecker(pointer, interaction, element) {\n    var rect = this.getRect(element),\n        shouldResize = false,\n        action = null,\n        resizeAxes = null,\n        resizeEdges,\n        page = extend({}, interaction.curCoords.page),\n        options = this.options;\n\n    if (!rect) {\n      return null;\n    }\n\n    if (actionIsEnabled.resize && options.resize.enabled) {\n      var resizeOptions = options.resize;\n      resizeEdges = {\n        left: false,\n        right: false,\n        top: false,\n        bottom: false\n      }; // if using resize.edges\n\n      if (isObject(resizeOptions.edges)) {\n        for (var edge in resizeEdges) {\n          resizeEdges[edge] = checkResizeEdge(edge, resizeOptions.edges[edge], page, interaction._eventTarget, element, rect, resizeOptions.margin || margin);\n        }\n\n        resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n        resizeEdges.top = resizeEdges.top && !resizeEdges.bottom;\n        shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n      } else {\n        var right = options.resize.axis !== 'y' && page.x > rect.right - margin,\n            bottom = options.resize.axis !== 'x' && page.y > rect.bottom - margin;\n        shouldResize = right || bottom;\n        resizeAxes = (right ? 'x' : '') + (bottom ? 'y' : '');\n      }\n    }\n\n    action = shouldResize ? 'resize' : actionIsEnabled.drag && options.drag.enabled ? 'drag' : null;\n\n    if (actionIsEnabled.gesture && interaction.pointerIds.length >= 2 && !(interaction.dragging || interaction.resizing)) {\n      action = 'gesture';\n    }\n\n    if (action) {\n      return {\n        name: action,\n        axis: resizeAxes,\n        edges: resizeEdges\n      };\n    }\n\n    return null;\n  } // Check if action is enabled globally and the current target supports it\n  // If so, return the validated action. Otherwise, return null\n\n\n  function validateAction(action, interactable) {\n    if (!isObject(action)) {\n      return null;\n    }\n\n    var actionName = action.name,\n        options = interactable.options;\n\n    if ((actionName === 'resize' && options.resize.enabled || actionName === 'drag' && options.drag.enabled || actionName === 'gesture' && options.gesture.enabled) && actionIsEnabled[actionName]) {\n      if (actionName === 'resize' || actionName === 'resizeyx') {\n        actionName = 'resizexy';\n      }\n\n      return action;\n    }\n\n    return null;\n  }\n\n  var listeners = {},\n      interactionListeners = ['dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove', 'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown', 'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd', 'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'];\n\n  for (var i = 0, len = interactionListeners.length; i < len; i++) {\n    var name = interactionListeners[i];\n    listeners[name] = doOnInteractions(name);\n  } // bound to the interactable context when a DOM event\n  // listener is added to a selector interactable\n\n\n  function delegateListener(event, useCapture) {\n    var fakeEvent = {},\n        delegated = delegatedEvents[event.type],\n        eventTarget = getActualElement(event.path ? event.path[0] : event.target),\n        element = eventTarget;\n    useCapture = useCapture ? true : false; // duplicate the event so that currentTarget can be changed\n\n    for (var prop in event) {\n      fakeEvent[prop] = event[prop];\n    }\n\n    fakeEvent.originalEvent = event;\n    fakeEvent.preventDefault = preventOriginalDefault; // climb up document tree looking for selector matches\n\n    while (isElement(element)) {\n      for (var i = 0; i < delegated.selectors.length; i++) {\n        var selector = delegated.selectors[i],\n            context = delegated.contexts[i];\n\n        if (matchesSelector(element, selector) && nodeContains(context, eventTarget) && nodeContains(context, element)) {\n          var listeners = delegated.listeners[i];\n          fakeEvent.currentTarget = element;\n\n          for (var j = 0; j < listeners.length; j++) {\n            if (listeners[j][1] === useCapture) {\n              listeners[j][0](fakeEvent);\n            }\n          }\n        }\n      }\n\n      element = parentElement(element);\n    }\n  }\n\n  function delegateUseCapture(event) {\n    return delegateListener.call(this, event, true);\n  }\n\n  interactables.indexOfElement = function indexOfElement(element, context) {\n    context = context || document;\n\n    for (var i = 0; i < this.length; i++) {\n      var interactable = this[i];\n\n      if (interactable.selector === element && interactable._context === context || !interactable.selector && interactable._element === element) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  interactables.get = function interactableGet(element, options) {\n    return this[this.indexOfElement(element, options && options.context)];\n  };\n\n  interactables.forEachSelector = function (callback) {\n    for (var i = 0; i < this.length; i++) {\n      var interactable = this[i];\n\n      if (!interactable.selector) {\n        continue;\n      }\n\n      var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\n      if (ret !== undefined) {\n        return ret;\n      }\n    }\n  };\n  /*\\\n   * interact\n   [ method ]\n   *\n   * The methods of this variable can be used to set elements as\n   * interactables and also to change various default settings.\n   *\n   * Calling it as a function and passing an element or a valid CSS selector\n   * string returns an Interactable object which has various methods to\n   * configure it.\n   *\n   - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n   = (object) An @Interactable\n   *\n   > Usage\n   | interact(document.getElementById('draggable')).draggable(true);\n   |\n   | var rectables = interact('rect');\n   | rectables\n   |     .gesturable(true)\n   |     .on('gesturemove', function (event) {\n   |         // something cool...\n   |     })\n   |     .autoScroll(true);\n  \\*/\n\n\n  function interact(element, options) {\n    return interactables.get(element, options) || new Interactable(element, options);\n  }\n  /*\\\n   * Interactable\n   [ property ]\n   **\n   * Object type returned by @interact\n  \\*/\n\n\n  function Interactable(element, options) {\n    this._element = element;\n    this._iEvents = this._iEvents || {};\n\n    var _window;\n\n    if (trySelector(element)) {\n      this.selector = element;\n      var context = options && options.context;\n      _window = context ? getWindow(context) : window;\n\n      if (context && (_window.Node ? context instanceof _window.Node : isElement(context) || context === _window.document)) {\n        this._context = context;\n      }\n    } else {\n      _window = getWindow(element);\n\n      if (isElement(element, _window)) {\n        if (supportsPointerEvent) {\n          events.add(this._element, pEventTypes.down, listeners.pointerDown);\n          events.add(this._element, pEventTypes.move, listeners.pointerHover);\n        } else {\n          events.add(this._element, 'mousedown', listeners.pointerDown);\n          events.add(this._element, 'mousemove', listeners.pointerHover);\n          events.add(this._element, 'touchstart', listeners.pointerDown);\n          events.add(this._element, 'touchmove', listeners.pointerHover);\n        }\n      }\n    }\n\n    this._doc = _window.document;\n\n    if (!contains(documents, this._doc)) {\n      listenToDocument(this._doc);\n    }\n\n    interactables.push(this);\n    this.set(options);\n  }\n\n  Interactable.prototype = {\n    setOnEvents: function (action, phases) {\n      if (action === 'drop') {\n        if (isFunction(phases.ondrop)) {\n          this.ondrop = phases.ondrop;\n        }\n\n        if (isFunction(phases.ondropactivate)) {\n          this.ondropactivate = phases.ondropactivate;\n        }\n\n        if (isFunction(phases.ondropdeactivate)) {\n          this.ondropdeactivate = phases.ondropdeactivate;\n        }\n\n        if (isFunction(phases.ondragenter)) {\n          this.ondragenter = phases.ondragenter;\n        }\n\n        if (isFunction(phases.ondragleave)) {\n          this.ondragleave = phases.ondragleave;\n        }\n\n        if (isFunction(phases.ondropmove)) {\n          this.ondropmove = phases.ondropmove;\n        }\n      } else {\n        action = 'on' + action;\n\n        if (isFunction(phases.onstart)) {\n          this[action + 'start'] = phases.onstart;\n        }\n\n        if (isFunction(phases.onmove)) {\n          this[action + 'move'] = phases.onmove;\n        }\n\n        if (isFunction(phases.onend)) {\n          this[action + 'end'] = phases.onend;\n        }\n\n        if (isFunction(phases.oninertiastart)) {\n          this[action + 'inertiastart'] = phases.oninertiastart;\n        }\n      }\n\n      return this;\n    },\n\n    /*\\\n     * Interactable.draggable\n     [ method ]\n     *\n     * Gets or sets whether drag actions can be performed on the\n     * Interactable\n     *\n     = (boolean) Indicates if this can be the target of drag events\n     | var isDraggable = interact('ul li').draggable();\n     * or\n     - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n     = (object) This Interactable\n     | interact(element).draggable({\n     |     onstart: function (event) {},\n     |     onmove : function (event) {},\n     |     onend  : function (event) {},\n     |\n     |     // the axis in which the first movement must be\n     |     // for the drag sequence to start\n     |     // 'xy' by default - any direction\n     |     axis: 'x' || 'y' || 'xy',\n     |\n     |     // max number of drags that can happen concurrently\n     |     // with elements of this Interactable. Infinity by default\n     |     max: Infinity,\n     |\n     |     // max number of drags that can target the same element+Interactable\n     |     // 1 by default\n     |     maxPerElement: 2\n     | });\n    \\*/\n    draggable: function (options) {\n      if (isObject(options)) {\n        this.options.drag.enabled = options.enabled === false ? false : true;\n        this.setPerAction('drag', options);\n        this.setOnEvents('drag', options);\n\n        if (/^x$|^y$|^xy$/.test(options.axis)) {\n          this.options.drag.axis = options.axis;\n        } else if (options.axis === null) {\n          delete this.options.drag.axis;\n        }\n\n        return this;\n      }\n\n      if (isBool(options)) {\n        this.options.drag.enabled = options;\n        return this;\n      }\n\n      return this.options.drag;\n    },\n    setPerAction: function (action, options) {\n      // for all the default per-action options\n      for (var option in options) {\n        // if this option exists for this action\n        if (option in defaultOptions[action]) {\n          // if the option in the options arg is an object value\n          if (isObject(options[option])) {\n            // duplicate the object\n            this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n            if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n              this.options[action][option].enabled = options[option].enabled === false ? false : true;\n            }\n          } else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n            this.options[action][option].enabled = options[option];\n          } else if (options[option] !== undefined) {\n            // or if it's not undefined, do a plain assignment\n            this.options[action][option] = options[option];\n          }\n        }\n      }\n    },\n\n    /*\\\n     * Interactable.dropzone\n     [ method ]\n     *\n     * Returns or sets whether elements can be dropped onto this\n     * Interactable to trigger drop events\n     *\n     * Dropzones can receive the following events:\n     *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n     *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n     *  - `dragmove` when a draggable that has entered the dropzone is moved\n     *  - `drop` when a draggable is dropped into this dropzone\n     *\n     *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n     *\n     *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n     *   - `'pointer'`, the pointer must be over the dropzone (default)\n     *   - `'center'`, the draggable element's center must be over the dropzone\n     *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n     *       e.g. `0.5` for drop to happen when half of the area of the\n     *       draggable is over the dropzone\n     *\n     - options (boolean | object | null) #optional The new value to be set.\n     | interact('.drop').dropzone({\n     |   accept: '.can-drop' || document.getElementById('single-drop'),\n     |   overlap: 'pointer' || 'center' || zeroToOne\n     | }\n     = (boolean | object) The current setting or this Interactable\n    \\*/\n    dropzone: function (options) {\n      if (isObject(options)) {\n        this.options.drop.enabled = options.enabled === false ? false : true;\n        this.setOnEvents('drop', options);\n\n        if (/^(pointer|center)$/.test(options.overlap)) {\n          this.options.drop.overlap = options.overlap;\n        } else if (isNumber(options.overlap)) {\n          this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n        }\n\n        if ('accept' in options) {\n          this.options.drop.accept = options.accept;\n        }\n\n        if ('checker' in options) {\n          this.options.drop.checker = options.checker;\n        }\n\n        return this;\n      }\n\n      if (isBool(options)) {\n        this.options.drop.enabled = options;\n        return this;\n      }\n\n      return this.options.drop;\n    },\n    dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n      var dropped = false; // if the dropzone has no rect (eg. display: none)\n      // call the custom dropChecker or just return false\n\n      if (!(rect = rect || this.getRect(dropElement))) {\n        return this.options.drop.checker ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement) : false;\n      }\n\n      var dropOverlap = this.options.drop.overlap;\n\n      if (dropOverlap === 'pointer') {\n        var page = getPageXY(dragEvent),\n            origin = getOriginXY(draggable, draggableElement),\n            horizontal,\n            vertical;\n        page.x += origin.x;\n        page.y += origin.y;\n        horizontal = page.x > rect.left && page.x < rect.right;\n        vertical = page.y > rect.top && page.y < rect.bottom;\n        dropped = horizontal && vertical;\n      }\n\n      var dragRect = draggable.getRect(draggableElement);\n\n      if (dropOverlap === 'center') {\n        var cx = dragRect.left + dragRect.width / 2,\n            cy = dragRect.top + dragRect.height / 2;\n        dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n      }\n\n      if (isNumber(dropOverlap)) {\n        var overlapArea = Math.max(0, Math.min(rect.right, dragRect.right) - Math.max(rect.left, dragRect.left)) * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top, dragRect.top)),\n            overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n        dropped = overlapRatio >= dropOverlap;\n      }\n\n      if (this.options.drop.checker) {\n        dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n      }\n\n      return dropped;\n    },\n\n    /*\\\n     * Interactable.dropChecker\n     [ method ]\n     *\n     * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n     *\n     * Gets or sets the function used to check if a dragged element is\n     * over this Interactable.\n     *\n     - checker (function) #optional The function that will be called when checking for a drop\n     = (Function | Interactable) The checker function or this Interactable\n     *\n     * The checker function takes the following arguments:\n     *\n     - dragEvent (InteractEvent) The related dragmove or dragend event\n     - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n     - dropped (boolean) The value from the default drop checker\n     - dropzone (Interactable) The dropzone interactable\n     - dropElement (Element) The dropzone element\n     - draggable (Interactable) The Interactable being dragged\n     - draggableElement (Element) The actual element that's being dragged\n     *\n     > Usage:\n     | interact(target)\n     | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n     |                       event,             // TouchEvent/PointerEvent/MouseEvent\n     |                       dropped,           // bool result of the default checker\n     |                       dropzone,          // dropzone Interactable\n     |                       dropElement,       // dropzone elemnt\n     |                       draggable,         // draggable Interactable\n     |                       draggableElement) {// draggable element\n     |\n     |   return dropped && event.target.hasAttribute('allow-drop');\n     | }\n    \\*/\n    dropChecker: function (checker) {\n      if (isFunction(checker)) {\n        this.options.drop.checker = checker;\n        return this;\n      }\n\n      if (checker === null) {\n        delete this.options.getRect;\n        return this;\n      }\n\n      return this.options.drop.checker;\n    },\n\n    /*\\\n     * Interactable.accept\n     [ method ]\n     *\n     * Deprecated. add an `accept` property to the options object passed to\n     * @Interactable.dropzone instead.\n     *\n     * Gets or sets the Element or CSS selector match that this\n     * Interactable accepts if it is a dropzone.\n     *\n     - newValue (Element | string | null) #optional\n     * If it is an Element, then only that element can be dropped into this dropzone.\n     * If it is a string, the element being dragged must match it as a selector.\n     * If it is null, the accept options is cleared - it accepts any element.\n     *\n     = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n    \\*/\n    accept: function (newValue) {\n      if (isElement(newValue)) {\n        this.options.drop.accept = newValue;\n        return this;\n      } // test if it is a valid CSS selector\n\n\n      if (trySelector(newValue)) {\n        this.options.drop.accept = newValue;\n        return this;\n      }\n\n      if (newValue === null) {\n        delete this.options.drop.accept;\n        return this;\n      }\n\n      return this.options.drop.accept;\n    },\n\n    /*\\\n     * Interactable.resizable\n     [ method ]\n     *\n     * Gets or sets whether resize actions can be performed on the\n     * Interactable\n     *\n     = (boolean) Indicates if this can be the target of resize elements\n     | var isResizeable = interact('input[type=text]').resizable();\n     * or\n     - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n     = (object) This Interactable\n     | interact(element).resizable({\n     |     onstart: function (event) {},\n     |     onmove : function (event) {},\n     |     onend  : function (event) {},\n     |\n     |     edges: {\n     |       top   : true,       // Use pointer coords to check for resize.\n     |       left  : false,      // Disable resizing from left edge.\n     |       bottom: '.resize-s',// Resize if pointer target matches selector\n     |       right : handleEl    // Resize if pointer target is the given Element\n     |     },\n     |\n     |     // Width and height can be adjusted independently. When `true`, width and\n     |     // height are adjusted at a 1:1 ratio.\n     |     square: false,\n     |\n     |     // Width and height can be adjusted independently. When `true`, width and\n     |     // height maintain the aspect ratio they had when resizing started.\n     |     preserveAspectRatio: false,\n     |\n     |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n     |     // 'negate' will allow the rect to have negative width/height\n     |     // 'reposition' will keep the width/height positive by swapping\n     |     // the top and bottom edges and/or swapping the left and right edges\n     |     invert: 'none' || 'negate' || 'reposition'\n     |\n     |     // limit multiple resizes.\n     |     // See the explanation in the @Interactable.draggable example\n     |     max: Infinity,\n     |     maxPerElement: 1,\n     | });\n    \\*/\n    resizable: function (options) {\n      if (isObject(options)) {\n        this.options.resize.enabled = options.enabled === false ? false : true;\n        this.setPerAction('resize', options);\n        this.setOnEvents('resize', options);\n\n        if (/^x$|^y$|^xy$/.test(options.axis)) {\n          this.options.resize.axis = options.axis;\n        } else if (options.axis === null) {\n          this.options.resize.axis = defaultOptions.resize.axis;\n        }\n\n        if (isBool(options.preserveAspectRatio)) {\n          this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n        } else if (isBool(options.square)) {\n          this.options.resize.square = options.square;\n        }\n\n        return this;\n      }\n\n      if (isBool(options)) {\n        this.options.resize.enabled = options;\n        return this;\n      }\n\n      return this.options.resize;\n    },\n\n    /*\\\n     * Interactable.squareResize\n     [ method ]\n     *\n     * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n     *\n     * Gets or sets whether resizing is forced 1:1 aspect\n     *\n     = (boolean) Current setting\n     *\n     * or\n     *\n     - newValue (boolean) #optional\n     = (object) this Interactable\n    \\*/\n    squareResize: function (newValue) {\n      if (isBool(newValue)) {\n        this.options.resize.square = newValue;\n        return this;\n      }\n\n      if (newValue === null) {\n        delete this.options.resize.square;\n        return this;\n      }\n\n      return this.options.resize.square;\n    },\n\n    /*\\\n     * Interactable.gesturable\n     [ method ]\n     *\n     * Gets or sets whether multitouch gestures can be performed on the\n     * Interactable's element\n     *\n     = (boolean) Indicates if this can be the target of gesture events\n     | var isGestureable = interact(element).gesturable();\n     * or\n     - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n     = (object) this Interactable\n     | interact(element).gesturable({\n     |     onstart: function (event) {},\n     |     onmove : function (event) {},\n     |     onend  : function (event) {},\n     |\n     |     // limit multiple gestures.\n     |     // See the explanation in @Interactable.draggable example\n     |     max: Infinity,\n     |     maxPerElement: 1,\n     | });\n    \\*/\n    gesturable: function (options) {\n      if (isObject(options)) {\n        this.options.gesture.enabled = options.enabled === false ? false : true;\n        this.setPerAction('gesture', options);\n        this.setOnEvents('gesture', options);\n        return this;\n      }\n\n      if (isBool(options)) {\n        this.options.gesture.enabled = options;\n        return this;\n      }\n\n      return this.options.gesture;\n    },\n\n    /*\\\n     * Interactable.autoScroll\n     [ method ]\n     **\n     * Deprecated. Add an `autoscroll` property to the options object\n     * passed to @Interactable.draggable or @Interactable.resizable instead.\n     *\n     * Returns or sets whether dragging and resizing near the edges of the\n     * window/container trigger autoScroll for this Interactable\n     *\n     = (object) Object with autoScroll properties\n     *\n     * or\n     *\n     - options (object | boolean) #optional\n     * options can be:\n     * - an object with margin, distance and interval properties,\n     * - true or false to enable or disable autoScroll or\n     = (Interactable) this Interactable\n    \\*/\n    autoScroll: function (options) {\n      if (isObject(options)) {\n        options = extend({\n          actions: ['drag', 'resize']\n        }, options);\n      } else if (isBool(options)) {\n        options = {\n          actions: ['drag', 'resize'],\n          enabled: options\n        };\n      }\n\n      return this.setOptions('autoScroll', options);\n    },\n\n    /*\\\n     * Interactable.snap\n     [ method ]\n     **\n     * Deprecated. Add a `snap` property to the options object passed\n     * to @Interactable.draggable or @Interactable.resizable instead.\n     *\n     * Returns or sets if and how action coordinates are snapped. By\n     * default, snapping is relative to the pointer coordinates. You can\n     * change this by setting the\n     * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n     **\n     = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n     **\n     * or\n     **\n     - options (object | boolean | null) #optional\n     = (Interactable) this Interactable\n     > Usage\n     | interact(document.querySelector('#thing')).snap({\n     |     targets: [\n     |         // snap to this specific point\n     |         {\n     |             x: 100,\n     |             y: 100,\n     |             range: 25\n     |         },\n     |         // give this function the x and y page coords and snap to the object returned\n     |         function (x, y) {\n     |             return {\n     |                 x: x,\n     |                 y: (75 + 50 * Math.sin(x * 0.04)),\n     |                 range: 40\n     |             };\n     |         },\n     |         // create a function that snaps to a grid\n     |         interact.createSnapGrid({\n     |             x: 50,\n     |             y: 50,\n     |             range: 10,              // optional\n     |             offset: { x: 5, y: 10 } // optional\n     |         })\n     |     ],\n     |     // do not snap during normal movement.\n     |     // Instead, trigger only one snapped move event\n     |     // immediately before the end event.\n     |     endOnly: true,\n     |\n     |     relativePoints: [\n     |         { x: 0, y: 0 },  // snap relative to the top left of the element\n     |         { x: 1, y: 1 },  // and also to the bottom right\n     |     ],  \n     |\n     |     // offset the snap target coordinates\n     |     // can be an object with x/y or 'startCoords'\n     |     offset: { x: 50, y: 50 }\n     |   }\n     | });\n    \\*/\n    snap: function (options) {\n      var ret = this.setOptions('snap', options);\n\n      if (ret === this) {\n        return this;\n      }\n\n      return ret.drag;\n    },\n    setOptions: function (option, options) {\n      var actions = options && isArray(options.actions) ? options.actions : ['drag'];\n      var i;\n\n      if (isObject(options) || isBool(options)) {\n        for (i = 0; i < actions.length; i++) {\n          var action = /resize/.test(actions[i]) ? 'resize' : actions[i];\n\n          if (!isObject(this.options[action])) {\n            continue;\n          }\n\n          var thisOption = this.options[action][option];\n\n          if (isObject(options)) {\n            extend(thisOption, options);\n            thisOption.enabled = options.enabled === false ? false : true;\n\n            if (option === 'snap') {\n              if (thisOption.mode === 'grid') {\n                thisOption.targets = [interact.createSnapGrid(extend({\n                  offset: thisOption.gridOffset || {\n                    x: 0,\n                    y: 0\n                  }\n                }, thisOption.grid || {}))];\n              } else if (thisOption.mode === 'anchor') {\n                thisOption.targets = thisOption.anchors;\n              } else if (thisOption.mode === 'path') {\n                thisOption.targets = thisOption.paths;\n              }\n\n              if ('elementOrigin' in options) {\n                thisOption.relativePoints = [options.elementOrigin];\n              }\n            }\n          } else if (isBool(options)) {\n            thisOption.enabled = options;\n          }\n        }\n\n        return this;\n      }\n\n      var ret = {},\n          allActions = ['drag', 'resize', 'gesture'];\n\n      for (i = 0; i < allActions.length; i++) {\n        if (option in defaultOptions[allActions[i]]) {\n          ret[allActions[i]] = this.options[allActions[i]][option];\n        }\n      }\n\n      return ret;\n    },\n\n    /*\\\n     * Interactable.inertia\n     [ method ]\n     **\n     * Deprecated. Add an `inertia` property to the options object passed\n     * to @Interactable.draggable or @Interactable.resizable instead.\n     *\n     * Returns or sets if and how events continue to run after the pointer is released\n     **\n     = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n     **\n     * or\n     **\n     - options (object | boolean | null) #optional\n     = (Interactable) this Interactable\n     > Usage\n     | // enable and use default settings\n     | interact(element).inertia(true);\n     |\n     | // enable and use custom settings\n     | interact(element).inertia({\n     |     // value greater than 0\n     |     // high values slow the object down more quickly\n     |     resistance     : 16,\n     |\n     |     // the minimum launch speed (pixels per second) that results in inertia start\n     |     minSpeed       : 200,\n     |\n     |     // inertia will stop when the object slows down to this speed\n     |     endSpeed       : 20,\n     |\n     |     // boolean; should actions be resumed when the pointer goes down during inertia\n     |     allowResume    : true,\n     |\n     |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n     |     zeroResumeDelta: false,\n     |\n     |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n     |     // the pointer without triggering inertia will animate from the release\n     |     // point to the snaped/restricted point in the given amount of time (ms)\n     |     smoothEndDuration: 300,\n     |\n     |     // an array of action types that can have inertia (no gesture)\n     |     actions        : ['drag', 'resize']\n     | });\n     |\n     | // reset custom settings and use all defaults\n     | interact(element).inertia(null);\n    \\*/\n    inertia: function (options) {\n      var ret = this.setOptions('inertia', options);\n\n      if (ret === this) {\n        return this;\n      }\n\n      return ret.drag;\n    },\n    getAction: function (pointer, event, interaction, element) {\n      var action = this.defaultActionChecker(pointer, interaction, element);\n\n      if (this.options.actionChecker) {\n        return this.options.actionChecker(pointer, event, action, this, element, interaction);\n      }\n\n      return action;\n    },\n    defaultActionChecker: defaultActionChecker,\n\n    /*\\\n     * Interactable.actionChecker\n     [ method ]\n     *\n     * Gets or sets the function used to check action to be performed on\n     * pointerDown\n     *\n     - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n     = (Function | Interactable) The checker function or this Interactable\n     *\n     | interact('.resize-drag')\n     |   .resizable(true)\n     |   .draggable(true)\n     |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n     |\n     |   if (interact.matchesSelector(event.target, '.drag-handle') {\n     |     // force drag with handle target\n     |     action.name = drag;\n     |   }\n     |   else {\n     |     // resize from the top and right edges\n     |     action.name  = 'resize';\n     |     action.edges = { top: true, right: true };\n     |   }\n     |\n     |   return action;\n     | });\n    \\*/\n    actionChecker: function (checker) {\n      if (isFunction(checker)) {\n        this.options.actionChecker = checker;\n        return this;\n      }\n\n      if (checker === null) {\n        delete this.options.actionChecker;\n        return this;\n      }\n\n      return this.options.actionChecker;\n    },\n\n    /*\\\n     * Interactable.getRect\n     [ method ]\n     *\n     * The default function to get an Interactables bounding rect. Can be\n     * overridden using @Interactable.rectChecker.\n     *\n     - element (Element) #optional The element to measure.\n     = (object) The object's bounding rectangle.\n     o {\n     o     top   : 0,\n     o     left  : 0,\n     o     bottom: 0,\n     o     right : 0,\n     o     width : 0,\n     o     height: 0\n     o }\n    \\*/\n    getRect: function rectCheck(element) {\n      element = element || this._element;\n\n      if (this.selector && !isElement(element)) {\n        element = this._context.querySelector(this.selector);\n      }\n\n      return getElementRect(element);\n    },\n\n    /*\\\n     * Interactable.rectChecker\n     [ method ]\n     *\n     * Returns or sets the function used to calculate the interactable's\n     * element's rectangle\n     *\n     - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n     = (function | object) The checker function or this Interactable\n    \\*/\n    rectChecker: function (checker) {\n      if (isFunction(checker)) {\n        this.getRect = checker;\n        return this;\n      }\n\n      if (checker === null) {\n        delete this.options.getRect;\n        return this;\n      }\n\n      return this.getRect;\n    },\n\n    /*\\\n     * Interactable.styleCursor\n     [ method ]\n     *\n     * Returns or sets whether the action that would be performed when the\n     * mouse on the element are checked on `mousemove` so that the cursor\n     * may be styled appropriately\n     *\n     - newValue (boolean) #optional\n     = (boolean | Interactable) The current setting or this Interactable\n    \\*/\n    styleCursor: function (newValue) {\n      if (isBool(newValue)) {\n        this.options.styleCursor = newValue;\n        return this;\n      }\n\n      if (newValue === null) {\n        delete this.options.styleCursor;\n        return this;\n      }\n\n      return this.options.styleCursor;\n    },\n\n    /*\\\n     * Interactable.preventDefault\n     [ method ]\n     *\n     * Returns or sets whether to prevent the browser's default behaviour\n     * in response to pointer events. Can be set to:\n     *  - `'always'` to always prevent\n     *  - `'never'` to never prevent\n     *  - `'auto'` to let interact.js try to determine what would be best\n     *\n     - newValue (string) #optional `true`, `false` or `'auto'`\n     = (string | Interactable) The current setting or this Interactable\n    \\*/\n    preventDefault: function (newValue) {\n      if (/^(always|never|auto)$/.test(newValue)) {\n        this.options.preventDefault = newValue;\n        return this;\n      }\n\n      if (isBool(newValue)) {\n        this.options.preventDefault = newValue ? 'always' : 'never';\n        return this;\n      }\n\n      return this.options.preventDefault;\n    },\n\n    /*\\\n     * Interactable.origin\n     [ method ]\n     *\n     * Gets or sets the origin of the Interactable's element.  The x and y\n     * of the origin will be subtracted from action event coordinates.\n     *\n     - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n     * OR\n     - origin (Element) #optional An HTML or SVG Element whose rect will be used\n     **\n     = (object) The current origin or this Interactable\n    \\*/\n    origin: function (newValue) {\n      if (trySelector(newValue)) {\n        this.options.origin = newValue;\n        return this;\n      } else if (isObject(newValue)) {\n        this.options.origin = newValue;\n        return this;\n      }\n\n      return this.options.origin;\n    },\n\n    /*\\\n     * Interactable.deltaSource\n     [ method ]\n     *\n     * Returns or sets the mouse coordinate types used to calculate the\n     * movement of the pointer.\n     *\n     - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n     = (string | object) The current deltaSource or this Interactable\n    \\*/\n    deltaSource: function (newValue) {\n      if (newValue === 'page' || newValue === 'client') {\n        this.options.deltaSource = newValue;\n        return this;\n      }\n\n      return this.options.deltaSource;\n    },\n\n    /*\\\n     * Interactable.restrict\n     [ method ]\n     **\n     * Deprecated. Add a `restrict` property to the options object passed to\n     * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n     *\n     * Returns or sets the rectangles within which actions on this\n     * interactable (after snap calculations) are restricted. By default,\n     * restricting is relative to the pointer coordinates. You can change\n     * this by setting the\n     * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n     **\n     - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n     = (object) The current restrictions object or this Interactable\n     **\n     | interact(element).restrict({\n     |     // the rect will be `interact.getElementRect(element.parentNode)`\n     |     drag: element.parentNode,\n     |\n     |     // x and y are relative to the the interactable's origin\n     |     resize: { x: 100, y: 100, width: 200, height: 200 }\n     | })\n     |\n     | interact('.draggable').restrict({\n     |     // the rect will be the selected element's parent\n     |     drag: 'parent',\n     |\n     |     // do not restrict during normal movement.\n     |     // Instead, trigger only one restricted move event\n     |     // immediately before the end event.\n     |     endOnly: true,\n     |\n     |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n     |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n     | });\n    \\*/\n    restrict: function (options) {\n      if (!isObject(options)) {\n        return this.setOptions('restrict', options);\n      }\n\n      var actions = ['drag', 'resize', 'gesture'],\n          ret;\n\n      for (var i = 0; i < actions.length; i++) {\n        var action = actions[i];\n\n        if (action in options) {\n          var perAction = extend({\n            actions: [action],\n            restriction: options[action]\n          }, options);\n          ret = this.setOptions('restrict', perAction);\n        }\n      }\n\n      return ret;\n    },\n\n    /*\\\n     * Interactable.context\n     [ method ]\n     *\n     * Gets the selector context Node of the Interactable. The default is `window.document`.\n     *\n     = (Node) The context Node of this Interactable\n     **\n    \\*/\n    context: function () {\n      return this._context;\n    },\n    _context: document,\n\n    /*\\\n     * Interactable.ignoreFrom\n     [ method ]\n     *\n     * If the target of the `mousedown`, `pointerdown` or `touchstart`\n     * event or any of it's parents match the given CSS selector or\n     * Element, no drag/resize/gesture is started.\n     *\n     - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n     = (string | Element | object) The current ignoreFrom value or this Interactable\n     **\n     | interact(element, { ignoreFrom: document.getElementById('no-action') });\n     | // or\n     | interact(element).ignoreFrom('input, textarea, a');\n    \\*/\n    ignoreFrom: function (newValue) {\n      if (trySelector(newValue)) {\n        // CSS selector to match event.target\n        this.options.ignoreFrom = newValue;\n        return this;\n      }\n\n      if (isElement(newValue)) {\n        // specific element\n        this.options.ignoreFrom = newValue;\n        return this;\n      }\n\n      return this.options.ignoreFrom;\n    },\n\n    /*\\\n     * Interactable.allowFrom\n     [ method ]\n     *\n     * A drag/resize/gesture is started only If the target of the\n     * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n     * parents match the given CSS selector or Element.\n     *\n     - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n     = (string | Element | object) The current allowFrom value or this Interactable\n     **\n     | interact(element, { allowFrom: document.getElementById('drag-handle') });\n     | // or\n     | interact(element).allowFrom('.handle');\n    \\*/\n    allowFrom: function (newValue) {\n      if (trySelector(newValue)) {\n        // CSS selector to match event.target\n        this.options.allowFrom = newValue;\n        return this;\n      }\n\n      if (isElement(newValue)) {\n        // specific element\n        this.options.allowFrom = newValue;\n        return this;\n      }\n\n      return this.options.allowFrom;\n    },\n\n    /*\\\n     * Interactable.element\n     [ method ]\n     *\n     * If this is not a selector Interactable, it returns the element this\n     * interactable represents\n     *\n     = (Element) HTML / SVG Element\n    \\*/\n    element: function () {\n      return this._element;\n    },\n\n    /*\\\n     * Interactable.fire\n     [ method ]\n     *\n     * Calls listeners for the given InteractEvent type bound globally\n     * and directly to this Interactable\n     *\n     - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n     = (Interactable) this Interactable\n    \\*/\n    fire: function (iEvent) {\n      if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n        return this;\n      }\n\n      var listeners,\n          i,\n          len,\n          onEvent = 'on' + iEvent.type,\n          funcName = ''; // Interactable#on() listeners\n\n      if (iEvent.type in this._iEvents) {\n        listeners = this._iEvents[iEvent.type];\n\n        for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n          funcName = listeners[i].name;\n          listeners[i](iEvent);\n        }\n      } // interactable.onevent listener\n\n\n      if (isFunction(this[onEvent])) {\n        funcName = this[onEvent].name;\n        this[onEvent](iEvent);\n      } // interact.on() listeners\n\n\n      if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type])) {\n        for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n          funcName = listeners[i].name;\n          listeners[i](iEvent);\n        }\n      }\n\n      return this;\n    },\n\n    /*\\\n     * Interactable.on\n     [ method ]\n     *\n     * Binds a listener for an InteractEvent or DOM event.\n     *\n     - eventType  (string | array | object) The types of events to listen for\n     - listener   (function) The function to be called on the given event(s)\n     - useCapture (boolean) #optional useCapture flag for addEventListener\n     = (object) This Interactable\n    \\*/\n    on: function (eventType, listener, useCapture) {\n      var i;\n\n      if (isString(eventType) && eventType.search(' ') !== -1) {\n        eventType = eventType.trim().split(/ +/);\n      }\n\n      if (isArray(eventType)) {\n        for (i = 0; i < eventType.length; i++) {\n          this.on(eventType[i], listener, useCapture);\n        }\n\n        return this;\n      }\n\n      if (isObject(eventType)) {\n        for (var prop in eventType) {\n          this.on(prop, eventType[prop], listener);\n        }\n\n        return this;\n      }\n\n      if (eventType === 'wheel') {\n        eventType = wheelEvent;\n      } // convert to boolean\n\n\n      useCapture = useCapture ? true : false;\n\n      if (contains(eventTypes, eventType)) {\n        // if this type of event was never bound to this Interactable\n        if (!(eventType in this._iEvents)) {\n          this._iEvents[eventType] = [listener];\n        } else {\n          this._iEvents[eventType].push(listener);\n        }\n      } // delegated event for selector\n      else if (this.selector) {\n          if (!delegatedEvents[eventType]) {\n            delegatedEvents[eventType] = {\n              selectors: [],\n              contexts: [],\n              listeners: []\n            }; // add delegate listener functions\n\n            for (i = 0; i < documents.length; i++) {\n              events.add(documents[i], eventType, delegateListener);\n              events.add(documents[i], eventType, delegateUseCapture, true);\n            }\n          }\n\n          var delegated = delegatedEvents[eventType],\n              index;\n\n          for (index = delegated.selectors.length - 1; index >= 0; index--) {\n            if (delegated.selectors[index] === this.selector && delegated.contexts[index] === this._context) {\n              break;\n            }\n          }\n\n          if (index === -1) {\n            index = delegated.selectors.length;\n            delegated.selectors.push(this.selector);\n            delegated.contexts.push(this._context);\n            delegated.listeners.push([]);\n          } // keep listener and useCapture flag\n\n\n          delegated.listeners[index].push([listener, useCapture]);\n        } else {\n          events.add(this._element, eventType, listener, useCapture);\n        }\n\n      return this;\n    },\n\n    /*\\\n     * Interactable.off\n     [ method ]\n     *\n     * Removes an InteractEvent or DOM event listener\n     *\n     - eventType  (string | array | object) The types of events that were listened for\n     - listener   (function) The listener function to be removed\n     - useCapture (boolean) #optional useCapture flag for removeEventListener\n     = (object) This Interactable\n    \\*/\n    off: function (eventType, listener, useCapture) {\n      var i;\n\n      if (isString(eventType) && eventType.search(' ') !== -1) {\n        eventType = eventType.trim().split(/ +/);\n      }\n\n      if (isArray(eventType)) {\n        for (i = 0; i < eventType.length; i++) {\n          this.off(eventType[i], listener, useCapture);\n        }\n\n        return this;\n      }\n\n      if (isObject(eventType)) {\n        for (var prop in eventType) {\n          this.off(prop, eventType[prop], listener);\n        }\n\n        return this;\n      }\n\n      var eventList,\n          index = -1; // convert to boolean\n\n      useCapture = useCapture ? true : false;\n\n      if (eventType === 'wheel') {\n        eventType = wheelEvent;\n      } // if it is an action event type\n\n\n      if (contains(eventTypes, eventType)) {\n        eventList = this._iEvents[eventType];\n\n        if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n          this._iEvents[eventType].splice(index, 1);\n        }\n      } // delegated event\n      else if (this.selector) {\n          var delegated = delegatedEvents[eventType],\n              matchFound = false;\n\n          if (!delegated) {\n            return this;\n          } // count from last index of delegated to 0\n\n\n          for (index = delegated.selectors.length - 1; index >= 0; index--) {\n            // look for matching selector and context Node\n            if (delegated.selectors[index] === this.selector && delegated.contexts[index] === this._context) {\n              var listeners = delegated.listeners[index]; // each item of the listeners array is an array: [function, useCaptureFlag]\n\n              for (i = listeners.length - 1; i >= 0; i--) {\n                var fn = listeners[i][0],\n                    useCap = listeners[i][1]; // check if the listener functions and useCapture flags match\n\n                if (fn === listener && useCap === useCapture) {\n                  // remove the listener from the array of listeners\n                  listeners.splice(i, 1); // if all listeners for this interactable have been removed\n                  // remove the interactable from the delegated arrays\n\n                  if (!listeners.length) {\n                    delegated.selectors.splice(index, 1);\n                    delegated.contexts.splice(index, 1);\n                    delegated.listeners.splice(index, 1); // remove delegate function from context\n\n                    events.remove(this._context, eventType, delegateListener);\n                    events.remove(this._context, eventType, delegateUseCapture, true); // remove the arrays if they are empty\n\n                    if (!delegated.selectors.length) {\n                      delegatedEvents[eventType] = null;\n                    }\n                  } // only remove one listener\n\n\n                  matchFound = true;\n                  break;\n                }\n              }\n\n              if (matchFound) {\n                break;\n              }\n            }\n          }\n        } // remove listener from this Interatable's element\n        else {\n            events.remove(this._element, eventType, listener, useCapture);\n          }\n\n      return this;\n    },\n\n    /*\\\n     * Interactable.set\n     [ method ]\n     *\n     * Reset the options of this Interactable\n     - options (object) The new settings to apply\n     = (object) This Interactable\n    \\*/\n    set: function (options) {\n      if (!isObject(options)) {\n        options = {};\n      }\n\n      this.options = extend({}, defaultOptions.base);\n      var i,\n          actions = ['drag', 'drop', 'resize', 'gesture'],\n          methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n          perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\n      for (i = 0; i < actions.length; i++) {\n        var action = actions[i];\n        this.options[action] = extend({}, defaultOptions[action]);\n        this.setPerAction(action, perActions);\n        this[methods[i]](options[action]);\n      }\n\n      var settings = ['accept', 'actionChecker', 'allowFrom', 'deltaSource', 'dropChecker', 'ignoreFrom', 'origin', 'preventDefault', 'rectChecker', 'styleCursor'];\n\n      for (i = 0, len = settings.length; i < len; i++) {\n        var setting = settings[i];\n        this.options[setting] = defaultOptions.base[setting];\n\n        if (setting in options) {\n          this[setting](options[setting]);\n        }\n      }\n\n      return this;\n    },\n\n    /*\\\n     * Interactable.unset\n     [ method ]\n     *\n     * Remove this interactable from the list of interactables and remove\n     * it's drag, drop, resize and gesture capabilities\n     *\n     = (object) @interact\n    \\*/\n    unset: function () {\n      events.remove(this._element, 'all');\n\n      if (!isString(this.selector)) {\n        events.remove(this, 'all');\n\n        if (this.options.styleCursor) {\n          this._element.style.cursor = '';\n        }\n      } else {\n        // remove delegated events\n        for (var type in delegatedEvents) {\n          var delegated = delegatedEvents[type];\n\n          for (var i = 0; i < delegated.selectors.length; i++) {\n            if (delegated.selectors[i] === this.selector && delegated.contexts[i] === this._context) {\n              delegated.selectors.splice(i, 1);\n              delegated.contexts.splice(i, 1);\n              delegated.listeners.splice(i, 1); // remove the arrays if they are empty\n\n              if (!delegated.selectors.length) {\n                delegatedEvents[type] = null;\n              }\n            }\n\n            events.remove(this._context, type, delegateListener);\n            events.remove(this._context, type, delegateUseCapture, true);\n            break;\n          }\n        }\n      }\n\n      this.dropzone(false);\n      interactables.splice(indexOf(interactables, this), 1);\n      return interact;\n    }\n  };\n\n  function warnOnce(method, message) {\n    var warned = false;\n    return function () {\n      if (!warned) {\n        window.console.warn(message);\n        warned = true;\n      }\n\n      return method.apply(this, arguments);\n    };\n  }\n\n  Interactable.prototype.snap = warnOnce(Interactable.prototype.snap, 'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n  Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict, 'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n  Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia, 'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n  Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll, 'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n  Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize, 'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n  Interactable.prototype.accept = warnOnce(Interactable.prototype.accept, 'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n  Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker, 'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n  Interactable.prototype.context = warnOnce(Interactable.prototype.context, 'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n  /*\\\n   * interact.isSet\n   [ method ]\n   *\n   * Check if an element has been set\n   - element (Element) The Element being searched for\n   = (boolean) Indicates if the element or CSS selector was previously passed to interact\n  \\*/\n\n  interact.isSet = function (element, options) {\n    return interactables.indexOfElement(element, options && options.context) !== -1;\n  };\n  /*\\\n   * interact.on\n   [ method ]\n   *\n   * Adds a global listener for an InteractEvent or adds a DOM event to\n   * `document`\n   *\n   - type       (string | array | object) The types of events to listen for\n   - listener   (function) The function to be called on the given event(s)\n   - useCapture (boolean) #optional useCapture flag for addEventListener\n   = (object) interact\n  \\*/\n\n\n  interact.on = function (type, listener, useCapture) {\n    if (isString(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/);\n    }\n\n    if (isArray(type)) {\n      for (var i = 0; i < type.length; i++) {\n        interact.on(type[i], listener, useCapture);\n      }\n\n      return interact;\n    }\n\n    if (isObject(type)) {\n      for (var prop in type) {\n        interact.on(prop, type[prop], listener);\n      }\n\n      return interact;\n    } // if it is an InteractEvent type, add listener to globalEvents\n\n\n    if (contains(eventTypes, type)) {\n      // if this type of event was never bound\n      if (!globalEvents[type]) {\n        globalEvents[type] = [listener];\n      } else {\n        globalEvents[type].push(listener);\n      }\n    } // If non InteractEvent type, addEventListener to document\n    else {\n        events.add(document, type, listener, useCapture);\n      }\n\n    return interact;\n  };\n  /*\\\n   * interact.off\n   [ method ]\n   *\n   * Removes a global InteractEvent listener or DOM event from `document`\n   *\n   - type       (string | array | object) The types of events that were listened for\n   - listener   (function) The listener function to be removed\n   - useCapture (boolean) #optional useCapture flag for removeEventListener\n   = (object) interact\n   \\*/\n\n\n  interact.off = function (type, listener, useCapture) {\n    if (isString(type) && type.search(' ') !== -1) {\n      type = type.trim().split(/ +/);\n    }\n\n    if (isArray(type)) {\n      for (var i = 0; i < type.length; i++) {\n        interact.off(type[i], listener, useCapture);\n      }\n\n      return interact;\n    }\n\n    if (isObject(type)) {\n      for (var prop in type) {\n        interact.off(prop, type[prop], listener);\n      }\n\n      return interact;\n    }\n\n    if (!contains(eventTypes, type)) {\n      events.remove(document, type, listener, useCapture);\n    } else {\n      var index;\n\n      if (type in globalEvents && (index = indexOf(globalEvents[type], listener)) !== -1) {\n        globalEvents[type].splice(index, 1);\n      }\n    }\n\n    return interact;\n  };\n  /*\\\n   * interact.enableDragging\n   [ method ]\n   *\n   * Deprecated.\n   *\n   * Returns or sets whether dragging is enabled for any Interactables\n   *\n   - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n   = (boolean | object) The current setting or interact\n  \\*/\n\n\n  interact.enableDragging = warnOnce(function (newValue) {\n    if (newValue !== null && newValue !== undefined) {\n      actionIsEnabled.drag = newValue;\n      return interact;\n    }\n\n    return actionIsEnabled.drag;\n  }, 'interact.enableDragging is deprecated and will soon be removed.');\n  /*\\\n   * interact.enableResizing\n   [ method ]\n   *\n   * Deprecated.\n   *\n   * Returns or sets whether resizing is enabled for any Interactables\n   *\n   - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n   = (boolean | object) The current setting or interact\n  \\*/\n\n  interact.enableResizing = warnOnce(function (newValue) {\n    if (newValue !== null && newValue !== undefined) {\n      actionIsEnabled.resize = newValue;\n      return interact;\n    }\n\n    return actionIsEnabled.resize;\n  }, 'interact.enableResizing is deprecated and will soon be removed.');\n  /*\\\n   * interact.enableGesturing\n   [ method ]\n   *\n   * Deprecated.\n   *\n   * Returns or sets whether gesturing is enabled for any Interactables\n   *\n   - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n   = (boolean | object) The current setting or interact\n  \\*/\n\n  interact.enableGesturing = warnOnce(function (newValue) {\n    if (newValue !== null && newValue !== undefined) {\n      actionIsEnabled.gesture = newValue;\n      return interact;\n    }\n\n    return actionIsEnabled.gesture;\n  }, 'interact.enableGesturing is deprecated and will soon be removed.');\n  interact.eventTypes = eventTypes;\n  /*\\\n   * interact.debug\n   [ method ]\n   *\n   * Returns debugging data\n   = (object) An object with properties that outline the current state and expose internal functions and variables\n  \\*/\n\n  interact.debug = function () {\n    var interaction = interactions[0] || new Interaction();\n    return {\n      interactions: interactions,\n      target: interaction.target,\n      dragging: interaction.dragging,\n      resizing: interaction.resizing,\n      gesturing: interaction.gesturing,\n      prepared: interaction.prepared,\n      matches: interaction.matches,\n      matchElements: interaction.matchElements,\n      prevCoords: interaction.prevCoords,\n      startCoords: interaction.startCoords,\n      pointerIds: interaction.pointerIds,\n      pointers: interaction.pointers,\n      addPointer: listeners.addPointer,\n      removePointer: listeners.removePointer,\n      recordPointer: listeners.recordPointer,\n      snap: interaction.snapStatus,\n      restrict: interaction.restrictStatus,\n      inertia: interaction.inertiaStatus,\n      downTime: interaction.downTimes[0],\n      downEvent: interaction.downEvent,\n      downPointer: interaction.downPointer,\n      prevEvent: interaction.prevEvent,\n      Interactable: Interactable,\n      interactables: interactables,\n      pointerIsDown: interaction.pointerIsDown,\n      defaultOptions: defaultOptions,\n      defaultActionChecker: defaultActionChecker,\n      actionCursors: actionCursors,\n      dragMove: listeners.dragMove,\n      resizeMove: listeners.resizeMove,\n      gestureMove: listeners.gestureMove,\n      pointerUp: listeners.pointerUp,\n      pointerDown: listeners.pointerDown,\n      pointerMove: listeners.pointerMove,\n      pointerHover: listeners.pointerHover,\n      eventTypes: eventTypes,\n      events: events,\n      globalEvents: globalEvents,\n      delegatedEvents: delegatedEvents,\n      prefixedPropREs: prefixedPropREs\n    };\n  }; // expose the functions used to calculate multi-touch properties\n\n\n  interact.getPointerAverage = pointerAverage;\n  interact.getTouchBBox = touchBBox;\n  interact.getTouchDistance = touchDistance;\n  interact.getTouchAngle = touchAngle;\n  interact.getElementRect = getElementRect;\n  interact.getElementClientRect = getElementClientRect;\n  interact.matchesSelector = matchesSelector;\n  interact.closest = closest;\n  /*\\\n   * interact.margin\n   [ method ]\n   *\n   * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n   * Returns or sets the margin for autocheck resizing used in\n   * @Interactable.getAction. That is the distance from the bottom and right\n   * edges of an element clicking in which will start resizing\n   *\n   - newValue (number) #optional\n   = (number | interact) The current margin value or interact\n  \\*/\n\n  interact.margin = warnOnce(function (newvalue) {\n    if (isNumber(newvalue)) {\n      margin = newvalue;\n      return interact;\n    }\n\n    return margin;\n  }, 'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.');\n  /*\\\n   * interact.supportsTouch\n   [ method ]\n   *\n   = (boolean) Whether or not the browser supports touch input\n  \\*/\n\n  interact.supportsTouch = function () {\n    return supportsTouch;\n  };\n  /*\\\n   * interact.supportsPointerEvent\n   [ method ]\n   *\n   = (boolean) Whether or not the browser supports PointerEvents\n  \\*/\n\n\n  interact.supportsPointerEvent = function () {\n    return supportsPointerEvent;\n  };\n  /*\\\n   * interact.stop\n   [ method ]\n   *\n   * Cancels all interactions (end events are not fired)\n   *\n   - event (Event) An event on which to call preventDefault()\n   = (object) interact\n  \\*/\n\n\n  interact.stop = function (event) {\n    for (var i = interactions.length - 1; i >= 0; i--) {\n      interactions[i].stop(event);\n    }\n\n    return interact;\n  };\n  /*\\\n   * interact.dynamicDrop\n   [ method ]\n   *\n   * Returns or sets whether the dimensions of dropzone elements are\n   * calculated on every dragmove or only on dragstart for the default\n   * dropChecker\n   *\n   - newValue (boolean) #optional True to check on each move. False to check only before start\n   = (boolean | interact) The current setting or interact\n  \\*/\n\n\n  interact.dynamicDrop = function (newValue) {\n    if (isBool(newValue)) {\n      //if (dragging && dynamicDrop !== newValue && !newValue) {\n      //calcRects(dropzones);\n      //}\n      dynamicDrop = newValue;\n      return interact;\n    }\n\n    return dynamicDrop;\n  };\n  /*\\\n   * interact.pointerMoveTolerance\n   [ method ]\n   * Returns or sets the distance the pointer must be moved before an action\n   * sequence occurs. This also affects tolerance for tap events.\n   *\n   - newValue (number) #optional The movement from the start position must be greater than this value\n   = (number | Interactable) The current setting or interact\n  \\*/\n\n\n  interact.pointerMoveTolerance = function (newValue) {\n    if (isNumber(newValue)) {\n      pointerMoveTolerance = newValue;\n      return this;\n    }\n\n    return pointerMoveTolerance;\n  };\n  /*\\\n   * interact.maxInteractions\n   [ method ]\n   **\n   * Returns or sets the maximum number of concurrent interactions allowed.\n   * By default only 1 interaction is allowed at a time (for backwards\n   * compatibility). To allow multiple interactions on the same Interactables\n   * and elements, you need to enable it in the draggable, resizable and\n   * gesturable `'max'` and `'maxPerElement'` options.\n   **\n   - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n  \\*/\n\n\n  interact.maxInteractions = function (newValue) {\n    if (isNumber(newValue)) {\n      maxInteractions = newValue;\n      return this;\n    }\n\n    return maxInteractions;\n  };\n\n  interact.createSnapGrid = function (grid) {\n    return function (x, y) {\n      var offsetX = 0,\n          offsetY = 0;\n\n      if (isObject(grid.offset)) {\n        offsetX = grid.offset.x;\n        offsetY = grid.offset.y;\n      }\n\n      var gridx = Math.round((x - offsetX) / grid.x),\n          gridy = Math.round((y - offsetY) / grid.y),\n          newX = gridx * grid.x + offsetX,\n          newY = gridy * grid.y + offsetY;\n      return {\n        x: newX,\n        y: newY,\n        range: grid.range\n      };\n    };\n  };\n\n  function endAllInteractions(event) {\n    for (var i = 0; i < interactions.length; i++) {\n      interactions[i].pointerEnd(event, event);\n    }\n  }\n\n  function listenToDocument(doc) {\n    if (contains(documents, doc)) {\n      return;\n    }\n\n    var win = doc.defaultView || doc.parentWindow; // add delegate event listener\n\n    for (var eventType in delegatedEvents) {\n      events.add(doc, eventType, delegateListener);\n      events.add(doc, eventType, delegateUseCapture, true);\n    }\n\n    if (supportsPointerEvent) {\n      if (PointerEvent === win.MSPointerEvent) {\n        pEventTypes = {\n          up: 'MSPointerUp',\n          down: 'MSPointerDown',\n          over: 'mouseover',\n          out: 'mouseout',\n          move: 'MSPointerMove',\n          cancel: 'MSPointerCancel'\n        };\n      } else {\n        pEventTypes = {\n          up: 'pointerup',\n          down: 'pointerdown',\n          over: 'pointerover',\n          out: 'pointerout',\n          move: 'pointermove',\n          cancel: 'pointercancel'\n        };\n      }\n\n      events.add(doc, pEventTypes.down, listeners.selectorDown);\n      events.add(doc, pEventTypes.move, listeners.pointerMove);\n      events.add(doc, pEventTypes.over, listeners.pointerOver);\n      events.add(doc, pEventTypes.out, listeners.pointerOut);\n      events.add(doc, pEventTypes.up, listeners.pointerUp);\n      events.add(doc, pEventTypes.cancel, listeners.pointerCancel); // autoscroll\n\n      events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n    } else {\n      events.add(doc, 'mousedown', listeners.selectorDown);\n      events.add(doc, 'mousemove', listeners.pointerMove);\n      events.add(doc, 'mouseup', listeners.pointerUp);\n      events.add(doc, 'mouseover', listeners.pointerOver);\n      events.add(doc, 'mouseout', listeners.pointerOut);\n      events.add(doc, 'touchstart', listeners.selectorDown);\n      events.add(doc, 'touchmove', listeners.pointerMove);\n      events.add(doc, 'touchend', listeners.pointerUp);\n      events.add(doc, 'touchcancel', listeners.pointerCancel); // autoscroll\n\n      events.add(doc, 'mousemove', listeners.autoScrollMove);\n      events.add(doc, 'touchmove', listeners.autoScrollMove);\n    }\n\n    events.add(win, 'blur', endAllInteractions);\n\n    try {\n      if (win.frameElement) {\n        var parentDoc = win.frameElement.ownerDocument,\n            parentWindow = parentDoc.defaultView;\n        events.add(parentDoc, 'mouseup', listeners.pointerEnd);\n        events.add(parentDoc, 'touchend', listeners.pointerEnd);\n        events.add(parentDoc, 'touchcancel', listeners.pointerEnd);\n        events.add(parentDoc, 'pointerup', listeners.pointerEnd);\n        events.add(parentDoc, 'MSPointerUp', listeners.pointerEnd);\n        events.add(parentWindow, 'blur', endAllInteractions);\n      }\n    } catch (error) {\n      interact.windowParentError = error;\n    } // prevent native HTML5 drag on interact.js target elements\n\n\n    events.add(doc, 'dragstart', function (event) {\n      for (var i = 0; i < interactions.length; i++) {\n        var interaction = interactions[i];\n\n        if (interaction.element && (interaction.element === event.target || nodeContains(interaction.element, event.target))) {\n          interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n          return;\n        }\n      }\n    });\n\n    if (events.useAttachEvent) {\n      // For IE's lack of Event#preventDefault\n      events.add(doc, 'selectstart', function (event) {\n        var interaction = interactions[0];\n\n        if (interaction.currentAction()) {\n          interaction.checkAndPreventDefault(event);\n        }\n      }); // For IE's bad dblclick event sequence\n\n      events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n    }\n\n    documents.push(doc);\n  }\n\n  listenToDocument(document);\n\n  function indexOf(array, target) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === target) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function contains(array, target) {\n    return indexOf(array, target) !== -1;\n  }\n\n  function matchesSelector(element, selector, nodeList) {\n    if (ie8MatchesSelector) {\n      return ie8MatchesSelector(element, selector, nodeList);\n    } // remove /deep/ from selectors if shadowDOM polyfill is used\n\n\n    if (window !== realWindow) {\n      selector = selector.replace(/\\/deep\\//g, ' ');\n    }\n\n    return element[prefixedMatchesSelector](selector);\n  }\n\n  function matchesUpTo(element, selector, limit) {\n    while (isElement(element)) {\n      if (matchesSelector(element, selector)) {\n        return true;\n      }\n\n      element = parentElement(element);\n\n      if (element === limit) {\n        return matchesSelector(element, selector);\n      }\n    }\n\n    return false;\n  } // For IE8's lack of an Element#matchesSelector\n  // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n\n\n  if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n    ie8MatchesSelector = function (element, selector, elems) {\n      elems = elems || element.parentNode.querySelectorAll(selector);\n\n      for (var i = 0, len = elems.length; i < len; i++) {\n        if (elems[i] === element) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n  } // requestAnimationFrame polyfill\n\n\n  (function () {\n    var lastTime = 0,\n        vendors = ['ms', 'moz', 'webkit', 'o'];\n\n    for (var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n      reqFrame = realWindow[vendors[x] + 'RequestAnimationFrame'];\n      cancelFrame = realWindow[vendors[x] + 'CancelAnimationFrame'] || realWindow[vendors[x] + 'CancelRequestAnimationFrame'];\n    }\n\n    if (!reqFrame) {\n      reqFrame = function (callback) {\n        var currTime = new Date().getTime(),\n            timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n            id = setTimeout(function () {\n          callback(currTime + timeToCall);\n        }, timeToCall);\n        lastTime = currTime + timeToCall;\n        return id;\n      };\n    }\n\n    if (!cancelFrame) {\n      cancelFrame = function (id) {\n        clearTimeout(id);\n      };\n    }\n  })();\n  /* global exports: true, module, define */\n  // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n\n\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = interact;\n    }\n\n    exports.interact = interact;\n  } // AMD\n  else if (typeof define === 'function' && define.amd) {\n      define('interact', function () {\n        return interact;\n      });\n    } else {\n      realWindow.interact = interact;\n    }\n})(typeof window === 'undefined' ? undefined : window);","map":{"version":3,"sources":["C:/audi_/ESPL_projects/facebook/node_modules/interact.js/interact.js"],"names":["realWindow","window","el","document","createTextNode","ownerDocument","wrap","DocumentFragment","blank","SVGElement","SVGSVGElement","SVGElementInstance","HTMLElement","Element","PointerEvent","MSPointerEvent","pEventTypes","hypot","Math","x","y","sqrt","tmpXY","documents","interactables","interactions","dynamicDrop","delegatedEvents","defaultOptions","base","accept","actionChecker","styleCursor","preventDefault","origin","deltaSource","allowFrom","ignoreFrom","_context","dropChecker","drag","enabled","manualStart","max","Infinity","maxPerElement","snap","restrict","inertia","autoScroll","axis","drop","overlap","resize","square","preserveAspectRatio","margin","NaN","edges","invert","gesture","perAction","endOnly","range","targets","offsets","relativePoints","container","speed","resistance","minSpeed","endSpeed","allowResume","zeroResumeDelta","smoothEndDuration","_holdDuration","interaction","i","scroll","options","target","prepared","name","getWindow","element","now","Date","getTime","dtx","prevTimeX","dty","prevTimeY","vx","vy","sx","sy","velocity","isWindow","scrollBy","scrollLeft","scrollTop","isScrolling","cancelFrame","reqFrame","start","stop","supportsTouch","DocumentTouch","supportsPointerEvent","test","navigator","userAgent","pointerMoveTolerance","prevTouchTime","maxInteractions","actionCursors","all","atob","resizex","resizey","resizexy","resizetop","resizeleft","resizebottom","resizeright","resizetopleft","resizebottomright","resizetopright","resizebottomleft","actionIsEnabled","wheelEvent","eventTypes","globalEvents","isOperaMobile","appName","match","isIOS7","platform","appVersion","prefixedMatchesSelector","prototype","ie8MatchesSelector","requestAnimationFrame","cancelAnimationFrame","events","useAttachEvent","addEvent","removeEvent","on","elements","attachedListeners","add","type","listener","useCapture","elementIndex","indexOf","typeCount","push","supplied","wrapped","useCount","contains","ret","listeners","listenerIndex","event","immediatePropagationStopped","srcElement","currentTarget","preventDef","stopPropagation","stopProp","stopImmediatePropagation","stopImmProp","pageX","clientX","documentElement","pageY","clientY","Boolean","remove","hasOwnProperty","len","length","splice","returnValue","cancelBubble","_elements","_targets","_attachedListeners","isElement","o","_window","nodeType","nodeName","thing","Window","isDocFrag","isArray","isObject","undefined","isFunction","isNumber","isBool","isString","trySelector","value","querySelector","extend","dest","source","prop","prefixedPropREs","webkit","pointerExtend","deprecated","vendor","copyCoords","src","page","client","timeStamp","setEventXY","targetObj","pointers","pointer","pointerAverage","getPageXY","getClientXY","setEventDeltas","prev","cur","dt","isNativePointer","Event","Touch","getXY","xy","scrollX","scrollY","getScrollXY","win","getPointerId","pointerId","identifier","getActualElement","correspondingUseElement","node","rootNode","defaultView","parentWindow","getElementClientRect","clientRect","getBoundingClientRect","getClientRects","left","right","top","bottom","width","height","getElementRect","getTouchPair","touches","changedTouches","average","screenX","screenY","touchBBox","minX","min","minY","maxX","maxY","touchDistance","sourceX","sourceY","dx","dy","touchAngle","prevAngle","angle","atan","PI","dr","drClamped","getOriginXY","interactable","parentElement","getRect","closest","_getQBezierValue","t","p1","p2","p3","iT","getQuadraticCurvePoint","startX","startY","cpX","cpY","endX","endY","position","easeOutQuad","b","c","d","nodeContains","parent","child","parentNode","selector","matchesSelector","host","inContext","testIgnore","interactableElement","matchesUpTo","testAllow","checkAxis","thisAxis","checkSnap","action","checkRestrict","checkAutoScroll","withinInteractionLimit","maxActions","activeInteractions","targetCount","targetElementCount","otherAction","active","interacting","indexOfDeepestElement","dropzone","deepestZone","index","deepestZoneParents","dropzoneParents","n","unshift","ownerSVGElement","parents","lastChild","previousSibling","Interaction","dropTarget","dropElement","prevDropTarget","prevDropElement","matches","matchElements","inertiaStatus","smoothEnd","ending","startEvent","upCoords","xe","ye","t0","vx0","vys","duration","resumeDx","resumeDy","lambda_v0","one_ve_v0","Function","bind","boundInertiaFrame","inertiaFrame","boundSmoothEndFrame","smoothEndFrame","that","activeDrops","dropzones","rects","pointerIds","downTargets","downTimes","holdTimers","prevCoords","curCoords","startCoords","pointerDelta","downEvent","downPointer","_eventTarget","_curEventTarget","prevEvent","tapTime","prevTap","startOffset","restrictOffset","snapOffsets","startDistance","prevDistance","distance","scale","startAngle","snapStatus","realX","realY","snappedX","snappedY","locked","changed","restrictStatus","restrictedX","restrictedY","restricted","pointerIsDown","pointerWasMoved","gesturing","dragging","resizing","resizeAxes","mouse","ptr","pointerOver","eventTarget","curMatches","curMatchElements","prevTargetElement","addPointer","elementInteractable","get","elementAction","validateAction","getAction","pushCurMatches","forEachSelector","validateSelector","pointerHover","move","curEventTarget","_doc","style","cursor","getActionCursor","checkAndPreventDefault","pointerOut","selectorDown","eventCopy","pointerIndex","setTimeout","pointerHold","collectEventTargets","pushMatches","context","querySelectorAll","pointerDown","forceAction","_element","newAction","setModifications","coords","preEnd","shouldMove","shouldSnap","shouldRestrict","setSnapping","setRestriction","setStartOffsets","rect","snapOffset","offset","elementRect","pointerMove","pageUp","clientUp","inertiaPosition","recordPointer","duplicateMove","clearTimeout","InteractEvent","absX","abs","absY","targetAxis","thisInteraction","getDraggable","selectorInteractable","starting","autoScrollMove","dragStart","dragEvent","fire","setActiveDrops","dropEvents","getDropEvents","activate","fireActiveDrops","dragMove","draggableElement","getDrop","leave","enter","resizeStart","resizeEvent","startRect","linkedEdges","_linkedEdges","resizeStartAspectRatio","resizeRects","current","previous","delta","deltaRect","resizeMove","invertible","originalEdges","swap","edge","gestureStart","gestureEvent","ds","gestureMove","isNaN","pointerUp","pointerEnd","removePointer","pointerCancel","ie8Dblclick","endEvent","inertiaOptions","pointerSpeed","inertiaPossible","endSnap","endRestrict","snapRestrict","vy0","v0","calcInertia","statusObject","useStatusXY","modifiedXe","modifiedYe","deactivate","collectDrops","drops","dropElements","j","currentElement","prevElement","dragElement","possibleDrops","validDrops","dropCheck","dropIndex","pointerEvent","relatedTarget","draggable","dragLeave","prevDropzone","dragEnter","dragmove","currentAction","clearTargets","lambda","te","progress","exp","quadPoint","id","eventType","collectSelectors","els","_iEvents","interact","isSet","firePointers","interval","createNewDoubleTap","preventOriginalDefault","originalEvent","originalPointer","pointerType","double","propagationStopped","doubleTap","matchElement","pageCoords","status","relIndex","relative","inRange","snapChanged","restriction","prevent","inertiaDur","log","x0","y0","innerWidth","innerHeight","_updateEventTargets","getInteractionFromPointer","mouseEvent","doOnInteractions","method","path","phase","related","clientX0","clientY0","ctrlKey","altKey","shiftKey","metaKey","button","buttons","detail","axes","box","da","prevScale","velocityX","velocityY","atan2","up","down","swipe","cursorKey","edgeNames","checkResizeEdge","defaultActionChecker","shouldResize","resizeEdges","resizeOptions","actionName","interactionListeners","delegateListener","fakeEvent","delegated","selectors","contexts","delegateUseCapture","call","indexOfElement","interactableGet","callback","Interactable","Node","listenToDocument","set","setOnEvents","phases","ondrop","ondropactivate","ondropdeactivate","ondragenter","ondragleave","ondropmove","onstart","onmove","onend","oninertiastart","setPerAction","option","checker","dropped","dropOverlap","horizontal","vertical","dragRect","cx","cy","overlapArea","overlapRatio","newValue","resizable","squareResize","gesturable","actions","setOptions","thisOption","mode","createSnapGrid","gridOffset","grid","anchors","paths","elementOrigin","allActions","rectCheck","rectChecker","iEvent","onEvent","funcName","search","trim","split","off","eventList","matchFound","fn","useCap","methods","perActions","settings","setting","unset","warnOnce","message","warned","console","warn","apply","arguments","enableDragging","enableResizing","enableGesturing","debug","downTime","getPointerAverage","getTouchBBox","getTouchDistance","getTouchAngle","newvalue","offsetX","offsetY","gridx","round","gridy","newX","newY","endAllInteractions","doc","over","out","cancel","frameElement","parentDoc","error","windowParentError","array","nodeList","replace","limit","elems","lastTime","vendors","currTime","timeToCall","exports","module","define","amd"],"mappings":"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","sourcesContent":["/**\n * interact.js v1.2.8\n *\n * Copyright (c) 2012-2015 Taye Adeyemi <dev@taye.me>\n * Open source under the MIT License.\n * https://raw.github.com/taye/interact.js/master/LICENSE\n */\n(function (realWindow) {\n    'use strict';\n\n    // return early if there's no window to work with (eg. Node.js)\n    if (!realWindow) { return; }\n\n    var // get wrapped window if using Shadow DOM polyfill\n        window = (function () {\n            // create a TextNode\n            var el = realWindow.document.createTextNode('');\n\n            // check if it's wrapped by a polyfill\n            if (el.ownerDocument !== realWindow.document\n                && typeof realWindow.wrap === 'function'\n                && realWindow.wrap(el) === el) {\n                // return wrapped window\n                return realWindow.wrap(realWindow);\n            }\n\n            // no Shadow DOM polyfil or native implementation\n            return realWindow;\n        }()),\n\n        document           = window.document,\n        DocumentFragment   = window.DocumentFragment   || blank,\n        SVGElement         = window.SVGElement         || blank,\n        SVGSVGElement      = window.SVGSVGElement      || blank,\n        SVGElementInstance = window.SVGElementInstance || blank,\n        HTMLElement        = window.HTMLElement        || window.Element,\n\n        PointerEvent = (window.PointerEvent || window.MSPointerEvent),\n        pEventTypes,\n\n        hypot = Math.hypot || function (x, y) { return Math.sqrt(x * x + y * y); },\n\n        tmpXY = {},     // reduce object creation in getXY()\n\n        documents       = [],   // all documents being listened to\n\n        interactables   = [],   // all set interactables\n        interactions    = [],   // all interactions\n\n        dynamicDrop     = false,\n\n        // {\n        //      type: {\n        //          selectors: ['selector', ...],\n        //          contexts : [document, ...],\n        //          listeners: [[listener, useCapture], ...]\n        //      }\n        //  }\n        delegatedEvents = {},\n\n        defaultOptions = {\n            base: {\n                accept        : null,\n                actionChecker : null,\n                styleCursor   : true,\n                preventDefault: 'auto',\n                origin        : { x: 0, y: 0 },\n                deltaSource   : 'page',\n                allowFrom     : null,\n                ignoreFrom    : null,\n                _context      : document,\n                dropChecker   : null\n            },\n\n            drag: {\n                enabled: false,\n                manualStart: true,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: null,\n                restrict: null,\n                inertia: null,\n                autoScroll: null,\n\n                axis: 'xy'\n            },\n\n            drop: {\n                enabled: false,\n                accept: null,\n                overlap: 'pointer'\n            },\n\n            resize: {\n                enabled: false,\n                manualStart: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: null,\n                restrict: null,\n                inertia: null,\n                autoScroll: null,\n\n                square: false,\n                preserveAspectRatio: false,\n                axis: 'xy',\n\n                // use default margin\n                margin: NaN,\n\n                // object with props left, right, top, bottom which are\n                // true/false values to resize when the pointer is over that edge,\n                // CSS selectors to match the handles for each direction\n                // or the Elements for each handle\n                edges: null,\n\n                // a value of 'none' will limit the resize rect to a minimum of 0x0\n                // 'negate' will alow the rect to have negative width/height\n                // 'reposition' will keep the width/height positive by swapping\n                // the top and bottom edges and/or swapping the left and right edges\n                invert: 'none'\n            },\n\n            gesture: {\n                manualStart: false,\n                enabled: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                restrict: null\n            },\n\n            perAction: {\n                manualStart: false,\n                max: Infinity,\n                maxPerElement: 1,\n\n                snap: {\n                    enabled     : false,\n                    endOnly     : false,\n                    range       : Infinity,\n                    targets     : null,\n                    offsets     : null,\n\n                    relativePoints: null\n                },\n\n                restrict: {\n                    enabled: false,\n                    endOnly: false\n                },\n\n                autoScroll: {\n                    enabled     : false,\n                    container   : null,     // the item that is scrolled (Window or HTMLElement)\n                    margin      : 60,\n                    speed       : 300       // the scroll speed in pixels per second\n                },\n\n                inertia: {\n                    enabled          : false,\n                    resistance       : 10,    // the lambda in exponential decay\n                    minSpeed         : 100,   // target speed must be above this for inertia to start\n                    endSpeed         : 10,    // the speed at which inertia is slow enough to stop\n                    allowResume      : true,  // allow resuming an action in inertia phase\n                    zeroResumeDelta  : true,  // if an action is resumed after launch, set dx/dy to 0\n                    smoothEndDuration: 300    // animate to snap/restrict endOnly if there's no inertia\n                }\n            },\n\n            _holdDuration: 600\n        },\n\n        // Things related to autoScroll\n        autoScroll = {\n            interaction: null,\n            i: null,    // the handle returned by window.setInterval\n            x: 0, y: 0, // Direction each pulse is to scroll in\n\n            // scroll the window by the values in scroll.x/y\n            scroll: function () {\n                var options = autoScroll.interaction.target.options[autoScroll.interaction.prepared.name].autoScroll,\n                    container = options.container || getWindow(autoScroll.interaction.element),\n                    now = new Date().getTime(),\n                    // change in time in seconds\n                    dtx = (now - autoScroll.prevTimeX) / 1000,\n                    dty = (now - autoScroll.prevTimeY) / 1000,\n                    vx, vy, sx, sy;\n\n                // displacement\n                if (options.velocity) {\n                  vx = options.velocity.x;\n                  vy = options.velocity.y;\n                }\n                else {\n                  vx = vy = options.speed\n                }\n \n                sx = vx * dtx;\n                sy = vy * dty;\n\n                if (sx >= 1 || sy >= 1) {\n                    if (isWindow(container)) {\n                        container.scrollBy(autoScroll.x * sx, autoScroll.y * sy);\n                    }\n                    else if (container) {\n                        container.scrollLeft += autoScroll.x * sx;\n                        container.scrollTop  += autoScroll.y * sy;\n                    }\n\n                    if (sx >=1) autoScroll.prevTimeX = now;\n                    if (sy >= 1) autoScroll.prevTimeY = now;\n                }\n\n                if (autoScroll.isScrolling) {\n                    cancelFrame(autoScroll.i);\n                    autoScroll.i = reqFrame(autoScroll.scroll);\n                }\n            },\n\n            isScrolling: false,\n            prevTimeX: 0,\n            prevTimeY: 0,\n\n            start: function (interaction) {\n                autoScroll.isScrolling = true;\n                cancelFrame(autoScroll.i);\n\n                autoScroll.interaction = interaction;\n                autoScroll.prevTimeX = new Date().getTime();\n                autoScroll.prevTimeY = new Date().getTime();\n                autoScroll.i = reqFrame(autoScroll.scroll);\n            },\n\n            stop: function () {\n                autoScroll.isScrolling = false;\n                cancelFrame(autoScroll.i);\n            }\n        },\n\n        // Does the browser support touch input?\n        supportsTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof window.DocumentTouch),\n\n        // Does the browser support PointerEvents\n        // Avoid PointerEvent bugs introduced in Chrome 55\n        supportsPointerEvent = PointerEvent && !/Chrome/.test(navigator.userAgent),\n\n        // Less Precision with touch input\n        margin = supportsTouch || supportsPointerEvent? 20: 10,\n\n        pointerMoveTolerance = 1,\n\n        // for ignoring browser's simulated mouse events\n        prevTouchTime = 0,\n\n        // Allow this many interactions to happen simultaneously\n        maxInteractions = Infinity,\n\n        // Check if is IE9 or older\n        actionCursors = (document.all && !window.atob) ? {\n            drag    : 'move',\n            resizex : 'e-resize',\n            resizey : 's-resize',\n            resizexy: 'se-resize',\n\n            resizetop        : 'n-resize',\n            resizeleft       : 'w-resize',\n            resizebottom     : 's-resize',\n            resizeright      : 'e-resize',\n            resizetopleft    : 'se-resize',\n            resizebottomright: 'se-resize',\n            resizetopright   : 'ne-resize',\n            resizebottomleft : 'ne-resize',\n\n            gesture : ''\n        } : {\n            drag    : 'move',\n            resizex : 'ew-resize',\n            resizey : 'ns-resize',\n            resizexy: 'nwse-resize',\n\n            resizetop        : 'ns-resize',\n            resizeleft       : 'ew-resize',\n            resizebottom     : 'ns-resize',\n            resizeright      : 'ew-resize',\n            resizetopleft    : 'nwse-resize',\n            resizebottomright: 'nwse-resize',\n            resizetopright   : 'nesw-resize',\n            resizebottomleft : 'nesw-resize',\n\n            gesture : ''\n        },\n\n        actionIsEnabled = {\n            drag   : true,\n            resize : true,\n            gesture: true\n        },\n\n        // because Webkit and Opera still use 'mousewheel' event type\n        wheelEvent = 'onmousewheel' in document? 'mousewheel': 'wheel',\n\n        eventTypes = [\n            'dragstart',\n            'dragmove',\n            'draginertiastart',\n            'dragend',\n            'dragenter',\n            'dragleave',\n            'dropactivate',\n            'dropdeactivate',\n            'dropmove',\n            'drop',\n            'resizestart',\n            'resizemove',\n            'resizeinertiastart',\n            'resizeend',\n            'gesturestart',\n            'gesturemove',\n            'gestureinertiastart',\n            'gestureend',\n\n            'down',\n            'move',\n            'up',\n            'cancel',\n            'tap',\n            'doubletap',\n            'hold'\n        ],\n\n        globalEvents = {},\n\n        // Opera Mobile must be handled differently\n        isOperaMobile = navigator.appName == 'Opera' &&\n            supportsTouch &&\n            navigator.userAgent.match('Presto'),\n\n        // scrolling doesn't change the result of getClientRects on iOS 7\n        isIOS7 = (/iP(hone|od|ad)/.test(navigator.platform)\n                         && /OS 7[^\\d]/.test(navigator.appVersion)),\n\n        // prefix matchesSelector\n        prefixedMatchesSelector = 'matches' in Element.prototype?\n                'matches': 'webkitMatchesSelector' in Element.prototype?\n                    'webkitMatchesSelector': 'mozMatchesSelector' in Element.prototype?\n                        'mozMatchesSelector': 'oMatchesSelector' in Element.prototype?\n                            'oMatchesSelector': 'msMatchesSelector',\n\n        // will be polyfill function if browser is IE8\n        ie8MatchesSelector,\n\n        // native requestAnimationFrame or polyfill\n        reqFrame = realWindow.requestAnimationFrame,\n        cancelFrame = realWindow.cancelAnimationFrame,\n\n        // Events wrapper\n        events = (function () {\n            var useAttachEvent = ('attachEvent' in window) && !('addEventListener' in window),\n                addEvent       = useAttachEvent?  'attachEvent': 'addEventListener',\n                removeEvent    = useAttachEvent?  'detachEvent': 'removeEventListener',\n                on             = useAttachEvent? 'on': '',\n\n                elements          = [],\n                targets           = [],\n                attachedListeners = [];\n\n            function add (element, type, listener, useCapture) {\n                var elementIndex = indexOf(elements, element),\n                    target = targets[elementIndex];\n\n                if (!target) {\n                    target = {\n                        events: {},\n                        typeCount: 0\n                    };\n\n                    elementIndex = elements.push(element) - 1;\n                    targets.push(target);\n\n                    attachedListeners.push((useAttachEvent ? {\n                            supplied: [],\n                            wrapped : [],\n                            useCount: []\n                        } : null));\n                }\n\n                if (!target.events[type]) {\n                    target.events[type] = [];\n                    target.typeCount++;\n                }\n\n                if (!contains(target.events[type], listener)) {\n                    var ret;\n\n                    if (useAttachEvent) {\n                        var listeners = attachedListeners[elementIndex],\n                            listenerIndex = indexOf(listeners.supplied, listener);\n\n                        var wrapped = listeners.wrapped[listenerIndex] || function (event) {\n                            if (!event.immediatePropagationStopped) {\n                                event.target = event.srcElement;\n                                event.currentTarget = element;\n\n                                event.preventDefault = event.preventDefault || preventDef;\n                                event.stopPropagation = event.stopPropagation || stopProp;\n                                event.stopImmediatePropagation = event.stopImmediatePropagation || stopImmProp;\n\n                                if (/mouse|click/.test(event.type)) {\n                                    event.pageX = event.clientX + getWindow(element).document.documentElement.scrollLeft;\n                                    event.pageY = event.clientY + getWindow(element).document.documentElement.scrollTop;\n                                }\n\n                                listener(event);\n                            }\n                        };\n\n                        ret = element[addEvent](on + type, wrapped, Boolean(useCapture));\n\n                        if (listenerIndex === -1) {\n                            listeners.supplied.push(listener);\n                            listeners.wrapped.push(wrapped);\n                            listeners.useCount.push(1);\n                        }\n                        else {\n                            listeners.useCount[listenerIndex]++;\n                        }\n                    }\n                    else {\n                        ret = element[addEvent](type, listener, useCapture || false);\n                    }\n                    target.events[type].push(listener);\n\n                    return ret;\n                }\n            }\n\n            function remove (element, type, listener, useCapture) {\n                var i,\n                    elementIndex = indexOf(elements, element),\n                    target = targets[elementIndex],\n                    listeners,\n                    listenerIndex,\n                    wrapped = listener;\n\n                if (!target || !target.events) {\n                    return;\n                }\n\n                if (useAttachEvent) {\n                    listeners = attachedListeners[elementIndex];\n                    listenerIndex = indexOf(listeners.supplied, listener);\n                    wrapped = listeners.wrapped[listenerIndex];\n                }\n\n                if (type === 'all') {\n                    for (type in target.events) {\n                        if (target.events.hasOwnProperty(type)) {\n                            remove(element, type, 'all');\n                        }\n                    }\n                    return;\n                }\n\n                if (target.events[type]) {\n                    var len = target.events[type].length;\n\n                    if (listener === 'all') {\n                        for (i = 0; i < len; i++) {\n                            remove(element, type, target.events[type][i], Boolean(useCapture));\n                        }\n                        return;\n                    } else {\n                        for (i = 0; i < len; i++) {\n                            if (target.events[type][i] === listener) {\n                                element[removeEvent](on + type, wrapped, useCapture || false);\n                                target.events[type].splice(i, 1);\n\n                                if (useAttachEvent && listeners) {\n                                    listeners.useCount[listenerIndex]--;\n                                    if (listeners.useCount[listenerIndex] === 0) {\n                                        listeners.supplied.splice(listenerIndex, 1);\n                                        listeners.wrapped.splice(listenerIndex, 1);\n                                        listeners.useCount.splice(listenerIndex, 1);\n                                    }\n                                }\n\n                                break;\n                            }\n                        }\n                    }\n\n                    if (target.events[type] && target.events[type].length === 0) {\n                        target.events[type] = null;\n                        target.typeCount--;\n                    }\n                }\n\n                if (!target.typeCount) {\n                    targets.splice(elementIndex, 1);\n                    elements.splice(elementIndex, 1);\n                    attachedListeners.splice(elementIndex, 1);\n                }\n            }\n\n            function preventDef () {\n                this.returnValue = false;\n            }\n\n            function stopProp () {\n                this.cancelBubble = true;\n            }\n\n            function stopImmProp () {\n                this.cancelBubble = true;\n                this.immediatePropagationStopped = true;\n            }\n\n            return {\n                add: add,\n                remove: remove,\n                useAttachEvent: useAttachEvent,\n\n                _elements: elements,\n                _targets: targets,\n                _attachedListeners: attachedListeners\n            };\n        }());\n\n    function blank () {}\n\n    function isElement (o) {\n        if (!o || (typeof o !== 'object')) { return false; }\n\n        var _window = getWindow(o) || window;\n\n        return (/object|function/.test(typeof _window.Element)\n            ? o instanceof _window.Element //DOM2\n            : o.nodeType === 1 && typeof o.nodeName === \"string\");\n    }\n    function isWindow (thing) { return thing === window || !!(thing && thing.Window) && (thing instanceof thing.Window); }\n    function isDocFrag (thing) { return !!thing && thing instanceof DocumentFragment; }\n    function isArray (thing) {\n        return isObject(thing)\n                && (typeof thing.length !== undefined)\n                && isFunction(thing.splice);\n    }\n    function isObject   (thing) { return !!thing && (typeof thing === 'object'); }\n    function isFunction (thing) { return typeof thing === 'function'; }\n    function isNumber   (thing) { return typeof thing === 'number'  ; }\n    function isBool     (thing) { return typeof thing === 'boolean' ; }\n    function isString   (thing) { return typeof thing === 'string'  ; }\n\n    function trySelector (value) {\n        if (!isString(value)) { return false; }\n\n        // an exception will be raised if it is invalid\n        document.querySelector(value);\n        return true;\n    }\n\n    function extend (dest, source) {\n        for (var prop in source) {\n            dest[prop] = source[prop];\n        }\n        return dest;\n    }\n\n    var prefixedPropREs = {\n      webkit: /(Movement[XY]|Radius[XY]|RotationAngle|Force)$/\n    };\n\n    function pointerExtend (dest, source) {\n        for (var prop in source) {\n          var deprecated = false;\n\n          // skip deprecated prefixed properties\n          for (var vendor in prefixedPropREs) {\n            if (prop.indexOf(vendor) === 0 && prefixedPropREs[vendor].test(prop)) {\n              deprecated = true;\n              break;\n            }\n          }\n\n          if (!deprecated) {\n            dest[prop] = source[prop];\n          }\n        }\n        return dest;\n    }\n\n    function copyCoords (dest, src) {\n        dest.page = dest.page || {};\n        dest.page.x = src.page.x;\n        dest.page.y = src.page.y;\n\n        dest.client = dest.client || {};\n        dest.client.x = src.client.x;\n        dest.client.y = src.client.y;\n\n        dest.timeStamp = src.timeStamp;\n    }\n\n    function setEventXY (targetObj, pointers, interaction) {\n        var pointer = (pointers.length > 1\n                       ? pointerAverage(pointers)\n                       : pointers[0]);\n\n        getPageXY(pointer, tmpXY, interaction);\n        targetObj.page.x = tmpXY.x;\n        targetObj.page.y = tmpXY.y;\n\n        getClientXY(pointer, tmpXY, interaction);\n        targetObj.client.x = tmpXY.x;\n        targetObj.client.y = tmpXY.y;\n\n        targetObj.timeStamp = new Date().getTime();\n    }\n\n    function setEventDeltas (targetObj, prev, cur) {\n        targetObj.page.x     = cur.page.x      - prev.page.x;\n        targetObj.page.y     = cur.page.y      - prev.page.y;\n        targetObj.client.x   = cur.client.x    - prev.client.x;\n        targetObj.client.y   = cur.client.y    - prev.client.y;\n        targetObj.timeStamp = new Date().getTime() - prev.timeStamp;\n\n        // set pointer velocity\n        var dt = Math.max(targetObj.timeStamp / 1000, 0.001);\n        targetObj.page.speed   = hypot(targetObj.page.x, targetObj.page.y) / dt;\n        targetObj.page.vx      = targetObj.page.x / dt;\n        targetObj.page.vy      = targetObj.page.y / dt;\n\n        targetObj.client.speed = hypot(targetObj.client.x, targetObj.page.y) / dt;\n        targetObj.client.vx    = targetObj.client.x / dt;\n        targetObj.client.vy    = targetObj.client.y / dt;\n    }\n\n    function isNativePointer (pointer) {\n        return (pointer instanceof window.Event\n            || (supportsTouch && window.Touch && pointer instanceof window.Touch));\n    }\n\n    // Get specified X/Y coords for mouse or event.touches[0]\n    function getXY (type, pointer, xy) {\n        xy = xy || {};\n        type = type || 'page';\n\n        xy.x = pointer[type + 'X'];\n        xy.y = pointer[type + 'Y'];\n\n        return xy;\n    }\n\n    function getPageXY (pointer, page) {\n        page = page || {};\n\n        // Opera Mobile handles the viewport and scrolling oddly\n        if (isOperaMobile && isNativePointer(pointer)) {\n            getXY('screen', pointer, page);\n\n            page.x += window.scrollX;\n            page.y += window.scrollY;\n        }\n        else {\n            getXY('page', pointer, page);\n        }\n\n        return page;\n    }\n\n    function getClientXY (pointer, client) {\n        client = client || {};\n\n        if (isOperaMobile && isNativePointer(pointer)) {\n            // Opera Mobile handles the viewport and scrolling oddly\n            getXY('screen', pointer, client);\n        }\n        else {\n          getXY('client', pointer, client);\n        }\n\n        return client;\n    }\n\n    function getScrollXY (win) {\n        win = win || window;\n        return {\n            x: win.scrollX || win.document.documentElement.scrollLeft,\n            y: win.scrollY || win.document.documentElement.scrollTop\n        };\n    }\n\n    function getPointerId (pointer) {\n        return isNumber(pointer.pointerId)? pointer.pointerId : pointer.identifier;\n    }\n\n    function getActualElement (element) {\n        return (element instanceof SVGElementInstance\n            ? element.correspondingUseElement\n            : element);\n    }\n\n    function getWindow (node) {\n        if (isWindow(node)) {\n            return node;\n        }\n\n        var rootNode = (node.ownerDocument || node);\n\n        return rootNode.defaultView || rootNode.parentWindow || window;\n    }\n\n    function getElementClientRect (element) {\n        var clientRect = (element instanceof SVGElement\n                            ? element.getBoundingClientRect()\n                            : element.getClientRects()[0]);\n\n        return clientRect && {\n            left  : clientRect.left,\n            right : clientRect.right,\n            top   : clientRect.top,\n            bottom: clientRect.bottom,\n            width : clientRect.width || clientRect.right - clientRect.left,\n            height: clientRect.height || clientRect.bottom - clientRect.top\n        };\n    }\n\n    function getElementRect (element) {\n        var clientRect = getElementClientRect(element);\n\n        if (!isIOS7 && clientRect) {\n            var scroll = getScrollXY(getWindow(element));\n\n            clientRect.left   += scroll.x;\n            clientRect.right  += scroll.x;\n            clientRect.top    += scroll.y;\n            clientRect.bottom += scroll.y;\n        }\n\n        return clientRect;\n    }\n\n    function getTouchPair (event) {\n        var touches = [];\n\n        // array of touches is supplied\n        if (isArray(event)) {\n            touches[0] = event[0];\n            touches[1] = event[1];\n        }\n        // an event\n        else {\n            if (event.type === 'touchend') {\n                if (event.touches.length === 1) {\n                    touches[0] = event.touches[0];\n                    touches[1] = event.changedTouches[0];\n                }\n                else if (event.touches.length === 0) {\n                    touches[0] = event.changedTouches[0];\n                    touches[1] = event.changedTouches[1];\n                }\n            }\n            else {\n                touches[0] = event.touches[0];\n                touches[1] = event.touches[1];\n            }\n        }\n\n        return touches;\n    }\n\n    function pointerAverage (pointers) {\n        var average = {\n            pageX  : 0,\n            pageY  : 0,\n            clientX: 0,\n            clientY: 0,\n            screenX: 0,\n            screenY: 0\n        };\n        var prop;\n\n        for (var i = 0; i < pointers.length; i++) {\n            for (prop in average) {\n                average[prop] += pointers[i][prop];\n            }\n        }\n        for (prop in average) {\n            average[prop] /= pointers.length;\n        }\n\n        return average;\n    }\n\n    function touchBBox (event) {\n        if (!event.length && !(event.touches && event.touches.length > 1)) {\n            return;\n        }\n\n        var touches = getTouchPair(event),\n            minX = Math.min(touches[0].pageX, touches[1].pageX),\n            minY = Math.min(touches[0].pageY, touches[1].pageY),\n            maxX = Math.max(touches[0].pageX, touches[1].pageX),\n            maxY = Math.max(touches[0].pageY, touches[1].pageY);\n\n        return {\n            x: minX,\n            y: minY,\n            left: minX,\n            top: minY,\n            width: maxX - minX,\n            height: maxY - minY\n        };\n    }\n\n    function touchDistance (event, deltaSource) {\n        deltaSource = deltaSource || defaultOptions.deltaSource;\n\n        var sourceX = deltaSource + 'X',\n            sourceY = deltaSource + 'Y',\n            touches = getTouchPair(event);\n\n\n        var dx = touches[0][sourceX] - touches[1][sourceX],\n            dy = touches[0][sourceY] - touches[1][sourceY];\n\n        return hypot(dx, dy);\n    }\n\n    function touchAngle (event, prevAngle, deltaSource) {\n        deltaSource = deltaSource || defaultOptions.deltaSource;\n\n        var sourceX = deltaSource + 'X',\n            sourceY = deltaSource + 'Y',\n            touches = getTouchPair(event),\n            dx = touches[0][sourceX] - touches[1][sourceX],\n            dy = touches[0][sourceY] - touches[1][sourceY],\n            angle = 180 * Math.atan(dy / dx) / Math.PI;\n\n        if (isNumber(prevAngle)) {\n            var dr = angle - prevAngle,\n                drClamped = dr % 360;\n\n            if (drClamped > 315) {\n                angle -= 360 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped > 135) {\n                angle -= 180 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped < -315) {\n                angle += 360 + (angle / 360)|0 * 360;\n            }\n            else if (drClamped < -135) {\n                angle += 180 + (angle / 360)|0 * 360;\n            }\n        }\n\n        return  angle;\n    }\n\n    function getOriginXY (interactable, element) {\n        var origin = interactable\n                ? interactable.options.origin\n                : defaultOptions.origin;\n\n        if (origin === 'parent') {\n            origin = parentElement(element);\n        }\n        else if (origin === 'self') {\n            origin = interactable.getRect(element);\n        }\n        else if (trySelector(origin)) {\n            origin = closest(element, origin) || { x: 0, y: 0 };\n        }\n\n        if (isFunction(origin)) {\n            origin = origin(interactable && element);\n        }\n\n        if (isElement(origin))  {\n            origin = getElementRect(origin);\n        }\n\n        origin.x = ('x' in origin)? origin.x : origin.left;\n        origin.y = ('y' in origin)? origin.y : origin.top;\n\n        return origin;\n    }\n\n    // http://stackoverflow.com/a/5634528/2280888\n    function _getQBezierValue(t, p1, p2, p3) {\n        var iT = 1 - t;\n        return iT * iT * p1 + 2 * iT * t * p2 + t * t * p3;\n    }\n\n    function getQuadraticCurvePoint(startX, startY, cpX, cpY, endX, endY, position) {\n        return {\n            x:  _getQBezierValue(position, startX, cpX, endX),\n            y:  _getQBezierValue(position, startY, cpY, endY)\n        };\n    }\n\n    // http://gizma.com/easing/\n    function easeOutQuad (t, b, c, d) {\n        t /= d;\n        return -c * t*(t-2) + b;\n    }\n\n    function nodeContains (parent, child) {\n        while (child) {\n            if (child === parent) {\n                return true;\n            }\n\n            child = child.parentNode;\n        }\n\n        return false;\n    }\n\n    function closest (child, selector) {\n        var parent = parentElement(child);\n\n        while (isElement(parent)) {\n            if (matchesSelector(parent, selector)) { return parent; }\n\n            parent = parentElement(parent);\n        }\n\n        return null;\n    }\n\n    function parentElement (node) {\n        var parent = node.parentNode;\n\n        if (isDocFrag(parent)) {\n            // skip past #shado-root fragments\n            while ((parent = parent.host) && isDocFrag(parent)) {}\n\n            return parent;\n        }\n\n        return parent;\n    }\n\n    function inContext (interactable, element) {\n        return interactable._context === element.ownerDocument\n                || nodeContains(interactable._context, element);\n    }\n\n    function testIgnore (interactable, interactableElement, element) {\n        var ignoreFrom = interactable.options.ignoreFrom;\n\n        if (!ignoreFrom || !isElement(element)) { return false; }\n\n        if (isString(ignoreFrom)) {\n            return matchesUpTo(element, ignoreFrom, interactableElement);\n        }\n        else if (isElement(ignoreFrom)) {\n            return nodeContains(ignoreFrom, element);\n        }\n\n        return false;\n    }\n\n    function testAllow (interactable, interactableElement, element) {\n        var allowFrom = interactable.options.allowFrom;\n\n        if (!allowFrom) { return true; }\n\n        if (!isElement(element)) { return false; }\n\n        if (isString(allowFrom)) {\n            return matchesUpTo(element, allowFrom, interactableElement);\n        }\n        else if (isElement(allowFrom)) {\n            return nodeContains(allowFrom, element);\n        }\n\n        return false;\n    }\n\n    function checkAxis (axis, interactable) {\n        if (!interactable) { return false; }\n\n        var thisAxis = interactable.options.drag.axis;\n\n        return (axis === 'xy' || thisAxis === 'xy' || thisAxis === axis);\n    }\n\n    function checkSnap (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return options[action].snap && options[action].snap.enabled;\n    }\n\n    function checkRestrict (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].restrict && options[action].restrict.enabled;\n    }\n\n    function checkAutoScroll (interactable, action) {\n        var options = interactable.options;\n\n        if (/^resize/.test(action)) {\n            action = 'resize';\n        }\n\n        return  options[action].autoScroll && options[action].autoScroll.enabled;\n    }\n\n    function withinInteractionLimit (interactable, element, action) {\n        var options = interactable.options,\n            maxActions = options[action.name].max,\n            maxPerElement = options[action.name].maxPerElement,\n            activeInteractions = 0,\n            targetCount = 0,\n            targetElementCount = 0;\n\n        for (var i = 0, len = interactions.length; i < len; i++) {\n            var interaction = interactions[i],\n                otherAction = interaction.prepared.name,\n                active = interaction.interacting();\n\n            if (!active) { continue; }\n\n            activeInteractions++;\n\n            if (activeInteractions >= maxInteractions) {\n                return false;\n            }\n\n            if (interaction.target !== interactable) { continue; }\n\n            targetCount += (otherAction === action.name)|0;\n\n            if (targetCount >= maxActions) {\n                return false;\n            }\n\n            if (interaction.element === element) {\n                targetElementCount++;\n\n                if (otherAction !== action.name || targetElementCount >= maxPerElement) {\n                    return false;\n                }\n            }\n        }\n\n        return maxInteractions > 0;\n    }\n\n    // Test for the element that's \"above\" all other qualifiers\n    function indexOfDeepestElement (elements) {\n        var dropzone,\n            deepestZone = elements[0],\n            index = deepestZone? 0: -1,\n            parent,\n            deepestZoneParents = [],\n            dropzoneParents = [],\n            child,\n            i,\n            n;\n\n        for (i = 1; i < elements.length; i++) {\n            dropzone = elements[i];\n\n            // an element might belong to multiple selector dropzones\n            if (!dropzone || dropzone === deepestZone) {\n                continue;\n            }\n\n            if (!deepestZone) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            // check if the deepest or current are document.documentElement or document.rootElement\n            // - if the current dropzone is, do nothing and continue\n            if (dropzone.parentNode === dropzone.ownerDocument) {\n                continue;\n            }\n            // - if deepest is, update with the current dropzone and continue to next\n            else if (deepestZone.parentNode === dropzone.ownerDocument) {\n                deepestZone = dropzone;\n                index = i;\n                continue;\n            }\n\n            if (!deepestZoneParents.length) {\n                parent = deepestZone;\n                while (parent.parentNode && parent.parentNode !== parent.ownerDocument) {\n                    deepestZoneParents.unshift(parent);\n                    parent = parent.parentNode;\n                }\n            }\n\n            // if this element is an svg element and the current deepest is\n            // an HTMLElement\n            if (deepestZone instanceof HTMLElement\n                && dropzone instanceof SVGElement\n                && !(dropzone instanceof SVGSVGElement)) {\n\n                if (dropzone === deepestZone.parentNode) {\n                    continue;\n                }\n\n                parent = dropzone.ownerSVGElement;\n            }\n            else {\n                parent = dropzone;\n            }\n\n            dropzoneParents = [];\n\n            while (parent.parentNode !== parent.ownerDocument) {\n                dropzoneParents.unshift(parent);\n                parent = parent.parentNode;\n            }\n\n            n = 0;\n\n            // get (position of last common ancestor) + 1\n            while (dropzoneParents[n] && dropzoneParents[n] === deepestZoneParents[n]) {\n                n++;\n            }\n\n            var parents = [\n                dropzoneParents[n - 1],\n                dropzoneParents[n],\n                deepestZoneParents[n]\n            ];\n\n            child = parents[0].lastChild;\n\n            while (child) {\n                if (child === parents[1]) {\n                    deepestZone = dropzone;\n                    index = i;\n                    deepestZoneParents = [];\n\n                    break;\n                }\n                else if (child === parents[2]) {\n                    break;\n                }\n\n                child = child.previousSibling;\n            }\n        }\n\n        return index;\n    }\n\n    function Interaction () {\n        this.target          = null; // current interactable being interacted with\n        this.element         = null; // the target element of the interactable\n        this.dropTarget      = null; // the dropzone a drag target might be dropped into\n        this.dropElement     = null; // the element at the time of checking\n        this.prevDropTarget  = null; // the dropzone that was recently dragged away from\n        this.prevDropElement = null; // the element at the time of checking\n\n        this.prepared        = {     // action that's ready to be fired on next move event\n            name : null,\n            axis : null,\n            edges: null\n        };\n\n        this.matches         = [];   // all selectors that are matched by target element\n        this.matchElements   = [];   // corresponding elements\n\n        this.inertiaStatus = {\n            active       : false,\n            smoothEnd    : false,\n            ending       : false,\n\n            startEvent: null,\n            upCoords: {},\n\n            xe: 0, ye: 0,\n            sx: 0, sy: 0,\n\n            t0: 0,\n            vx0: 0, vys: 0,\n            duration: 0,\n\n            resumeDx: 0,\n            resumeDy: 0,\n\n            lambda_v0: 0,\n            one_ve_v0: 0,\n            i  : null\n        };\n\n        if (isFunction(Function.prototype.bind)) {\n            this.boundInertiaFrame = this.inertiaFrame.bind(this);\n            this.boundSmoothEndFrame = this.smoothEndFrame.bind(this);\n        }\n        else {\n            var that = this;\n\n            this.boundInertiaFrame = function () { return that.inertiaFrame(); };\n            this.boundSmoothEndFrame = function () { return that.smoothEndFrame(); };\n        }\n\n        this.activeDrops = {\n            dropzones: [],      // the dropzones that are mentioned below\n            elements : [],      // elements of dropzones that accept the target draggable\n            rects    : []       // the rects of the elements mentioned above\n        };\n\n        // keep track of added pointers\n        this.pointers    = [];\n        this.pointerIds  = [];\n        this.downTargets = [];\n        this.downTimes   = [];\n        this.holdTimers  = [];\n\n        // Previous native pointer move event coordinates\n        this.prevCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n        // current native pointer move event coordinates\n        this.curCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n\n        // Starting InteractEvent pointer coordinates\n        this.startCoords = {\n            page     : { x: 0, y: 0 },\n            client   : { x: 0, y: 0 },\n            timeStamp: 0\n        };\n\n        // Change in coordinates and time of the pointer\n        this.pointerDelta = {\n            page     : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n            client   : { x: 0, y: 0, vx: 0, vy: 0, speed: 0 },\n            timeStamp: 0\n        };\n\n        this.downEvent   = null;    // pointerdown/mousedown/touchstart event\n        this.downPointer = {};\n\n        this._eventTarget    = null;\n        this._curEventTarget = null;\n\n        this.prevEvent = null;      // previous action event\n        this.tapTime   = 0;         // time of the most recent tap event\n        this.prevTap   = null;\n\n        this.startOffset    = { left: 0, right: 0, top: 0, bottom: 0 };\n        this.restrictOffset = { left: 0, right: 0, top: 0, bottom: 0 };\n        this.snapOffsets    = [];\n\n        this.gesture = {\n            start: { x: 0, y: 0 },\n\n            startDistance: 0,   // distance between two touches of touchStart\n            prevDistance : 0,\n            distance     : 0,\n\n            scale: 1,           // gesture.distance / gesture.startDistance\n\n            startAngle: 0,      // angle of line joining two touches\n            prevAngle : 0       // angle of the previous gesture event\n        };\n\n        this.snapStatus = {\n            x       : 0, y       : 0,\n            dx      : 0, dy      : 0,\n            realX   : 0, realY   : 0,\n            snappedX: 0, snappedY: 0,\n            targets : [],\n            locked  : false,\n            changed : false\n        };\n\n        this.restrictStatus = {\n            dx         : 0, dy         : 0,\n            restrictedX: 0, restrictedY: 0,\n            snap       : null,\n            restricted : false,\n            changed    : false\n        };\n\n        this.restrictStatus.snap = this.snapStatus;\n\n        this.pointerIsDown   = false;\n        this.pointerWasMoved = false;\n        this.gesturing       = false;\n        this.dragging        = false;\n        this.resizing        = false;\n        this.resizeAxes      = 'xy';\n\n        this.mouse = false;\n\n        interactions.push(this);\n    }\n\n    Interaction.prototype = {\n        getPageXY  : function (pointer, xy) { return   getPageXY(pointer, xy, this); },\n        getClientXY: function (pointer, xy) { return getClientXY(pointer, xy, this); },\n        setEventXY : function (target, ptr) { return  setEventXY(target, ptr, this); },\n\n        pointerOver: function (pointer, event, eventTarget) {\n            if (this.prepared.name || !this.mouse) { return; }\n\n            var curMatches = [],\n                curMatchElements = [],\n                prevTargetElement = this.element;\n\n            this.addPointer(pointer);\n\n            if (this.target\n                && (testIgnore(this.target, this.element, eventTarget)\n                    || !testAllow(this.target, this.element, eventTarget))) {\n                // if the eventTarget should be ignored or shouldn't be allowed\n                // clear the previous target\n                this.target = null;\n                this.element = null;\n                this.matches = [];\n                this.matchElements = [];\n            }\n\n            var elementInteractable = interactables.get(eventTarget),\n                elementAction = (elementInteractable\n                                 && !testIgnore(elementInteractable, eventTarget, eventTarget)\n                                 && testAllow(elementInteractable, eventTarget, eventTarget)\n                                 && validateAction(\n                                     elementInteractable.getAction(pointer, event, this, eventTarget),\n                                     elementInteractable));\n\n            if (elementAction && !withinInteractionLimit(elementInteractable, eventTarget, elementAction)) {\n                 elementAction = null;\n            }\n\n            function pushCurMatches (interactable, selector) {\n                if (interactable\n                    && inContext(interactable, eventTarget)\n                    && !testIgnore(interactable, eventTarget, eventTarget)\n                    && testAllow(interactable, eventTarget, eventTarget)\n                    && matchesSelector(eventTarget, selector)) {\n\n                    curMatches.push(interactable);\n                    curMatchElements.push(eventTarget);\n                }\n            }\n\n            if (elementAction) {\n                this.target = elementInteractable;\n                this.element = eventTarget;\n                this.matches = [];\n                this.matchElements = [];\n            }\n            else {\n                interactables.forEachSelector(pushCurMatches);\n\n                if (this.validateSelector(pointer, event, curMatches, curMatchElements)) {\n                    this.matches = curMatches;\n                    this.matchElements = curMatchElements;\n\n                    this.pointerHover(pointer, event, this.matches, this.matchElements);\n                    events.add(eventTarget,\n                                        supportsPointerEvent? pEventTypes.move : 'mousemove',\n                                        listeners.pointerHover);\n                }\n                else if (this.target) {\n                    if (nodeContains(prevTargetElement, eventTarget)) {\n                        this.pointerHover(pointer, event, this.matches, this.matchElements);\n                        events.add(this.element,\n                                            supportsPointerEvent? pEventTypes.move : 'mousemove',\n                                            listeners.pointerHover);\n                    }\n                    else {\n                        this.target = null;\n                        this.element = null;\n                        this.matches = [];\n                        this.matchElements = [];\n                    }\n                }\n            }\n        },\n\n        // Check what action would be performed on pointerMove target if a mouse\n        // button were pressed and change the cursor accordingly\n        pointerHover: function (pointer, event, eventTarget, curEventTarget, matches, matchElements) {\n            var target = this.target;\n\n            if (!this.prepared.name && this.mouse) {\n\n                var action;\n\n                // update pointer coords for defaultActionChecker to use\n                this.setEventXY(this.curCoords, [pointer]);\n\n                if (matches) {\n                    action = this.validateSelector(pointer, event, matches, matchElements);\n                }\n                else if (target) {\n                    action = validateAction(target.getAction(this.pointers[0], event, this, this.element), this.target);\n                }\n\n                if (target && target.options.styleCursor) {\n                    if (action) {\n                        target._doc.documentElement.style.cursor = getActionCursor(action);\n                    }\n                    else {\n                        target._doc.documentElement.style.cursor = '';\n                    }\n                }\n            }\n            else if (this.prepared.name) {\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n        },\n\n        pointerOut: function (pointer, event, eventTarget) {\n            if (this.prepared.name) { return; }\n\n            // Remove temporary event listeners for selector Interactables\n            if (!interactables.get(eventTarget)) {\n                events.remove(eventTarget,\n                                       supportsPointerEvent? pEventTypes.move : 'mousemove',\n                                       listeners.pointerHover);\n            }\n\n            if (this.target && this.target.options.styleCursor && !this.interacting()) {\n                this.target._doc.documentElement.style.cursor = '';\n            }\n        },\n\n        selectorDown: function (pointer, event, eventTarget, curEventTarget) {\n            var that = this,\n                // copy event to be used in timeout for IE8\n                eventCopy = events.useAttachEvent? extend({}, event) : event,\n                element = eventTarget,\n                pointerIndex = this.addPointer(pointer),\n                action;\n\n            this.holdTimers[pointerIndex] = setTimeout(function () {\n                that.pointerHold(events.useAttachEvent? eventCopy : pointer, eventCopy, eventTarget, curEventTarget);\n            }, defaultOptions._holdDuration);\n\n            this.pointerIsDown = true;\n\n            // Check if the down event hits the current inertia target\n            if (this.inertiaStatus.active && this.target.selector) {\n                // climb up the DOM tree from the event target\n                while (isElement(element)) {\n\n                    // if this element is the current inertia target element\n                    if (element === this.element\n                        // and the prospective action is the same as the ongoing one\n                        && validateAction(this.target.getAction(pointer, event, this, this.element), this.target).name === this.prepared.name) {\n\n                        // stop inertia so that the next move will be a normal one\n                        cancelFrame(this.inertiaStatus.i);\n                        this.inertiaStatus.active = false;\n\n                        this.collectEventTargets(pointer, event, eventTarget, 'down');\n                        return;\n                    }\n                    element = parentElement(element);\n                }\n            }\n\n            // do nothing if interacting\n            if (this.interacting()) {\n                this.collectEventTargets(pointer, event, eventTarget, 'down');\n                return;\n            }\n\n            function pushMatches (interactable, selector, context) {\n                var elements = ie8MatchesSelector\n                    ? context.querySelectorAll(selector)\n                    : undefined;\n\n                if (inContext(interactable, element)\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, elements)) {\n\n                    that.matches.push(interactable);\n                    that.matchElements.push(element);\n                }\n            }\n\n            // update pointer coords for defaultActionChecker to use\n            this.setEventXY(this.curCoords, [pointer]);\n            this.downEvent = event;\n\n            while (isElement(element) && !action) {\n                this.matches = [];\n                this.matchElements = [];\n\n                interactables.forEachSelector(pushMatches);\n\n                action = this.validateSelector(pointer, event, this.matches, this.matchElements);\n                element = parentElement(element);\n            }\n\n            if (action) {\n                this.prepared.name  = action.name;\n                this.prepared.axis  = action.axis;\n                this.prepared.edges = action.edges;\n\n                this.collectEventTargets(pointer, event, eventTarget, 'down');\n\n                return this.pointerDown(pointer, event, eventTarget, curEventTarget, action);\n            }\n            else {\n                // do these now since pointerDown isn't being called from here\n                this.downTimes[pointerIndex] = new Date().getTime();\n                this.downTargets[pointerIndex] = eventTarget;\n                pointerExtend(this.downPointer, pointer);\n\n                copyCoords(this.prevCoords, this.curCoords);\n                this.pointerWasMoved = false;\n            }\n\n            this.collectEventTargets(pointer, event, eventTarget, 'down');\n        },\n\n        // Determine action to be performed on next pointerMove and add appropriate\n        // style and event Listeners\n        pointerDown: function (pointer, event, eventTarget, curEventTarget, forceAction) {\n            if (!forceAction && !this.inertiaStatus.active && this.pointerWasMoved && this.prepared.name) {\n                this.checkAndPreventDefault(event, this.target, this.element);\n\n                return;\n            }\n\n            this.pointerIsDown = true;\n            this.downEvent = event;\n\n            var pointerIndex = this.addPointer(pointer),\n                action;\n\n            // If it is the second touch of a multi-touch gesture, keep the\n            // target the same and get a new action if a target was set by the\n            // first touch\n            if (this.pointerIds.length > 1 && this.target._element === this.element) {\n                var newAction = validateAction(forceAction || this.target.getAction(pointer, event, this, this.element), this.target);\n\n                if (withinInteractionLimit(this.target, this.element, newAction)) {\n                    action = newAction;\n                }\n\n                this.prepared.name = null;\n            }\n            // Otherwise, set the target if there is no action prepared\n            else if (!this.prepared.name) {\n                var interactable = interactables.get(curEventTarget);\n\n                if (interactable\n                    && !testIgnore(interactable, curEventTarget, eventTarget)\n                    && testAllow(interactable, curEventTarget, eventTarget)\n                    && (action = validateAction(forceAction || interactable.getAction(pointer, event, this, curEventTarget), interactable, eventTarget))\n                    && withinInteractionLimit(interactable, curEventTarget, action)) {\n                    this.target = interactable;\n                    this.element = curEventTarget;\n                }\n            }\n\n            var target = this.target,\n                options = target && target.options;\n\n            if (target && (forceAction || !this.prepared.name)) {\n                action = action || validateAction(forceAction || target.getAction(pointer, event, this, curEventTarget), target, this.element);\n\n                this.setEventXY(this.startCoords, this.pointers);\n\n                if (!action) { return; }\n\n                if (options.styleCursor) {\n                    target._doc.documentElement.style.cursor = getActionCursor(action);\n                }\n\n                this.resizeAxes = action.name === 'resize'? action.axis : null;\n\n                if (action === 'gesture' && this.pointerIds.length < 2) {\n                    action = null;\n                }\n\n                this.prepared.name  = action.name;\n                this.prepared.axis  = action.axis;\n                this.prepared.edges = action.edges;\n\n                this.snapStatus.snappedX = this.snapStatus.snappedY =\n                    this.restrictStatus.restrictedX = this.restrictStatus.restrictedY = NaN;\n\n                this.downTimes[pointerIndex] = new Date().getTime();\n                this.downTargets[pointerIndex] = eventTarget;\n                pointerExtend(this.downPointer, pointer);\n\n                copyCoords(this.prevCoords, this.startCoords);\n                this.pointerWasMoved = false;\n\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n            // if inertia is active try to resume action\n            else if (this.inertiaStatus.active\n                && curEventTarget === this.element\n                && validateAction(target.getAction(pointer, event, this, this.element), target).name === this.prepared.name) {\n\n                cancelFrame(this.inertiaStatus.i);\n                this.inertiaStatus.active = false;\n\n                this.checkAndPreventDefault(event, target, this.element);\n            }\n        },\n\n        setModifications: function (coords, preEnd) {\n            var target         = this.target,\n                shouldMove     = true,\n                shouldSnap     = checkSnap(target, this.prepared.name)     && (!target.options[this.prepared.name].snap.endOnly     || preEnd),\n                shouldRestrict = checkRestrict(target, this.prepared.name) && (!target.options[this.prepared.name].restrict.endOnly || preEnd);\n\n            if (shouldSnap    ) { this.setSnapping   (coords); } else { this.snapStatus    .locked     = false; }\n            if (shouldRestrict) { this.setRestriction(coords); } else { this.restrictStatus.restricted = false; }\n\n            if (shouldSnap && this.snapStatus.locked && !this.snapStatus.changed) {\n                shouldMove = shouldRestrict && this.restrictStatus.restricted && this.restrictStatus.changed;\n            }\n            else if (shouldRestrict && this.restrictStatus.restricted && !this.restrictStatus.changed) {\n                shouldMove = false;\n            }\n\n            return shouldMove;\n        },\n\n        setStartOffsets: function (action, interactable, element) {\n            var rect = interactable.getRect(element),\n                origin = getOriginXY(interactable, element),\n                snap = interactable.options[this.prepared.name].snap,\n                restrict = interactable.options[this.prepared.name].restrict,\n                width, height;\n\n            if (rect) {\n                this.startOffset.left = this.startCoords.page.x - rect.left;\n                this.startOffset.top  = this.startCoords.page.y - rect.top;\n\n                this.startOffset.right  = rect.right  - this.startCoords.page.x;\n                this.startOffset.bottom = rect.bottom - this.startCoords.page.y;\n\n                if ('width' in rect) { width = rect.width; }\n                else { width = rect.right - rect.left; }\n                if ('height' in rect) { height = rect.height; }\n                else { height = rect.bottom - rect.top; }\n            }\n            else {\n                this.startOffset.left = this.startOffset.top = this.startOffset.right = this.startOffset.bottom = 0;\n            }\n\n            this.snapOffsets.splice(0);\n\n            var snapOffset = snap && snap.offset === 'startCoords'\n                                ? {\n                                    x: this.startCoords.page.x - origin.x,\n                                    y: this.startCoords.page.y - origin.y\n                                }\n                                : snap && snap.offset || { x: 0, y: 0 };\n\n            if (rect && snap && snap.relativePoints && snap.relativePoints.length) {\n                for (var i = 0; i < snap.relativePoints.length; i++) {\n                    this.snapOffsets.push({\n                        x: this.startOffset.left - (width  * snap.relativePoints[i].x) + snapOffset.x,\n                        y: this.startOffset.top  - (height * snap.relativePoints[i].y) + snapOffset.y\n                    });\n                }\n            }\n            else {\n                this.snapOffsets.push(snapOffset);\n            }\n\n            if (rect && restrict.elementRect) {\n                this.restrictOffset.left = this.startOffset.left - (width  * restrict.elementRect.left);\n                this.restrictOffset.top  = this.startOffset.top  - (height * restrict.elementRect.top);\n\n                this.restrictOffset.right  = this.startOffset.right  - (width  * (1 - restrict.elementRect.right));\n                this.restrictOffset.bottom = this.startOffset.bottom - (height * (1 - restrict.elementRect.bottom));\n            }\n            else {\n                this.restrictOffset.left = this.restrictOffset.top = this.restrictOffset.right = this.restrictOffset.bottom = 0;\n            }\n        },\n\n        /*\\\n         * Interaction.start\n         [ method ]\n         *\n         * Start an action with the given Interactable and Element as tartgets. The\n         * action must be enabled for the target Interactable and an appropriate number\n         * of pointers must be held down – 1 for drag/resize, 2 for gesture.\n         *\n         * Use it with `interactable.<action>able({ manualStart: false })` to always\n         * [start actions manually](https://github.com/taye/interact.js/issues/114)\n         *\n         - action       (object)  The action to be performed - drag, resize, etc.\n         - interactable (Interactable) The Interactable to target\n         - element      (Element) The DOM Element to target\n         = (object) interact\n         **\n         | interact(target)\n         |   .draggable({\n         |     // disable the default drag start by down->move\n         |     manualStart: true\n         |   })\n         |   // start dragging after the user holds the pointer down\n         |   .on('hold', function (event) {\n         |     var interaction = event.interaction;\n         |\n         |     if (!interaction.interacting()) {\n         |       interaction.start({ name: 'drag' },\n         |                         event.interactable,\n         |                         event.currentTarget);\n         |     }\n         | });\n        \\*/\n        start: function (action, interactable, element) {\n            if (this.interacting()\n                || !this.pointerIsDown\n                || this.pointerIds.length < (action.name === 'gesture'? 2 : 1)) {\n                return;\n            }\n\n            // if this interaction had been removed after stopping\n            // add it back\n            if (indexOf(interactions, this) === -1) {\n                interactions.push(this);\n            }\n\n            // set the startCoords if there was no prepared action\n            if (!this.prepared.name) {\n                this.setEventXY(this.startCoords, this.pointers);\n            }\n\n            this.prepared.name  = action.name;\n            this.prepared.axis  = action.axis;\n            this.prepared.edges = action.edges;\n            this.target         = interactable;\n            this.element        = element;\n\n            this.setStartOffsets(action.name, interactable, element);\n            this.setModifications(this.startCoords.page);\n\n            this.prevEvent = this[this.prepared.name + 'Start'](this.downEvent);\n        },\n\n        pointerMove: function (pointer, event, eventTarget, curEventTarget, preEnd) {\n            if (this.inertiaStatus.active) {\n                var pageUp   = this.inertiaStatus.upCoords.page;\n                var clientUp = this.inertiaStatus.upCoords.client;\n\n                var inertiaPosition = {\n                    pageX  : pageUp.x   + this.inertiaStatus.sx,\n                    pageY  : pageUp.y   + this.inertiaStatus.sy,\n                    clientX: clientUp.x + this.inertiaStatus.sx,\n                    clientY: clientUp.y + this.inertiaStatus.sy\n                };\n\n                this.setEventXY(this.curCoords, [inertiaPosition]);\n            }\n            else {\n                this.recordPointer(pointer);\n                this.setEventXY(this.curCoords, this.pointers);\n            }\n\n            var duplicateMove = (this.curCoords.page.x === this.prevCoords.page.x\n                                 && this.curCoords.page.y === this.prevCoords.page.y\n                                 && this.curCoords.client.x === this.prevCoords.client.x\n                                 && this.curCoords.client.y === this.prevCoords.client.y);\n\n            var dx, dy,\n                pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            // register movement greater than pointerMoveTolerance\n            if (this.pointerIsDown && !this.pointerWasMoved) {\n                dx = this.curCoords.client.x - this.startCoords.client.x;\n                dy = this.curCoords.client.y - this.startCoords.client.y;\n\n                this.pointerWasMoved = hypot(dx, dy) > pointerMoveTolerance;\n            }\n\n            if (!duplicateMove && (!this.pointerIsDown || this.pointerWasMoved)) {\n                if (this.pointerIsDown) {\n                    clearTimeout(this.holdTimers[pointerIndex]);\n                }\n\n                this.collectEventTargets(pointer, event, eventTarget, 'move');\n            }\n\n            if (!this.pointerIsDown) { return; }\n\n            if (duplicateMove && this.pointerWasMoved && !preEnd) {\n                this.checkAndPreventDefault(event, this.target, this.element);\n                return;\n            }\n\n            // set pointer coordinate, time changes and speeds\n            setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n            if (!this.prepared.name) { return; }\n\n            if (this.pointerWasMoved\n                // ignore movement while inertia is active\n                && (!this.inertiaStatus.active || (pointer instanceof InteractEvent && /inertiastart/.test(pointer.type)))) {\n\n                // if just starting an action, calculate the pointer speed now\n                if (!this.interacting()) {\n                    setEventDeltas(this.pointerDelta, this.prevCoords, this.curCoords);\n\n                    // check if a drag is in the correct axis\n                    if (this.prepared.name === 'drag') {\n                        var absX = Math.abs(dx),\n                            absY = Math.abs(dy),\n                            targetAxis = this.target.options.drag.axis,\n                            axis = (absX > absY ? 'x' : absX < absY ? 'y' : 'xy');\n\n                        // if the movement isn't in the axis of the interactable\n                        if (axis !== 'xy' && targetAxis !== 'xy' && targetAxis !== axis) {\n                            // cancel the prepared action\n                            this.prepared.name = null;\n\n                            // then try to get a drag from another ineractable\n\n                            var element = eventTarget;\n\n                            // check element interactables\n                            while (isElement(element)) {\n                                var elementInteractable = interactables.get(element);\n\n                                if (elementInteractable\n                                    && elementInteractable !== this.target\n                                    && !elementInteractable.options.drag.manualStart\n                                    && elementInteractable.getAction(this.downPointer, this.downEvent, this, element).name === 'drag'\n                                    && checkAxis(axis, elementInteractable)) {\n\n                                    this.prepared.name = 'drag';\n                                    this.target = elementInteractable;\n                                    this.element = element;\n                                    break;\n                                }\n\n                                element = parentElement(element);\n                            }\n\n                            // if there's no drag from element interactables,\n                            // check the selector interactables\n                            if (!this.prepared.name) {\n                                var thisInteraction = this;\n\n                                var getDraggable = function (interactable, selector, context) {\n                                    var elements = ie8MatchesSelector\n                                        ? context.querySelectorAll(selector)\n                                        : undefined;\n\n                                    if (interactable === thisInteraction.target) { return; }\n\n                                    if (inContext(interactable, eventTarget)\n                                        && !interactable.options.drag.manualStart\n                                        && !testIgnore(interactable, element, eventTarget)\n                                        && testAllow(interactable, element, eventTarget)\n                                        && matchesSelector(element, selector, elements)\n                                        && interactable.getAction(thisInteraction.downPointer, thisInteraction.downEvent, thisInteraction, element).name === 'drag'\n                                        && checkAxis(axis, interactable)\n                                        && withinInteractionLimit(interactable, element, 'drag')) {\n\n                                        return interactable;\n                                    }\n                                };\n\n                                element = eventTarget;\n\n                                while (isElement(element)) {\n                                    var selectorInteractable = interactables.forEachSelector(getDraggable);\n\n                                    if (selectorInteractable) {\n                                        this.prepared.name = 'drag';\n                                        this.target = selectorInteractable;\n                                        this.element = element;\n                                        break;\n                                    }\n\n                                    element = parentElement(element);\n                                }\n                            }\n                        }\n                    }\n                }\n\n                var starting = !!this.prepared.name && !this.interacting();\n\n                if (starting\n                    && (this.target.options[this.prepared.name].manualStart\n                        || !withinInteractionLimit(this.target, this.element, this.prepared))) {\n                    this.stop(event);\n                    return;\n                }\n\n                if (this.prepared.name && this.target) {\n                    if (starting) {\n                        this.start(this.prepared, this.target, this.element);\n                    }\n\n                    var shouldMove = this.setModifications(this.curCoords.page, preEnd);\n\n                    // move if snapping or restriction doesn't prevent it\n                    if (shouldMove || starting) {\n                        this.prevEvent = this[this.prepared.name + 'Move'](event);\n                    }\n\n                    this.checkAndPreventDefault(event, this.target, this.element);\n                }\n            }\n\n            copyCoords(this.prevCoords, this.curCoords);\n\n            if (this.dragging || this.resizing) {\n                this.autoScrollMove(pointer);\n            }\n        },\n\n        dragStart: function (event) {\n            var dragEvent = new InteractEvent(this, event, 'drag', 'start', this.element);\n\n            this.dragging = true;\n            this.target.fire(dragEvent);\n\n            // reset active dropzones\n            this.activeDrops.dropzones = [];\n            this.activeDrops.elements  = [];\n            this.activeDrops.rects     = [];\n\n            if (!this.dynamicDrop) {\n                this.setActiveDrops(this.element);\n            }\n\n            var dropEvents = this.getDropEvents(event, dragEvent);\n\n            if (dropEvents.activate) {\n                this.fireActiveDrops(dropEvents.activate);\n            }\n\n            return dragEvent;\n        },\n\n        dragMove: function (event) {\n            var target = this.target,\n                dragEvent  = new InteractEvent(this, event, 'drag', 'move', this.element),\n                draggableElement = this.element,\n                drop = this.getDrop(dragEvent, event, draggableElement);\n\n            this.dropTarget = drop.dropzone;\n            this.dropElement = drop.element;\n\n            var dropEvents = this.getDropEvents(event, dragEvent);\n\n            target.fire(dragEvent);\n\n            if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n            if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n            if (dropEvents.move ) {     this.dropTarget.fire(dropEvents.move ); }\n\n            this.prevDropTarget  = this.dropTarget;\n            this.prevDropElement = this.dropElement;\n\n            return dragEvent;\n        },\n\n        resizeStart: function (event) {\n            var resizeEvent = new InteractEvent(this, event, 'resize', 'start', this.element);\n\n            if (this.prepared.edges) {\n                var startRect = this.target.getRect(this.element);\n\n                /*\n                 * When using the `resizable.square` or `resizable.preserveAspectRatio` options, resizing from one edge\n                 * will affect another. E.g. with `resizable.square`, resizing to make the right edge larger will make\n                 * the bottom edge larger by the same amount. We call these 'linked' edges. Any linked edges will depend\n                 * on the active edges and the edge being interacted with.\n                 */\n                if (this.target.options.resize.square || this.target.options.resize.preserveAspectRatio) {\n                    var linkedEdges = extend({}, this.prepared.edges);\n\n                    linkedEdges.top    = linkedEdges.top    || (linkedEdges.left   && !linkedEdges.bottom);\n                    linkedEdges.left   = linkedEdges.left   || (linkedEdges.top    && !linkedEdges.right );\n                    linkedEdges.bottom = linkedEdges.bottom || (linkedEdges.right  && !linkedEdges.top   );\n                    linkedEdges.right  = linkedEdges.right  || (linkedEdges.bottom && !linkedEdges.left  );\n\n                    this.prepared._linkedEdges = linkedEdges;\n                }\n                else {\n                    this.prepared._linkedEdges = null;\n                }\n\n                // if using `resizable.preserveAspectRatio` option, record aspect ratio at the start of the resize\n                if (this.target.options.resize.preserveAspectRatio) {\n                    this.resizeStartAspectRatio = startRect.width / startRect.height;\n                }\n\n                this.resizeRects = {\n                    start     : startRect,\n                    current   : extend({}, startRect),\n                    restricted: extend({}, startRect),\n                    previous  : extend({}, startRect),\n                    delta     : {\n                        left: 0, right : 0, width : 0,\n                        top : 0, bottom: 0, height: 0\n                    }\n                };\n\n                resizeEvent.rect = this.resizeRects.restricted;\n                resizeEvent.deltaRect = this.resizeRects.delta;\n            }\n\n            this.target.fire(resizeEvent);\n\n            this.resizing = true;\n\n            return resizeEvent;\n        },\n\n        resizeMove: function (event) {\n            var resizeEvent = new InteractEvent(this, event, 'resize', 'move', this.element);\n\n            var edges = this.prepared.edges,\n                invert = this.target.options.resize.invert,\n                invertible = invert === 'reposition' || invert === 'negate';\n\n            if (edges) {\n                var dx = resizeEvent.dx,\n                    dy = resizeEvent.dy,\n\n                    start      = this.resizeRects.start,\n                    current    = this.resizeRects.current,\n                    restricted = this.resizeRects.restricted,\n                    delta      = this.resizeRects.delta,\n                    previous   = extend(this.resizeRects.previous, restricted),\n\n                    originalEdges = edges;\n\n                // `resize.preserveAspectRatio` takes precedence over `resize.square`\n                if (this.target.options.resize.preserveAspectRatio) {\n                    var resizeStartAspectRatio = this.resizeStartAspectRatio;\n\n                    edges = this.prepared._linkedEdges;\n\n                    if ((originalEdges.left && originalEdges.bottom)\n                        || (originalEdges.right && originalEdges.top)) {\n                        dy = -dx / resizeStartAspectRatio;\n                    }\n                    else if (originalEdges.left || originalEdges.right) { dy = dx / resizeStartAspectRatio; }\n                    else if (originalEdges.top || originalEdges.bottom) { dx = dy * resizeStartAspectRatio; }\n                }\n                else if (this.target.options.resize.square) {\n                    edges = this.prepared._linkedEdges;\n\n                    if ((originalEdges.left && originalEdges.bottom)\n                        || (originalEdges.right && originalEdges.top)) {\n                        dy = -dx;\n                    }\n                    else if (originalEdges.left || originalEdges.right) { dy = dx; }\n                    else if (originalEdges.top || originalEdges.bottom) { dx = dy; }\n                }\n\n                // update the 'current' rect without modifications\n                if (edges.top   ) { current.top    += dy; }\n                if (edges.bottom) { current.bottom += dy; }\n                if (edges.left  ) { current.left   += dx; }\n                if (edges.right ) { current.right  += dx; }\n\n                if (invertible) {\n                    // if invertible, copy the current rect\n                    extend(restricted, current);\n\n                    if (invert === 'reposition') {\n                        // swap edge values if necessary to keep width/height positive\n                        var swap;\n\n                        if (restricted.top > restricted.bottom) {\n                            swap = restricted.top;\n\n                            restricted.top = restricted.bottom;\n                            restricted.bottom = swap;\n                        }\n                        if (restricted.left > restricted.right) {\n                            swap = restricted.left;\n\n                            restricted.left = restricted.right;\n                            restricted.right = swap;\n                        }\n                    }\n                }\n                else {\n                    // if not invertible, restrict to minimum of 0x0 rect\n                    restricted.top    = Math.min(current.top, start.bottom);\n                    restricted.bottom = Math.max(current.bottom, start.top);\n                    restricted.left   = Math.min(current.left, start.right);\n                    restricted.right  = Math.max(current.right, start.left);\n                }\n\n                restricted.width  = restricted.right  - restricted.left;\n                restricted.height = restricted.bottom - restricted.top ;\n\n                for (var edge in restricted) {\n                    delta[edge] = restricted[edge] - previous[edge];\n                }\n\n                resizeEvent.edges = this.prepared.edges;\n                resizeEvent.rect = restricted;\n                resizeEvent.deltaRect = delta;\n            }\n\n            this.target.fire(resizeEvent);\n\n            return resizeEvent;\n        },\n\n        gestureStart: function (event) {\n            var gestureEvent = new InteractEvent(this, event, 'gesture', 'start', this.element);\n\n            gestureEvent.ds = 0;\n\n            this.gesture.startDistance = this.gesture.prevDistance = gestureEvent.distance;\n            this.gesture.startAngle = this.gesture.prevAngle = gestureEvent.angle;\n            this.gesture.scale = 1;\n\n            this.gesturing = true;\n\n            this.target.fire(gestureEvent);\n\n            return gestureEvent;\n        },\n\n        gestureMove: function (event) {\n            if (!this.pointerIds.length) {\n                return this.prevEvent;\n            }\n\n            var gestureEvent;\n\n            gestureEvent = new InteractEvent(this, event, 'gesture', 'move', this.element);\n            gestureEvent.ds = gestureEvent.scale - this.gesture.scale;\n\n            this.target.fire(gestureEvent);\n\n            this.gesture.prevAngle = gestureEvent.angle;\n            this.gesture.prevDistance = gestureEvent.distance;\n\n            if (gestureEvent.scale !== Infinity &&\n                gestureEvent.scale !== null &&\n                gestureEvent.scale !== undefined  &&\n                !isNaN(gestureEvent.scale)) {\n\n                this.gesture.scale = gestureEvent.scale;\n            }\n\n            return gestureEvent;\n        },\n\n        pointerHold: function (pointer, event, eventTarget) {\n            this.collectEventTargets(pointer, event, eventTarget, 'hold');\n        },\n\n        pointerUp: function (pointer, event, eventTarget, curEventTarget) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            clearTimeout(this.holdTimers[pointerIndex]);\n\n            this.collectEventTargets(pointer, event, eventTarget, 'up' );\n            this.collectEventTargets(pointer, event, eventTarget, 'tap');\n\n            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n            this.removePointer(pointer);\n        },\n\n        pointerCancel: function (pointer, event, eventTarget, curEventTarget) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            clearTimeout(this.holdTimers[pointerIndex]);\n\n            this.collectEventTargets(pointer, event, eventTarget, 'cancel');\n            this.pointerEnd(pointer, event, eventTarget, curEventTarget);\n\n            this.removePointer(pointer);\n        },\n\n        // http://www.quirksmode.org/dom/events/click.html\n        // >Events leading to dblclick\n        //\n        // IE8 doesn't fire down event before dblclick.\n        // This workaround tries to fire a tap and doubletap after dblclick\n        ie8Dblclick: function (pointer, event, eventTarget) {\n            if (this.prevTap\n                && event.clientX === this.prevTap.clientX\n                && event.clientY === this.prevTap.clientY\n                && eventTarget   === this.prevTap.target) {\n\n                this.downTargets[0] = eventTarget;\n                this.downTimes[0] = new Date().getTime();\n                this.collectEventTargets(pointer, event, eventTarget, 'tap');\n            }\n        },\n\n        // End interact move events and stop auto-scroll unless inertia is enabled\n        pointerEnd: function (pointer, event, eventTarget, curEventTarget) {\n            var endEvent,\n                target = this.target,\n                options = target && target.options,\n                inertiaOptions = options && this.prepared.name && options[this.prepared.name].inertia,\n                inertiaStatus = this.inertiaStatus;\n\n            if (this.interacting()) {\n\n                if (inertiaStatus.active && !inertiaStatus.ending) { return; }\n\n                var pointerSpeed,\n                    now = new Date().getTime(),\n                    inertiaPossible = false,\n                    inertia = false,\n                    smoothEnd = false,\n                    endSnap = checkSnap(target, this.prepared.name) && options[this.prepared.name].snap.endOnly,\n                    endRestrict = checkRestrict(target, this.prepared.name) && options[this.prepared.name].restrict.endOnly,\n                    dx = 0,\n                    dy = 0,\n                    startEvent;\n\n                if (this.dragging) {\n                    if      (options.drag.axis === 'x' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vx); }\n                    else if (options.drag.axis === 'y' ) { pointerSpeed = Math.abs(this.pointerDelta.client.vy); }\n                    else   /*options.drag.axis === 'xy'*/{ pointerSpeed = this.pointerDelta.client.speed; }\n                }\n                else {\n                    pointerSpeed = this.pointerDelta.client.speed;\n                }\n\n                // check if inertia should be started\n                inertiaPossible = (inertiaOptions && inertiaOptions.enabled\n                                   && this.prepared.name !== 'gesture'\n                                   && event !== inertiaStatus.startEvent);\n\n                inertia = (inertiaPossible\n                           && (now - this.curCoords.timeStamp) < 50\n                           && pointerSpeed > inertiaOptions.minSpeed\n                           && pointerSpeed > inertiaOptions.endSpeed);\n\n                if (inertiaPossible && !inertia && (endSnap || endRestrict)) {\n\n                    var snapRestrict = {};\n\n                    snapRestrict.snap = snapRestrict.restrict = snapRestrict;\n\n                    if (endSnap) {\n                        this.setSnapping(this.curCoords.page, snapRestrict);\n                        if (snapRestrict.locked) {\n                            dx += snapRestrict.dx;\n                            dy += snapRestrict.dy;\n                        }\n                    }\n\n                    if (endRestrict) {\n                        this.setRestriction(this.curCoords.page, snapRestrict);\n                        if (snapRestrict.restricted) {\n                            dx += snapRestrict.dx;\n                            dy += snapRestrict.dy;\n                        }\n                    }\n\n                    if (dx || dy) {\n                        smoothEnd = true;\n                    }\n                }\n\n                if (inertia || smoothEnd) {\n                    copyCoords(inertiaStatus.upCoords, this.curCoords);\n\n                    this.pointers[0] = inertiaStatus.startEvent = startEvent =\n                        new InteractEvent(this, event, this.prepared.name, 'inertiastart', this.element);\n\n                    inertiaStatus.t0 = now;\n\n                    target.fire(inertiaStatus.startEvent);\n\n                    if (inertia) {\n                        inertiaStatus.vx0 = this.pointerDelta.client.vx;\n                        inertiaStatus.vy0 = this.pointerDelta.client.vy;\n                        inertiaStatus.v0 = pointerSpeed;\n\n                        this.calcInertia(inertiaStatus);\n\n                        var page = extend({}, this.curCoords.page),\n                            origin = getOriginXY(target, this.element),\n                            statusObject;\n\n                        page.x = page.x + inertiaStatus.xe - origin.x;\n                        page.y = page.y + inertiaStatus.ye - origin.y;\n\n                        statusObject = {\n                            useStatusXY: true,\n                            x: page.x,\n                            y: page.y,\n                            dx: 0,\n                            dy: 0,\n                            snap: null\n                        };\n\n                        statusObject.snap = statusObject;\n\n                        dx = dy = 0;\n\n                        if (endSnap) {\n                            var snap = this.setSnapping(this.curCoords.page, statusObject);\n\n                            if (snap.locked) {\n                                dx += snap.dx;\n                                dy += snap.dy;\n                            }\n                        }\n\n                        if (endRestrict) {\n                            var restrict = this.setRestriction(this.curCoords.page, statusObject);\n\n                            if (restrict.restricted) {\n                                dx += restrict.dx;\n                                dy += restrict.dy;\n                            }\n                        }\n\n                        inertiaStatus.modifiedXe += dx;\n                        inertiaStatus.modifiedYe += dy;\n\n                        inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n                    }\n                    else {\n                        inertiaStatus.smoothEnd = true;\n                        inertiaStatus.xe = dx;\n                        inertiaStatus.ye = dy;\n\n                        inertiaStatus.sx = inertiaStatus.sy = 0;\n\n                        inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n                    }\n\n                    inertiaStatus.active = true;\n                    return;\n                }\n\n                if (endSnap || endRestrict) {\n                    // fire a move event at the snapped coordinates\n                    this.pointerMove(pointer, event, eventTarget, curEventTarget, true);\n                }\n            }\n\n            if (this.dragging) {\n                endEvent = new InteractEvent(this, event, 'drag', 'end', this.element);\n\n                var draggableElement = this.element,\n                    drop = this.getDrop(endEvent, event, draggableElement);\n\n                this.dropTarget = drop.dropzone;\n                this.dropElement = drop.element;\n\n                var dropEvents = this.getDropEvents(event, endEvent);\n\n                if (dropEvents.leave) { this.prevDropTarget.fire(dropEvents.leave); }\n                if (dropEvents.enter) {     this.dropTarget.fire(dropEvents.enter); }\n                if (dropEvents.drop ) {     this.dropTarget.fire(dropEvents.drop ); }\n                if (dropEvents.deactivate) {\n                    this.fireActiveDrops(dropEvents.deactivate);\n                }\n\n                target.fire(endEvent);\n            }\n            else if (this.resizing) {\n                endEvent = new InteractEvent(this, event, 'resize', 'end', this.element);\n                target.fire(endEvent);\n            }\n            else if (this.gesturing) {\n                endEvent = new InteractEvent(this, event, 'gesture', 'end', this.element);\n                target.fire(endEvent);\n            }\n\n            this.stop(event);\n        },\n\n        collectDrops: function (element) {\n            var drops = [],\n                elements = [],\n                i;\n\n            element = element || this.element;\n\n            // collect all dropzones and their elements which qualify for a drop\n            for (i = 0; i < interactables.length; i++) {\n                if (!interactables[i].options.drop.enabled) { continue; }\n\n                var current = interactables[i],\n                    accept = current.options.drop.accept;\n\n                // test the draggable element against the dropzone's accept setting\n                if ((isElement(accept) && accept !== element)\n                    || (isString(accept)\n                        && !matchesSelector(element, accept))) {\n\n                    continue;\n                }\n\n                // query for new elements if necessary\n                var dropElements = current.selector? current._context.querySelectorAll(current.selector) : [current._element];\n\n                for (var j = 0, len = dropElements.length; j < len; j++) {\n                    var currentElement = dropElements[j];\n\n                    if (currentElement === element) {\n                        continue;\n                    }\n\n                    drops.push(current);\n                    elements.push(currentElement);\n                }\n            }\n\n            return {\n                dropzones: drops,\n                elements: elements\n            };\n        },\n\n        fireActiveDrops: function (event) {\n            var i,\n                current,\n                currentElement,\n                prevElement;\n\n            // loop through all active dropzones and trigger event\n            for (i = 0; i < this.activeDrops.dropzones.length; i++) {\n                current = this.activeDrops.dropzones[i];\n                currentElement = this.activeDrops.elements [i];\n\n                // prevent trigger of duplicate events on same element\n                if (currentElement !== prevElement) {\n                    // set current element as event target\n                    event.target = currentElement;\n                    current.fire(event);\n                }\n                prevElement = currentElement;\n            }\n        },\n\n        // Collect a new set of possible drops and save them in activeDrops.\n        // setActiveDrops should always be called when a drag has just started or a\n        // drag event happens while dynamicDrop is true\n        setActiveDrops: function (dragElement) {\n            // get dropzones and their elements that could receive the draggable\n            var possibleDrops = this.collectDrops(dragElement, true);\n\n            this.activeDrops.dropzones = possibleDrops.dropzones;\n            this.activeDrops.elements  = possibleDrops.elements;\n            this.activeDrops.rects     = [];\n\n            for (var i = 0; i < this.activeDrops.dropzones.length; i++) {\n                this.activeDrops.rects[i] = this.activeDrops.dropzones[i].getRect(this.activeDrops.elements[i]);\n            }\n        },\n\n        getDrop: function (dragEvent, event, dragElement) {\n            var validDrops = [];\n\n            if (dynamicDrop) {\n                this.setActiveDrops(dragElement);\n            }\n\n            // collect all dropzones and their elements which qualify for a drop\n            for (var j = 0; j < this.activeDrops.dropzones.length; j++) {\n                var current        = this.activeDrops.dropzones[j],\n                    currentElement = this.activeDrops.elements [j],\n                    rect           = this.activeDrops.rects    [j];\n\n                validDrops.push(current.dropCheck(dragEvent, event, this.target, dragElement, currentElement, rect)\n                                ? currentElement\n                                : null);\n            }\n\n            // get the most appropriate dropzone based on DOM depth and order\n            var dropIndex = indexOfDeepestElement(validDrops),\n                dropzone  = this.activeDrops.dropzones[dropIndex] || null,\n                element   = this.activeDrops.elements [dropIndex] || null;\n\n            return {\n                dropzone: dropzone,\n                element: element\n            };\n        },\n\n        getDropEvents: function (pointerEvent, dragEvent) {\n            var dropEvents = {\n                enter     : null,\n                leave     : null,\n                activate  : null,\n                deactivate: null,\n                move      : null,\n                drop      : null\n            };\n\n            if (this.dropElement !== this.prevDropElement) {\n                // if there was a prevDropTarget, create a dragleave event\n                if (this.prevDropTarget) {\n                    dropEvents.leave = {\n                        target       : this.prevDropElement,\n                        dropzone     : this.prevDropTarget,\n                        relatedTarget: dragEvent.target,\n                        draggable    : dragEvent.interactable,\n                        dragEvent    : dragEvent,\n                        interaction  : this,\n                        timeStamp    : dragEvent.timeStamp,\n                        type         : 'dragleave'\n                    };\n\n                    dragEvent.dragLeave = this.prevDropElement;\n                    dragEvent.prevDropzone = this.prevDropTarget;\n                }\n                // if the dropTarget is not null, create a dragenter event\n                if (this.dropTarget) {\n                    dropEvents.enter = {\n                        target       : this.dropElement,\n                        dropzone     : this.dropTarget,\n                        relatedTarget: dragEvent.target,\n                        draggable    : dragEvent.interactable,\n                        dragEvent    : dragEvent,\n                        interaction  : this,\n                        timeStamp    : dragEvent.timeStamp,\n                        type         : 'dragenter'\n                    };\n\n                    dragEvent.dragEnter = this.dropElement;\n                    dragEvent.dropzone = this.dropTarget;\n                }\n            }\n\n            if (dragEvent.type === 'dragend' && this.dropTarget) {\n                dropEvents.drop = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'drop'\n                };\n\n                dragEvent.dropzone = this.dropTarget;\n            }\n            if (dragEvent.type === 'dragstart') {\n                dropEvents.activate = {\n                    target       : null,\n                    dropzone     : null,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropactivate'\n                };\n            }\n            if (dragEvent.type === 'dragend') {\n                dropEvents.deactivate = {\n                    target       : null,\n                    dropzone     : null,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropdeactivate'\n                };\n            }\n            if (dragEvent.type === 'dragmove' && this.dropTarget) {\n                dropEvents.move = {\n                    target       : this.dropElement,\n                    dropzone     : this.dropTarget,\n                    relatedTarget: dragEvent.target,\n                    draggable    : dragEvent.interactable,\n                    dragEvent    : dragEvent,\n                    interaction  : this,\n                    dragmove     : dragEvent,\n                    timeStamp    : dragEvent.timeStamp,\n                    type         : 'dropmove'\n                };\n                dragEvent.dropzone = this.dropTarget;\n            }\n\n            return dropEvents;\n        },\n\n        currentAction: function () {\n            return (this.dragging && 'drag') || (this.resizing && 'resize') || (this.gesturing && 'gesture') || null;\n        },\n\n        interacting: function () {\n            return this.dragging || this.resizing || this.gesturing;\n        },\n\n        clearTargets: function () {\n            this.target = this.element = null;\n\n            this.dropTarget = this.dropElement = this.prevDropTarget = this.prevDropElement = null;\n        },\n\n        stop: function (event) {\n            if (this.interacting()) {\n                autoScroll.stop();\n                this.matches = [];\n                this.matchElements = [];\n\n                var target = this.target;\n\n                if (target.options.styleCursor) {\n                    target._doc.documentElement.style.cursor = '';\n                }\n\n                // prevent Default only if were previously interacting\n                if (event && isFunction(event.preventDefault)) {\n                    this.checkAndPreventDefault(event, target, this.element);\n                }\n\n                if (this.dragging) {\n                    this.activeDrops.dropzones = this.activeDrops.elements = this.activeDrops.rects = null;\n                }\n            }\n\n            this.clearTargets();\n\n            this.pointerIsDown = this.snapStatus.locked = this.dragging = this.resizing = this.gesturing = false;\n            this.prepared.name = this.prevEvent = null;\n            this.inertiaStatus.resumeDx = this.inertiaStatus.resumeDy = 0;\n\n            // remove pointers if their ID isn't in this.pointerIds\n            for (var i = 0; i < this.pointers.length; i++) {\n                if (indexOf(this.pointerIds, getPointerId(this.pointers[i])) === -1) {\n                    this.pointers.splice(i, 1);\n                }\n            }\n        },\n\n        inertiaFrame: function () {\n            var inertiaStatus = this.inertiaStatus,\n                options = this.target.options[this.prepared.name].inertia,\n                lambda = options.resistance,\n                t = new Date().getTime() / 1000 - inertiaStatus.t0;\n\n            if (t < inertiaStatus.te) {\n\n                var progress =  1 - (Math.exp(-lambda * t) - inertiaStatus.lambda_v0) / inertiaStatus.one_ve_v0;\n\n                if (inertiaStatus.modifiedXe === inertiaStatus.xe && inertiaStatus.modifiedYe === inertiaStatus.ye) {\n                    inertiaStatus.sx = inertiaStatus.xe * progress;\n                    inertiaStatus.sy = inertiaStatus.ye * progress;\n                }\n                else {\n                    var quadPoint = getQuadraticCurvePoint(\n                            0, 0,\n                            inertiaStatus.xe, inertiaStatus.ye,\n                            inertiaStatus.modifiedXe, inertiaStatus.modifiedYe,\n                            progress);\n\n                    inertiaStatus.sx = quadPoint.x;\n                    inertiaStatus.sy = quadPoint.y;\n                }\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.i = reqFrame(this.boundInertiaFrame);\n            }\n            else {\n                inertiaStatus.ending = true;\n\n                inertiaStatus.sx = inertiaStatus.modifiedXe;\n                inertiaStatus.sy = inertiaStatus.modifiedYe;\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.active = inertiaStatus.ending = false;\n            }\n        },\n\n        smoothEndFrame: function () {\n            var inertiaStatus = this.inertiaStatus,\n                t = new Date().getTime() - inertiaStatus.t0,\n                duration = this.target.options[this.prepared.name].inertia.smoothEndDuration;\n\n            if (t < duration) {\n                inertiaStatus.sx = easeOutQuad(t, 0, inertiaStatus.xe, duration);\n                inertiaStatus.sy = easeOutQuad(t, 0, inertiaStatus.ye, duration);\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.i = reqFrame(this.boundSmoothEndFrame);\n            }\n            else {\n                inertiaStatus.ending = true;\n\n                inertiaStatus.sx = inertiaStatus.xe;\n                inertiaStatus.sy = inertiaStatus.ye;\n\n                this.pointerMove(inertiaStatus.startEvent, inertiaStatus.startEvent);\n                this.pointerEnd(inertiaStatus.startEvent, inertiaStatus.startEvent);\n\n                inertiaStatus.smoothEnd =\n                  inertiaStatus.active = inertiaStatus.ending = false;\n            }\n        },\n\n        addPointer: function (pointer) {\n            var id = getPointerId(pointer),\n                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n            if (index === -1) {\n                index = this.pointerIds.length;\n            }\n\n            this.pointerIds[index] = id;\n            this.pointers[index] = pointer;\n\n            return index;\n        },\n\n        removePointer: function (pointer) {\n            var id = getPointerId(pointer),\n                index = this.mouse? 0 : indexOf(this.pointerIds, id);\n\n            if (index === -1) { return; }\n\n            this.pointers   .splice(index, 1);\n            this.pointerIds .splice(index, 1);\n            this.downTargets.splice(index, 1);\n            this.downTimes  .splice(index, 1);\n            this.holdTimers .splice(index, 1);\n        },\n\n        recordPointer: function (pointer) {\n            var index = this.mouse? 0: indexOf(this.pointerIds, getPointerId(pointer));\n\n            if (index === -1) { return; }\n\n            this.pointers[index] = pointer;\n        },\n\n        collectEventTargets: function (pointer, event, eventTarget, eventType) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer));\n\n            // do not fire a tap event if the pointer was moved before being lifted\n            if (eventType === 'tap' && (this.pointerWasMoved\n                // or if the pointerup target is different to the pointerdown target\n                || !(this.downTargets[pointerIndex] && this.downTargets[pointerIndex] === eventTarget))) {\n                return;\n            }\n\n            var targets = [],\n                elements = [],\n                element = eventTarget;\n\n            function collectSelectors (interactable, selector, context) {\n                var els = ie8MatchesSelector\n                        ? context.querySelectorAll(selector)\n                        : undefined;\n\n                if (interactable._iEvents[eventType]\n                    && isElement(element)\n                    && inContext(interactable, element)\n                    && !testIgnore(interactable, element, eventTarget)\n                    && testAllow(interactable, element, eventTarget)\n                    && matchesSelector(element, selector, els)) {\n\n                    targets.push(interactable);\n                    elements.push(element);\n                }\n            }\n\n            while (element) {\n                if (interact.isSet(element) && interact(element)._iEvents[eventType]) {\n                    targets.push(interact(element));\n                    elements.push(element);\n                }\n\n                interactables.forEachSelector(collectSelectors);\n\n                element = parentElement(element);\n            }\n\n            // create the tap event even if there are no listeners so that\n            // doubletap can still be created and fired\n            if (targets.length || eventType === 'tap') {\n                this.firePointers(pointer, event, eventTarget, targets, elements, eventType);\n            }\n        },\n\n        firePointers: function (pointer, event, eventTarget, targets, elements, eventType) {\n            var pointerIndex = this.mouse? 0 : indexOf(this.pointerIds, getPointerId(pointer)),\n                pointerEvent = {},\n                i,\n                // for tap events\n                interval, createNewDoubleTap;\n\n            // if it's a doubletap then the event properties would have been\n            // copied from the tap event and provided as the pointer argument\n            if (eventType === 'doubletap') {\n                pointerEvent = pointer;\n            }\n            else {\n                pointerExtend(pointerEvent, event);\n                if (event !== pointer) {\n                    pointerExtend(pointerEvent, pointer);\n                }\n\n                pointerEvent.preventDefault           = preventOriginalDefault;\n                pointerEvent.stopPropagation          = InteractEvent.prototype.stopPropagation;\n                pointerEvent.stopImmediatePropagation = InteractEvent.prototype.stopImmediatePropagation;\n                pointerEvent.interaction              = this;\n\n                pointerEvent.timeStamp       = new Date().getTime();\n                pointerEvent.originalEvent   = event;\n                pointerEvent.originalPointer = pointer;\n                pointerEvent.type            = eventType;\n                pointerEvent.pointerId       = getPointerId(pointer);\n                pointerEvent.pointerType     = this.mouse? 'mouse' : !supportsPointerEvent? 'touch'\n                                                    : isString(pointer.pointerType)\n                                                        ? pointer.pointerType\n                                                        : [,,'touch', 'pen', 'mouse'][pointer.pointerType];\n            }\n\n            if (eventType === 'tap') {\n                pointerEvent.dt = pointerEvent.timeStamp - this.downTimes[pointerIndex];\n\n                interval = pointerEvent.timeStamp - this.tapTime;\n                createNewDoubleTap = !!(this.prevTap && this.prevTap.type !== 'doubletap'\n                       && this.prevTap.target === pointerEvent.target\n                       && interval < 500);\n\n                pointerEvent.double = createNewDoubleTap;\n\n                this.tapTime = pointerEvent.timeStamp;\n            }\n\n            for (i = 0; i < targets.length; i++) {\n                pointerEvent.currentTarget = elements[i];\n                pointerEvent.interactable = targets[i];\n                targets[i].fire(pointerEvent);\n\n                if (pointerEvent.immediatePropagationStopped\n                    ||(pointerEvent.propagationStopped && elements[i + 1] !== pointerEvent.currentTarget)) {\n                    break;\n                }\n            }\n\n            if (createNewDoubleTap) {\n                var doubleTap = {};\n\n                extend(doubleTap, pointerEvent);\n\n                doubleTap.dt   = interval;\n                doubleTap.type = 'doubletap';\n\n                this.collectEventTargets(doubleTap, event, eventTarget, 'doubletap');\n\n                this.prevTap = doubleTap;\n            }\n            else if (eventType === 'tap') {\n                this.prevTap = pointerEvent;\n            }\n        },\n\n        validateSelector: function (pointer, event, matches, matchElements) {\n            for (var i = 0, len = matches.length; i < len; i++) {\n                var match = matches[i],\n                    matchElement = matchElements[i],\n                    action = validateAction(match.getAction(pointer, event, this, matchElement), match);\n\n                if (action && withinInteractionLimit(match, matchElement, action)) {\n                    this.target = match;\n                    this.element = matchElement;\n\n                    return action;\n                }\n            }\n        },\n\n        setSnapping: function (pageCoords, status) {\n            var snap = this.target.options[this.prepared.name].snap,\n                targets = [],\n                target,\n                page,\n                i;\n\n            status = status || this.snapStatus;\n\n            if (status.useStatusXY) {\n                page = { x: status.x, y: status.y };\n            }\n            else {\n                var origin = getOriginXY(this.target, this.element);\n\n                page = extend({}, pageCoords);\n\n                page.x -= origin.x;\n                page.y -= origin.y;\n            }\n\n            status.realX = page.x;\n            status.realY = page.y;\n\n            page.x = page.x - this.inertiaStatus.resumeDx;\n            page.y = page.y - this.inertiaStatus.resumeDy;\n\n            var len = snap.targets? snap.targets.length : 0;\n\n            for (var relIndex = 0; relIndex < this.snapOffsets.length; relIndex++) {\n                var relative = {\n                    x: page.x - this.snapOffsets[relIndex].x,\n                    y: page.y - this.snapOffsets[relIndex].y\n                };\n\n                for (i = 0; i < len; i++) {\n                    if (isFunction(snap.targets[i])) {\n                        target = snap.targets[i](relative.x, relative.y, this);\n                    }\n                    else {\n                        target = snap.targets[i];\n                    }\n\n                    if (!target) { continue; }\n\n                    targets.push({\n                        x: isNumber(target.x) ? (target.x + this.snapOffsets[relIndex].x) : relative.x,\n                        y: isNumber(target.y) ? (target.y + this.snapOffsets[relIndex].y) : relative.y,\n\n                        range: isNumber(target.range)? target.range: snap.range\n                    });\n                }\n            }\n\n            var closest = {\n                    target: null,\n                    inRange: false,\n                    distance: 0,\n                    range: 0,\n                    dx: 0,\n                    dy: 0\n                };\n\n            for (i = 0, len = targets.length; i < len; i++) {\n                target = targets[i];\n\n                var range = target.range,\n                    dx = target.x - page.x,\n                    dy = target.y - page.y,\n                    distance = hypot(dx, dy),\n                    inRange = distance <= range;\n\n                // Infinite targets count as being out of range\n                // compared to non infinite ones that are in range\n                if (range === Infinity && closest.inRange && closest.range !== Infinity) {\n                    inRange = false;\n                }\n\n                if (!closest.target || (inRange\n                    // is the closest target in range?\n                    ? (closest.inRange && range !== Infinity\n                        // the pointer is relatively deeper in this target\n                        ? distance / range < closest.distance / closest.range\n                        // this target has Infinite range and the closest doesn't\n                        : (range === Infinity && closest.range !== Infinity)\n                            // OR this target is closer that the previous closest\n                            || distance < closest.distance)\n                    // The other is not in range and the pointer is closer to this target\n                    : (!closest.inRange && distance < closest.distance))) {\n\n                    if (range === Infinity) {\n                        inRange = true;\n                    }\n\n                    closest.target = target;\n                    closest.distance = distance;\n                    closest.range = range;\n                    closest.inRange = inRange;\n                    closest.dx = dx;\n                    closest.dy = dy;\n\n                    status.range = range;\n                }\n            }\n\n            var snapChanged;\n\n            if (closest.target) {\n                snapChanged = (status.snappedX !== closest.target.x || status.snappedY !== closest.target.y);\n\n                status.snappedX = closest.target.x;\n                status.snappedY = closest.target.y;\n            }\n            else {\n                snapChanged = true;\n\n                status.snappedX = NaN;\n                status.snappedY = NaN;\n            }\n\n            status.dx = closest.dx;\n            status.dy = closest.dy;\n\n            status.changed = (snapChanged || (closest.inRange && !status.locked));\n            status.locked = closest.inRange;\n\n            return status;\n        },\n\n        setRestriction: function (pageCoords, status) {\n            var target = this.target,\n                restrict = target && target.options[this.prepared.name].restrict,\n                restriction = restrict && restrict.restriction,\n                page;\n\n            if (!restriction) {\n                return status;\n            }\n\n            status = status || this.restrictStatus;\n\n            page = status.useStatusXY\n                    ? page = { x: status.x, y: status.y }\n                    : page = extend({}, pageCoords);\n\n            if (status.snap && status.snap.locked) {\n                page.x += status.snap.dx || 0;\n                page.y += status.snap.dy || 0;\n            }\n\n            page.x -= this.inertiaStatus.resumeDx;\n            page.y -= this.inertiaStatus.resumeDy;\n\n            status.dx = 0;\n            status.dy = 0;\n            status.restricted = false;\n\n            var rect, restrictedX, restrictedY;\n\n            if (isString(restriction)) {\n                if (restriction === 'parent') {\n                    restriction = parentElement(this.element);\n                }\n                else if (restriction === 'self') {\n                    restriction = target.getRect(this.element);\n                }\n                else {\n                    restriction = closest(this.element, restriction);\n                }\n\n                if (!restriction) { return status; }\n            }\n\n            if (isFunction(restriction)) {\n                restriction = restriction(page.x, page.y, this.element);\n            }\n\n            if (isElement(restriction)) {\n                restriction = getElementRect(restriction);\n            }\n\n            rect = restriction;\n\n            if (!restriction) {\n                restrictedX = page.x;\n                restrictedY = page.y;\n            }\n            // object is assumed to have\n            // x, y, width, height or\n            // left, top, right, bottom\n            else if ('x' in restriction && 'y' in restriction) {\n                restrictedX = Math.max(Math.min(rect.x + rect.width  - this.restrictOffset.right , page.x), rect.x + this.restrictOffset.left);\n                restrictedY = Math.max(Math.min(rect.y + rect.height - this.restrictOffset.bottom, page.y), rect.y + this.restrictOffset.top );\n            }\n            else {\n                restrictedX = Math.max(Math.min(rect.right  - this.restrictOffset.right , page.x), rect.left + this.restrictOffset.left);\n                restrictedY = Math.max(Math.min(rect.bottom - this.restrictOffset.bottom, page.y), rect.top  + this.restrictOffset.top );\n            }\n\n            status.dx = restrictedX - page.x;\n            status.dy = restrictedY - page.y;\n\n            status.changed = status.restrictedX !== restrictedX || status.restrictedY !== restrictedY;\n            status.restricted = !!(status.dx || status.dy);\n\n            status.restrictedX = restrictedX;\n            status.restrictedY = restrictedY;\n\n            return status;\n        },\n\n        checkAndPreventDefault: function (event, interactable, element) {\n            if (!(interactable = interactable || this.target)) { return; }\n\n            var options = interactable.options,\n                prevent = options.preventDefault;\n\n            if (prevent === 'auto' && element && !/^(input|select|textarea)$/i.test(event.target.nodeName)) {\n                // do not preventDefault on pointerdown if the prepared action is a drag\n                // and dragging can only start from a certain direction - this allows\n                // a touch to pan the viewport if a drag isn't in the right direction\n                if (/down|start/i.test(event.type)\n                    && this.prepared.name === 'drag' && options.drag.axis !== 'xy') {\n\n                    return;\n                }\n\n                // with manualStart, only preventDefault while interacting\n                if (options[this.prepared.name] && options[this.prepared.name].manualStart\n                    && !this.interacting()) {\n                    return;\n                }\n\n                event.preventDefault();\n                return;\n            }\n\n            if (prevent === 'always') {\n                event.preventDefault();\n                return;\n            }\n        },\n\n        calcInertia: function (status) {\n            var inertiaOptions = this.target.options[this.prepared.name].inertia,\n                lambda = inertiaOptions.resistance,\n                inertiaDur = -Math.log(inertiaOptions.endSpeed / status.v0) / lambda;\n\n            status.x0 = this.prevEvent.pageX;\n            status.y0 = this.prevEvent.pageY;\n            status.t0 = status.startEvent.timeStamp / 1000;\n            status.sx = status.sy = 0;\n\n            status.modifiedXe = status.xe = (status.vx0 - inertiaDur) / lambda;\n            status.modifiedYe = status.ye = (status.vy0 - inertiaDur) / lambda;\n            status.te = inertiaDur;\n\n            status.lambda_v0 = lambda / status.v0;\n            status.one_ve_v0 = 1 - inertiaOptions.endSpeed / status.v0;\n        },\n\n        autoScrollMove: function (pointer) {\n            if (!(this.interacting()\n                && checkAutoScroll(this.target, this.prepared.name))) {\n                return;\n            }\n\n            if (this.inertiaStatus.active) {\n                autoScroll.x = autoScroll.y = 0;\n                return;\n            }\n\n            var top,\n                right,\n                bottom,\n                left,\n                options = this.target.options[this.prepared.name].autoScroll,\n                container = options.container || getWindow(this.element);\n\n            if (isWindow(container)) {\n                left   = pointer.clientX < autoScroll.margin;\n                top    = pointer.clientY < autoScroll.margin;\n                right  = pointer.clientX > container.innerWidth  - autoScroll.margin;\n                bottom = pointer.clientY > container.innerHeight - autoScroll.margin;\n            }\n            else {\n                var rect = getElementClientRect(container);\n\n                left   = pointer.clientX < rect.left   + autoScroll.margin;\n                top    = pointer.clientY < rect.top    + autoScroll.margin;\n                right  = pointer.clientX > rect.right  - autoScroll.margin;\n                bottom = pointer.clientY > rect.bottom - autoScroll.margin;\n            }\n\n            autoScroll.x = (right ? 1: left? -1: 0);\n            autoScroll.y = (bottom? 1:  top? -1: 0);\n\n            if (!autoScroll.isScrolling) {\n                // set the autoScroll properties to those of the target\n                autoScroll.margin = options.margin;\n                autoScroll.speed  = options.speed;\n\n                autoScroll.start(this);\n            }\n        },\n\n        _updateEventTargets: function (target, currentTarget) {\n            this._eventTarget    = target;\n            this._curEventTarget = currentTarget;\n        }\n\n    };\n\n    function getInteractionFromPointer (pointer, eventType, eventTarget) {\n        var i = 0, len = interactions.length,\n            mouseEvent = (/mouse/i.test(pointer.pointerType || eventType)\n                          // MSPointerEvent.MSPOINTER_TYPE_MOUSE\n                          || pointer.pointerType === 4),\n            interaction;\n\n        var id = getPointerId(pointer);\n\n        // try to resume inertia with a new pointer\n        if (/down|start/i.test(eventType)) {\n            for (i = 0; i < len; i++) {\n                interaction = interactions[i];\n\n                var element = eventTarget;\n\n                if (interaction.inertiaStatus.active && interaction.target.options[interaction.prepared.name].inertia.allowResume\n                    && (interaction.mouse === mouseEvent)) {\n                    while (element) {\n                        // if the element is the interaction element\n                        if (element === interaction.element) {\n                            return interaction;\n                        }\n                        element = parentElement(element);\n                    }\n                }\n            }\n        }\n\n        // if it's a mouse interaction\n        if (mouseEvent || !(supportsTouch || supportsPointerEvent)) {\n\n            // find a mouse interaction that's not in inertia phase\n            for (i = 0; i < len; i++) {\n                if (interactions[i].mouse && !interactions[i].inertiaStatus.active) {\n                    return interactions[i];\n                }\n            }\n\n            // find any interaction specifically for mouse.\n            // if the eventType is a mousedown, and inertia is active\n            // ignore the interaction\n            for (i = 0; i < len; i++) {\n                if (interactions[i].mouse && !(/down/.test(eventType) && interactions[i].inertiaStatus.active)) {\n                    return interaction;\n                }\n            }\n\n            // create a new interaction for mouse\n            interaction = new Interaction();\n            interaction.mouse = true;\n\n            return interaction;\n        }\n\n        // get interaction that has this pointer\n        for (i = 0; i < len; i++) {\n            if (contains(interactions[i].pointerIds, id)) {\n                return interactions[i];\n            }\n        }\n\n        // at this stage, a pointerUp should not return an interaction\n        if (/up|end|out/i.test(eventType)) {\n            return null;\n        }\n\n        // get first idle interaction\n        for (i = 0; i < len; i++) {\n            interaction = interactions[i];\n\n            if ((!interaction.prepared.name || (interaction.target.options.gesture.enabled))\n                && !interaction.interacting()\n                && !(!mouseEvent && interaction.mouse)) {\n\n                return interaction;\n            }\n        }\n\n        return new Interaction();\n    }\n\n    function doOnInteractions (method) {\n        return (function (event) {\n            var interaction,\n                eventTarget = getActualElement(event.path\n                                               ? event.path[0]\n                                               : event.target),\n                curEventTarget = getActualElement(event.currentTarget),\n                i;\n\n            if (supportsTouch && /touch/.test(event.type)) {\n                prevTouchTime = new Date().getTime();\n\n                for (i = 0; i < event.changedTouches.length; i++) {\n                    var pointer = event.changedTouches[i];\n\n                    interaction = getInteractionFromPointer(pointer, event.type, eventTarget);\n\n                    if (!interaction) { continue; }\n\n                    interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                    interaction[method](pointer, event, eventTarget, curEventTarget);\n                }\n            }\n            else {\n                if (!supportsPointerEvent && /mouse/.test(event.type)) {\n                    // ignore mouse events while touch interactions are active\n                    for (i = 0; i < interactions.length; i++) {\n                        if (!interactions[i].mouse && interactions[i].pointerIsDown) {\n                            return;\n                        }\n                    }\n\n                    // try to ignore mouse events that are simulated by the browser\n                    // after a touch event\n                    if (new Date().getTime() - prevTouchTime < 500) {\n                        return;\n                    }\n                }\n\n                interaction = getInteractionFromPointer(event, event.type, eventTarget);\n\n                if (!interaction) { return; }\n\n                interaction._updateEventTargets(eventTarget, curEventTarget);\n\n                interaction[method](event, event, eventTarget, curEventTarget);\n            }\n        });\n    }\n\n    function InteractEvent (interaction, event, action, phase, element, related) {\n        var client,\n            page,\n            target      = interaction.target,\n            snapStatus  = interaction.snapStatus,\n            restrictStatus  = interaction.restrictStatus,\n            pointers    = interaction.pointers,\n            deltaSource = (target && target.options || defaultOptions).deltaSource,\n            sourceX     = deltaSource + 'X',\n            sourceY     = deltaSource + 'Y',\n            options     = target? target.options: defaultOptions,\n            origin      = getOriginXY(target, element),\n            starting    = phase === 'start',\n            ending      = phase === 'end',\n            coords      = starting? interaction.startCoords : interaction.curCoords;\n\n        element = element || interaction.element;\n\n        page   = extend({}, coords.page);\n        client = extend({}, coords.client);\n\n        page.x -= origin.x;\n        page.y -= origin.y;\n\n        client.x -= origin.x;\n        client.y -= origin.y;\n\n        var relativePoints = options[action].snap && options[action].snap.relativePoints ;\n\n        if (checkSnap(target, action) && !(starting && relativePoints && relativePoints.length)) {\n            this.snap = {\n                range  : snapStatus.range,\n                locked : snapStatus.locked,\n                x      : snapStatus.snappedX,\n                y      : snapStatus.snappedY,\n                realX  : snapStatus.realX,\n                realY  : snapStatus.realY,\n                dx     : snapStatus.dx,\n                dy     : snapStatus.dy\n            };\n\n            if (snapStatus.locked) {\n                page.x += snapStatus.dx;\n                page.y += snapStatus.dy;\n                client.x += snapStatus.dx;\n                client.y += snapStatus.dy;\n            }\n        }\n\n        if (checkRestrict(target, action) && !(starting && options[action].restrict.elementRect) && restrictStatus.restricted) {\n            page.x += restrictStatus.dx;\n            page.y += restrictStatus.dy;\n            client.x += restrictStatus.dx;\n            client.y += restrictStatus.dy;\n\n            this.restrict = {\n                dx: restrictStatus.dx,\n                dy: restrictStatus.dy\n            };\n        }\n\n        this.pageX     = page.x;\n        this.pageY     = page.y;\n        this.clientX   = client.x;\n        this.clientY   = client.y;\n\n        this.x0        = interaction.startCoords.page.x - origin.x;\n        this.y0        = interaction.startCoords.page.y - origin.y;\n        this.clientX0  = interaction.startCoords.client.x - origin.x;\n        this.clientY0  = interaction.startCoords.client.y - origin.y;\n        this.ctrlKey   = event.ctrlKey;\n        this.altKey    = event.altKey;\n        this.shiftKey  = event.shiftKey;\n        this.metaKey   = event.metaKey;\n        this.button    = event.button;\n        this.buttons   = event.buttons;\n        this.target    = element;\n        this.t0        = interaction.downTimes[0];\n        this.type      = action + (phase || '');\n\n        this.interaction = interaction;\n        this.interactable = target;\n\n        var inertiaStatus = interaction.inertiaStatus;\n\n        if (inertiaStatus.active) {\n            this.detail = 'inertia';\n        }\n\n        if (related) {\n            this.relatedTarget = related;\n        }\n\n        // end event dx, dy is difference between start and end points\n        if (ending) {\n            if (deltaSource === 'client') {\n                this.dx = client.x - interaction.startCoords.client.x;\n                this.dy = client.y - interaction.startCoords.client.y;\n            }\n            else {\n                this.dx = page.x - interaction.startCoords.page.x;\n                this.dy = page.y - interaction.startCoords.page.y;\n            }\n        }\n        else if (starting) {\n            this.dx = 0;\n            this.dy = 0;\n        }\n        // copy properties from previousmove if starting inertia\n        else if (phase === 'inertiastart') {\n            this.dx = interaction.prevEvent.dx;\n            this.dy = interaction.prevEvent.dy;\n        }\n        else {\n            if (deltaSource === 'client') {\n                this.dx = client.x - interaction.prevEvent.clientX;\n                this.dy = client.y - interaction.prevEvent.clientY;\n            }\n            else {\n                this.dx = page.x - interaction.prevEvent.pageX;\n                this.dy = page.y - interaction.prevEvent.pageY;\n            }\n        }\n        if (interaction.prevEvent && interaction.prevEvent.detail === 'inertia'\n            && !inertiaStatus.active\n            && options[action].inertia && options[action].inertia.zeroResumeDelta) {\n\n            inertiaStatus.resumeDx += this.dx;\n            inertiaStatus.resumeDy += this.dy;\n\n            this.dx = this.dy = 0;\n        }\n\n        if (action === 'resize' && interaction.resizeAxes) {\n            if (options.resize.square) {\n                if (interaction.resizeAxes === 'y') {\n                    this.dx = this.dy;\n                }\n                else {\n                    this.dy = this.dx;\n                }\n                this.axes = 'xy';\n            }\n            else {\n                this.axes = interaction.resizeAxes;\n\n                if (interaction.resizeAxes === 'x') {\n                    this.dy = 0;\n                }\n                else if (interaction.resizeAxes === 'y') {\n                    this.dx = 0;\n                }\n            }\n        }\n        else if (action === 'gesture') {\n            this.touches = [pointers[0], pointers[1]];\n\n            if (starting) {\n                this.distance = touchDistance(pointers, deltaSource);\n                this.box      = touchBBox(pointers);\n                this.scale    = 1;\n                this.ds       = 0;\n                this.angle    = touchAngle(pointers, undefined, deltaSource);\n                this.da       = 0;\n            }\n            else if (ending || event instanceof InteractEvent) {\n                this.distance = interaction.prevEvent.distance;\n                this.box      = interaction.prevEvent.box;\n                this.scale    = interaction.prevEvent.scale;\n                this.ds       = this.scale - 1;\n                this.angle    = interaction.prevEvent.angle;\n                this.da       = this.angle - interaction.gesture.startAngle;\n            }\n            else {\n                this.distance = touchDistance(pointers, deltaSource);\n                this.box      = touchBBox(pointers);\n                this.scale    = this.distance / interaction.gesture.startDistance;\n                this.angle    = touchAngle(pointers, interaction.gesture.prevAngle, deltaSource);\n\n                this.ds = this.scale - interaction.gesture.prevScale;\n                this.da = this.angle - interaction.gesture.prevAngle;\n            }\n        }\n\n        if (starting) {\n            this.timeStamp = interaction.downTimes[0];\n            this.dt        = 0;\n            this.duration  = 0;\n            this.speed     = 0;\n            this.velocityX = 0;\n            this.velocityY = 0;\n        }\n        else if (phase === 'inertiastart') {\n            this.timeStamp = interaction.prevEvent.timeStamp;\n            this.dt        = interaction.prevEvent.dt;\n            this.duration  = interaction.prevEvent.duration;\n            this.speed     = interaction.prevEvent.speed;\n            this.velocityX = interaction.prevEvent.velocityX;\n            this.velocityY = interaction.prevEvent.velocityY;\n        }\n        else {\n            this.timeStamp = new Date().getTime();\n            this.dt        = this.timeStamp - interaction.prevEvent.timeStamp;\n            this.duration  = this.timeStamp - interaction.downTimes[0];\n\n            if (event instanceof InteractEvent) {\n                var dx = this[sourceX] - interaction.prevEvent[sourceX],\n                    dy = this[sourceY] - interaction.prevEvent[sourceY],\n                    dt = this.dt / 1000;\n\n                this.speed = hypot(dx, dy) / dt;\n                this.velocityX = dx / dt;\n                this.velocityY = dy / dt;\n            }\n            // if normal move or end event, use previous user event coords\n            else {\n                // speed and velocity in pixels per second\n                this.speed = interaction.pointerDelta[deltaSource].speed;\n                this.velocityX = interaction.pointerDelta[deltaSource].vx;\n                this.velocityY = interaction.pointerDelta[deltaSource].vy;\n            }\n        }\n\n        if ((ending || phase === 'inertiastart')\n            && interaction.prevEvent.speed > 600 && this.timeStamp - interaction.prevEvent.timeStamp < 150) {\n\n            var angle = 180 * Math.atan2(interaction.prevEvent.velocityY, interaction.prevEvent.velocityX) / Math.PI,\n                overlap = 22.5;\n\n            if (angle < 0) {\n                angle += 360;\n            }\n\n            var left = 135 - overlap <= angle && angle < 225 + overlap,\n                up   = 225 - overlap <= angle && angle < 315 + overlap,\n\n                right = !left && (315 - overlap <= angle || angle <  45 + overlap),\n                down  = !up   &&   45 - overlap <= angle && angle < 135 + overlap;\n\n            this.swipe = {\n                up   : up,\n                down : down,\n                left : left,\n                right: right,\n                angle: angle,\n                speed: interaction.prevEvent.speed,\n                velocity: {\n                    x: interaction.prevEvent.velocityX,\n                    y: interaction.prevEvent.velocityY\n                }\n            };\n        }\n    }\n\n    InteractEvent.prototype = {\n        preventDefault: blank,\n        stopImmediatePropagation: function () {\n            this.immediatePropagationStopped = this.propagationStopped = true;\n        },\n        stopPropagation: function () {\n            this.propagationStopped = true;\n        }\n    };\n\n    function preventOriginalDefault () {\n        this.originalEvent.preventDefault();\n    }\n\n    function getActionCursor (action) {\n        var cursor = '';\n\n        if (action.name === 'drag') {\n            cursor =  actionCursors.drag;\n        }\n        if (action.name === 'resize') {\n            if (action.axis) {\n                cursor =  actionCursors[action.name + action.axis];\n            }\n            else if (action.edges) {\n                var cursorKey = 'resize',\n                    edgeNames = ['top', 'bottom', 'left', 'right'];\n\n                for (var i = 0; i < 4; i++) {\n                    if (action.edges[edgeNames[i]]) {\n                        cursorKey += edgeNames[i];\n                    }\n                }\n\n                cursor = actionCursors[cursorKey];\n            }\n        }\n\n        return cursor;\n    }\n\n    function checkResizeEdge (name, value, page, element, interactableElement, rect, margin) {\n        // false, '', undefined, null\n        if (!value) { return false; }\n\n        // true value, use pointer coords and element rect\n        if (value === true) {\n            // if dimensions are negative, \"switch\" edges\n            var width = isNumber(rect.width)? rect.width : rect.right - rect.left,\n                height = isNumber(rect.height)? rect.height : rect.bottom - rect.top;\n\n            if (width < 0) {\n                if      (name === 'left' ) { name = 'right'; }\n                else if (name === 'right') { name = 'left' ; }\n            }\n            if (height < 0) {\n                if      (name === 'top'   ) { name = 'bottom'; }\n                else if (name === 'bottom') { name = 'top'   ; }\n            }\n\n            if (name === 'left'  ) { return page.x < ((width  >= 0? rect.left: rect.right ) + margin); }\n            if (name === 'top'   ) { return page.y < ((height >= 0? rect.top : rect.bottom) + margin); }\n\n            if (name === 'right' ) { return page.x > ((width  >= 0? rect.right : rect.left) - margin); }\n            if (name === 'bottom') { return page.y > ((height >= 0? rect.bottom: rect.top ) - margin); }\n        }\n\n        // the remaining checks require an element\n        if (!isElement(element)) { return false; }\n\n        return isElement(value)\n                    // the value is an element to use as a resize handle\n                    ? value === element\n                    // otherwise check if element matches value as selector\n                    : matchesUpTo(element, value, interactableElement);\n    }\n\n    function defaultActionChecker (pointer, interaction, element) {\n        var rect = this.getRect(element),\n            shouldResize = false,\n            action = null,\n            resizeAxes = null,\n            resizeEdges,\n            page = extend({}, interaction.curCoords.page),\n            options = this.options;\n\n        if (!rect) { return null; }\n\n        if (actionIsEnabled.resize && options.resize.enabled) {\n            var resizeOptions = options.resize;\n\n            resizeEdges = {\n                left: false, right: false, top: false, bottom: false\n            };\n\n            // if using resize.edges\n            if (isObject(resizeOptions.edges)) {\n                for (var edge in resizeEdges) {\n                    resizeEdges[edge] = checkResizeEdge(edge,\n                                                        resizeOptions.edges[edge],\n                                                        page,\n                                                        interaction._eventTarget,\n                                                        element,\n                                                        rect,\n                                                        resizeOptions.margin || margin);\n                }\n\n                resizeEdges.left = resizeEdges.left && !resizeEdges.right;\n                resizeEdges.top  = resizeEdges.top  && !resizeEdges.bottom;\n\n                shouldResize = resizeEdges.left || resizeEdges.right || resizeEdges.top || resizeEdges.bottom;\n            }\n            else {\n                var right  = options.resize.axis !== 'y' && page.x > (rect.right  - margin),\n                    bottom = options.resize.axis !== 'x' && page.y > (rect.bottom - margin);\n\n                shouldResize = right || bottom;\n                resizeAxes = (right? 'x' : '') + (bottom? 'y' : '');\n            }\n        }\n\n        action = shouldResize\n            ? 'resize'\n            : actionIsEnabled.drag && options.drag.enabled\n                ? 'drag'\n                : null;\n\n        if (actionIsEnabled.gesture\n            && interaction.pointerIds.length >=2\n            && !(interaction.dragging || interaction.resizing)) {\n            action = 'gesture';\n        }\n\n        if (action) {\n            return {\n                name: action,\n                axis: resizeAxes,\n                edges: resizeEdges\n            };\n        }\n\n        return null;\n    }\n\n    // Check if action is enabled globally and the current target supports it\n    // If so, return the validated action. Otherwise, return null\n    function validateAction (action, interactable) {\n        if (!isObject(action)) { return null; }\n\n        var actionName = action.name,\n            options = interactable.options;\n\n        if ((  (actionName  === 'resize'   && options.resize.enabled )\n            || (actionName      === 'drag'     && options.drag.enabled  )\n            || (actionName      === 'gesture'  && options.gesture.enabled))\n            && actionIsEnabled[actionName]) {\n\n            if (actionName === 'resize' || actionName === 'resizeyx') {\n                actionName = 'resizexy';\n            }\n\n            return action;\n        }\n        return null;\n    }\n\n    var listeners = {},\n        interactionListeners = [\n            'dragStart', 'dragMove', 'resizeStart', 'resizeMove', 'gestureStart', 'gestureMove',\n            'pointerOver', 'pointerOut', 'pointerHover', 'selectorDown',\n            'pointerDown', 'pointerMove', 'pointerUp', 'pointerCancel', 'pointerEnd',\n            'addPointer', 'removePointer', 'recordPointer', 'autoScrollMove'\n        ];\n\n    for (var i = 0, len = interactionListeners.length; i < len; i++) {\n        var name = interactionListeners[i];\n\n        listeners[name] = doOnInteractions(name);\n    }\n\n    // bound to the interactable context when a DOM event\n    // listener is added to a selector interactable\n    function delegateListener (event, useCapture) {\n        var fakeEvent = {},\n            delegated = delegatedEvents[event.type],\n            eventTarget = getActualElement(event.path\n                                           ? event.path[0]\n                                           : event.target),\n            element = eventTarget;\n\n        useCapture = useCapture? true: false;\n\n        // duplicate the event so that currentTarget can be changed\n        for (var prop in event) {\n            fakeEvent[prop] = event[prop];\n        }\n\n        fakeEvent.originalEvent = event;\n        fakeEvent.preventDefault = preventOriginalDefault;\n\n        // climb up document tree looking for selector matches\n        while (isElement(element)) {\n            for (var i = 0; i < delegated.selectors.length; i++) {\n                var selector = delegated.selectors[i],\n                    context = delegated.contexts[i];\n\n                if (matchesSelector(element, selector)\n                    && nodeContains(context, eventTarget)\n                    && nodeContains(context, element)) {\n\n                    var listeners = delegated.listeners[i];\n\n                    fakeEvent.currentTarget = element;\n\n                    for (var j = 0; j < listeners.length; j++) {\n                        if (listeners[j][1] === useCapture) {\n                            listeners[j][0](fakeEvent);\n                        }\n                    }\n                }\n            }\n\n            element = parentElement(element);\n        }\n    }\n\n    function delegateUseCapture (event) {\n        return delegateListener.call(this, event, true);\n    }\n\n    interactables.indexOfElement = function indexOfElement (element, context) {\n        context = context || document;\n\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if ((interactable.selector === element\n                && (interactable._context === context))\n                || (!interactable.selector && interactable._element === element)) {\n\n                return i;\n            }\n        }\n        return -1;\n    };\n\n    interactables.get = function interactableGet (element, options) {\n        return this[this.indexOfElement(element, options && options.context)];\n    };\n\n    interactables.forEachSelector = function (callback) {\n        for (var i = 0; i < this.length; i++) {\n            var interactable = this[i];\n\n            if (!interactable.selector) {\n                continue;\n            }\n\n            var ret = callback(interactable, interactable.selector, interactable._context, i, this);\n\n            if (ret !== undefined) {\n                return ret;\n            }\n        }\n    };\n\n    /*\\\n     * interact\n     [ method ]\n     *\n     * The methods of this variable can be used to set elements as\n     * interactables and also to change various default settings.\n     *\n     * Calling it as a function and passing an element or a valid CSS selector\n     * string returns an Interactable object which has various methods to\n     * configure it.\n     *\n     - element (Element | string) The HTML or SVG Element to interact with or CSS selector\n     = (object) An @Interactable\n     *\n     > Usage\n     | interact(document.getElementById('draggable')).draggable(true);\n     |\n     | var rectables = interact('rect');\n     | rectables\n     |     .gesturable(true)\n     |     .on('gesturemove', function (event) {\n     |         // something cool...\n     |     })\n     |     .autoScroll(true);\n    \\*/\n    function interact (element, options) {\n        return interactables.get(element, options) || new Interactable(element, options);\n    }\n\n    /*\\\n     * Interactable\n     [ property ]\n     **\n     * Object type returned by @interact\n    \\*/\n    function Interactable (element, options) {\n        this._element = element;\n        this._iEvents = this._iEvents || {};\n\n        var _window;\n\n        if (trySelector(element)) {\n            this.selector = element;\n\n            var context = options && options.context;\n\n            _window = context? getWindow(context) : window;\n\n            if (context && (_window.Node\n                    ? context instanceof _window.Node\n                    : (isElement(context) || context === _window.document))) {\n\n                this._context = context;\n            }\n        }\n        else {\n            _window = getWindow(element);\n\n            if (isElement(element, _window)) {\n\n                if (supportsPointerEvent) {\n                    events.add(this._element, pEventTypes.down, listeners.pointerDown );\n                    events.add(this._element, pEventTypes.move, listeners.pointerHover);\n                }\n                else {\n                    events.add(this._element, 'mousedown' , listeners.pointerDown );\n                    events.add(this._element, 'mousemove' , listeners.pointerHover);\n                    events.add(this._element, 'touchstart', listeners.pointerDown );\n                    events.add(this._element, 'touchmove' , listeners.pointerHover);\n                }\n            }\n        }\n\n        this._doc = _window.document;\n\n        if (!contains(documents, this._doc)) {\n            listenToDocument(this._doc);\n        }\n\n        interactables.push(this);\n\n        this.set(options);\n    }\n\n    Interactable.prototype = {\n        setOnEvents: function (action, phases) {\n            if (action === 'drop') {\n                if (isFunction(phases.ondrop)          ) { this.ondrop           = phases.ondrop          ; }\n                if (isFunction(phases.ondropactivate)  ) { this.ondropactivate   = phases.ondropactivate  ; }\n                if (isFunction(phases.ondropdeactivate)) { this.ondropdeactivate = phases.ondropdeactivate; }\n                if (isFunction(phases.ondragenter)     ) { this.ondragenter      = phases.ondragenter     ; }\n                if (isFunction(phases.ondragleave)     ) { this.ondragleave      = phases.ondragleave     ; }\n                if (isFunction(phases.ondropmove)      ) { this.ondropmove       = phases.ondropmove      ; }\n            }\n            else {\n                action = 'on' + action;\n\n                if (isFunction(phases.onstart)       ) { this[action + 'start'         ] = phases.onstart         ; }\n                if (isFunction(phases.onmove)        ) { this[action + 'move'          ] = phases.onmove          ; }\n                if (isFunction(phases.onend)         ) { this[action + 'end'           ] = phases.onend           ; }\n                if (isFunction(phases.oninertiastart)) { this[action + 'inertiastart'  ] = phases.oninertiastart  ; }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.draggable\n         [ method ]\n         *\n         * Gets or sets whether drag actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of drag events\n         | var isDraggable = interact('ul li').draggable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on drag events (object makes the Interactable draggable)\n         = (object) This Interactable\n         | interact(element).draggable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // the axis in which the first movement must be\n         |     // for the drag sequence to start\n         |     // 'xy' by default - any direction\n         |     axis: 'x' || 'y' || 'xy',\n         |\n         |     // max number of drags that can happen concurrently\n         |     // with elements of this Interactable. Infinity by default\n         |     max: Infinity,\n         |\n         |     // max number of drags that can target the same element+Interactable\n         |     // 1 by default\n         |     maxPerElement: 2\n         | });\n        \\*/\n        draggable: function (options) {\n            if (isObject(options)) {\n                this.options.drag.enabled = options.enabled === false? false: true;\n                this.setPerAction('drag', options);\n                this.setOnEvents('drag', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.drag.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    delete this.options.drag.axis;\n                }\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.drag.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drag;\n        },\n\n        setPerAction: function (action, options) {\n            // for all the default per-action options\n            for (var option in options) {\n                // if this option exists for this action\n                if (option in defaultOptions[action]) {\n                    // if the option in the options arg is an object value\n                    if (isObject(options[option])) {\n                        // duplicate the object\n                        this.options[action][option] = extend(this.options[action][option] || {}, options[option]);\n\n                        if (isObject(defaultOptions.perAction[option]) && 'enabled' in defaultOptions.perAction[option]) {\n                            this.options[action][option].enabled = options[option].enabled === false? false : true;\n                        }\n                    }\n                    else if (isBool(options[option]) && isObject(defaultOptions.perAction[option])) {\n                        this.options[action][option].enabled = options[option];\n                    }\n                    else if (options[option] !== undefined) {\n                        // or if it's not undefined, do a plain assignment\n                        this.options[action][option] = options[option];\n                    }\n                }\n            }\n        },\n\n        /*\\\n         * Interactable.dropzone\n         [ method ]\n         *\n         * Returns or sets whether elements can be dropped onto this\n         * Interactable to trigger drop events\n         *\n         * Dropzones can receive the following events:\n         *  - `dropactivate` and `dropdeactivate` when an acceptable drag starts and ends\n         *  - `dragenter` and `dragleave` when a draggable enters and leaves the dropzone\n         *  - `dragmove` when a draggable that has entered the dropzone is moved\n         *  - `drop` when a draggable is dropped into this dropzone\n         *\n         *  Use the `accept` option to allow only elements that match the given CSS selector or element.\n         *\n         *  Use the `overlap` option to set how drops are checked for. The allowed values are:\n         *   - `'pointer'`, the pointer must be over the dropzone (default)\n         *   - `'center'`, the draggable element's center must be over the dropzone\n         *   - a number from 0-1 which is the `(intersection area) / (draggable area)`.\n         *       e.g. `0.5` for drop to happen when half of the area of the\n         *       draggable is over the dropzone\n         *\n         - options (boolean | object | null) #optional The new value to be set.\n         | interact('.drop').dropzone({\n         |   accept: '.can-drop' || document.getElementById('single-drop'),\n         |   overlap: 'pointer' || 'center' || zeroToOne\n         | }\n         = (boolean | object) The current setting or this Interactable\n        \\*/\n        dropzone: function (options) {\n            if (isObject(options)) {\n                this.options.drop.enabled = options.enabled === false? false: true;\n                this.setOnEvents('drop', options);\n\n                if (/^(pointer|center)$/.test(options.overlap)) {\n                    this.options.drop.overlap = options.overlap;\n                }\n                else if (isNumber(options.overlap)) {\n                    this.options.drop.overlap = Math.max(Math.min(1, options.overlap), 0);\n                }\n                if ('accept' in options) {\n                  this.options.drop.accept = options.accept;\n                }\n                if ('checker' in options) {\n                  this.options.drop.checker = options.checker;\n                }\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.drop.enabled = options;\n\n                return this;\n            }\n\n            return this.options.drop;\n        },\n\n        dropCheck: function (dragEvent, event, draggable, draggableElement, dropElement, rect) {\n            var dropped = false;\n\n            // if the dropzone has no rect (eg. display: none)\n            // call the custom dropChecker or just return false\n            if (!(rect = rect || this.getRect(dropElement))) {\n                return (this.options.drop.checker\n                    ? this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement)\n                    : false);\n            }\n\n            var dropOverlap = this.options.drop.overlap;\n\n            if (dropOverlap === 'pointer') {\n                var page = getPageXY(dragEvent),\n                    origin = getOriginXY(draggable, draggableElement),\n                    horizontal,\n                    vertical;\n\n                page.x += origin.x;\n                page.y += origin.y;\n\n                horizontal = (page.x > rect.left) && (page.x < rect.right);\n                vertical   = (page.y > rect.top ) && (page.y < rect.bottom);\n\n                dropped = horizontal && vertical;\n            }\n\n            var dragRect = draggable.getRect(draggableElement);\n\n            if (dropOverlap === 'center') {\n                var cx = dragRect.left + dragRect.width  / 2,\n                    cy = dragRect.top  + dragRect.height / 2;\n\n                dropped = cx >= rect.left && cx <= rect.right && cy >= rect.top && cy <= rect.bottom;\n            }\n\n            if (isNumber(dropOverlap)) {\n                var overlapArea  = (Math.max(0, Math.min(rect.right , dragRect.right ) - Math.max(rect.left, dragRect.left))\n                                  * Math.max(0, Math.min(rect.bottom, dragRect.bottom) - Math.max(rect.top , dragRect.top ))),\n                    overlapRatio = overlapArea / (dragRect.width * dragRect.height);\n\n                dropped = overlapRatio >= dropOverlap;\n            }\n\n            if (this.options.drop.checker) {\n                dropped = this.options.drop.checker(dragEvent, event, dropped, this, dropElement, draggable, draggableElement);\n            }\n\n            return dropped;\n        },\n\n        /*\\\n         * Interactable.dropChecker\n         [ method ]\n         *\n         * DEPRECATED. Use interactable.dropzone({ checker: function... }) instead.\n         *\n         * Gets or sets the function used to check if a dragged element is\n         * over this Interactable.\n         *\n         - checker (function) #optional The function that will be called when checking for a drop\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         * The checker function takes the following arguments:\n         *\n         - dragEvent (InteractEvent) The related dragmove or dragend event\n         - event (TouchEvent | PointerEvent | MouseEvent) The user move/up/end Event related to the dragEvent\n         - dropped (boolean) The value from the default drop checker\n         - dropzone (Interactable) The dropzone interactable\n         - dropElement (Element) The dropzone element\n         - draggable (Interactable) The Interactable being dragged\n         - draggableElement (Element) The actual element that's being dragged\n         *\n         > Usage:\n         | interact(target)\n         | .dropChecker(function(dragEvent,         // related dragmove or dragend event\n         |                       event,             // TouchEvent/PointerEvent/MouseEvent\n         |                       dropped,           // bool result of the default checker\n         |                       dropzone,          // dropzone Interactable\n         |                       dropElement,       // dropzone elemnt\n         |                       draggable,         // draggable Interactable\n         |                       draggableElement) {// draggable element\n         |\n         |   return dropped && event.target.hasAttribute('allow-drop');\n         | }\n        \\*/\n        dropChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.options.drop.checker = checker;\n\n                return this;\n            }\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.options.drop.checker;\n        },\n\n        /*\\\n         * Interactable.accept\n         [ method ]\n         *\n         * Deprecated. add an `accept` property to the options object passed to\n         * @Interactable.dropzone instead.\n         *\n         * Gets or sets the Element or CSS selector match that this\n         * Interactable accepts if it is a dropzone.\n         *\n         - newValue (Element | string | null) #optional\n         * If it is an Element, then only that element can be dropped into this dropzone.\n         * If it is a string, the element being dragged must match it as a selector.\n         * If it is null, the accept options is cleared - it accepts any element.\n         *\n         = (string | Element | null | Interactable) The current accept option if given `undefined` or this Interactable\n        \\*/\n        accept: function (newValue) {\n            if (isElement(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            // test if it is a valid CSS selector\n            if (trySelector(newValue)) {\n                this.options.drop.accept = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.drop.accept;\n\n                return this;\n            }\n\n            return this.options.drop.accept;\n        },\n\n        /*\\\n         * Interactable.resizable\n         [ method ]\n         *\n         * Gets or sets whether resize actions can be performed on the\n         * Interactable\n         *\n         = (boolean) Indicates if this can be the target of resize elements\n         | var isResizeable = interact('input[type=text]').resizable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on resize events (object makes the Interactable resizable)\n         = (object) This Interactable\n         | interact(element).resizable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     edges: {\n         |       top   : true,       // Use pointer coords to check for resize.\n         |       left  : false,      // Disable resizing from left edge.\n         |       bottom: '.resize-s',// Resize if pointer target matches selector\n         |       right : handleEl    // Resize if pointer target is the given Element\n         |     },\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height are adjusted at a 1:1 ratio.\n         |     square: false,\n         |\n         |     // Width and height can be adjusted independently. When `true`, width and\n         |     // height maintain the aspect ratio they had when resizing started.\n         |     preserveAspectRatio: false,\n         |\n         |     // a value of 'none' will limit the resize rect to a minimum of 0x0\n         |     // 'negate' will allow the rect to have negative width/height\n         |     // 'reposition' will keep the width/height positive by swapping\n         |     // the top and bottom edges and/or swapping the left and right edges\n         |     invert: 'none' || 'negate' || 'reposition'\n         |\n         |     // limit multiple resizes.\n         |     // See the explanation in the @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        resizable: function (options) {\n            if (isObject(options)) {\n                this.options.resize.enabled = options.enabled === false? false: true;\n                this.setPerAction('resize', options);\n                this.setOnEvents('resize', options);\n\n                if (/^x$|^y$|^xy$/.test(options.axis)) {\n                    this.options.resize.axis = options.axis;\n                }\n                else if (options.axis === null) {\n                    this.options.resize.axis = defaultOptions.resize.axis;\n                }\n\n                if (isBool(options.preserveAspectRatio)) {\n                    this.options.resize.preserveAspectRatio = options.preserveAspectRatio;\n                }\n                else if (isBool(options.square)) {\n                    this.options.resize.square = options.square;\n                }\n\n                return this;\n            }\n            if (isBool(options)) {\n                this.options.resize.enabled = options;\n\n                return this;\n            }\n            return this.options.resize;\n        },\n\n        /*\\\n         * Interactable.squareResize\n         [ method ]\n         *\n         * Deprecated. Add a `square: true || false` property to @Interactable.resizable instead\n         *\n         * Gets or sets whether resizing is forced 1:1 aspect\n         *\n         = (boolean) Current setting\n         *\n         * or\n         *\n         - newValue (boolean) #optional\n         = (object) this Interactable\n        \\*/\n        squareResize: function (newValue) {\n            if (isBool(newValue)) {\n                this.options.resize.square = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.resize.square;\n\n                return this;\n            }\n\n            return this.options.resize.square;\n        },\n\n        /*\\\n         * Interactable.gesturable\n         [ method ]\n         *\n         * Gets or sets whether multitouch gestures can be performed on the\n         * Interactable's element\n         *\n         = (boolean) Indicates if this can be the target of gesture events\n         | var isGestureable = interact(element).gesturable();\n         * or\n         - options (boolean | object) #optional true/false or An object with event listeners to be fired on gesture events (makes the Interactable gesturable)\n         = (object) this Interactable\n         | interact(element).gesturable({\n         |     onstart: function (event) {},\n         |     onmove : function (event) {},\n         |     onend  : function (event) {},\n         |\n         |     // limit multiple gestures.\n         |     // See the explanation in @Interactable.draggable example\n         |     max: Infinity,\n         |     maxPerElement: 1,\n         | });\n        \\*/\n        gesturable: function (options) {\n            if (isObject(options)) {\n                this.options.gesture.enabled = options.enabled === false? false: true;\n                this.setPerAction('gesture', options);\n                this.setOnEvents('gesture', options);\n\n                return this;\n            }\n\n            if (isBool(options)) {\n                this.options.gesture.enabled = options;\n\n                return this;\n            }\n\n            return this.options.gesture;\n        },\n\n        /*\\\n         * Interactable.autoScroll\n         [ method ]\n         **\n         * Deprecated. Add an `autoscroll` property to the options object\n         * passed to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets whether dragging and resizing near the edges of the\n         * window/container trigger autoScroll for this Interactable\n         *\n         = (object) Object with autoScroll properties\n         *\n         * or\n         *\n         - options (object | boolean) #optional\n         * options can be:\n         * - an object with margin, distance and interval properties,\n         * - true or false to enable or disable autoScroll or\n         = (Interactable) this Interactable\n        \\*/\n        autoScroll: function (options) {\n            if (isObject(options)) {\n                options = extend({ actions: ['drag', 'resize']}, options);\n            }\n            else if (isBool(options)) {\n                options = { actions: ['drag', 'resize'], enabled: options };\n            }\n\n            return this.setOptions('autoScroll', options);\n        },\n\n        /*\\\n         * Interactable.snap\n         [ method ]\n         **\n         * Deprecated. Add a `snap` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how action coordinates are snapped. By\n         * default, snapping is relative to the pointer coordinates. You can\n         * change this by setting the\n         * [`elementOrigin`](https://github.com/taye/interact.js/pull/72).\n         **\n         = (boolean | object) `false` if snap is disabled; object with snap properties if snap is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | interact(document.querySelector('#thing')).snap({\n         |     targets: [\n         |         // snap to this specific point\n         |         {\n         |             x: 100,\n         |             y: 100,\n         |             range: 25\n         |         },\n         |         // give this function the x and y page coords and snap to the object returned\n         |         function (x, y) {\n         |             return {\n         |                 x: x,\n         |                 y: (75 + 50 * Math.sin(x * 0.04)),\n         |                 range: 40\n         |             };\n         |         },\n         |         // create a function that snaps to a grid\n         |         interact.createSnapGrid({\n         |             x: 50,\n         |             y: 50,\n         |             range: 10,              // optional\n         |             offset: { x: 5, y: 10 } // optional\n         |         })\n         |     ],\n         |     // do not snap during normal movement.\n         |     // Instead, trigger only one snapped move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     relativePoints: [\n         |         { x: 0, y: 0 },  // snap relative to the top left of the element\n         |         { x: 1, y: 1 },  // and also to the bottom right\n         |     ],  \n         |\n         |     // offset the snap target coordinates\n         |     // can be an object with x/y or 'startCoords'\n         |     offset: { x: 50, y: 50 }\n         |   }\n         | });\n        \\*/\n        snap: function (options) {\n            var ret = this.setOptions('snap', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        setOptions: function (option, options) {\n            var actions = options && isArray(options.actions)\n                    ? options.actions\n                    : ['drag'];\n\n            var i;\n\n            if (isObject(options) || isBool(options)) {\n                for (i = 0; i < actions.length; i++) {\n                    var action = /resize/.test(actions[i])? 'resize' : actions[i];\n\n                    if (!isObject(this.options[action])) { continue; }\n\n                    var thisOption = this.options[action][option];\n\n                    if (isObject(options)) {\n                        extend(thisOption, options);\n                        thisOption.enabled = options.enabled === false? false: true;\n\n                        if (option === 'snap') {\n                            if (thisOption.mode === 'grid') {\n                                thisOption.targets = [\n                                    interact.createSnapGrid(extend({\n                                        offset: thisOption.gridOffset || { x: 0, y: 0 }\n                                    }, thisOption.grid || {}))\n                                ];\n                            }\n                            else if (thisOption.mode === 'anchor') {\n                                thisOption.targets = thisOption.anchors;\n                            }\n                            else if (thisOption.mode === 'path') {\n                                thisOption.targets = thisOption.paths;\n                            }\n\n                            if ('elementOrigin' in options) {\n                                thisOption.relativePoints = [options.elementOrigin];\n                            }\n                        }\n                    }\n                    else if (isBool(options)) {\n                        thisOption.enabled = options;\n                    }\n                }\n\n                return this;\n            }\n\n            var ret = {},\n                allActions = ['drag', 'resize', 'gesture'];\n\n            for (i = 0; i < allActions.length; i++) {\n                if (option in defaultOptions[allActions[i]]) {\n                    ret[allActions[i]] = this.options[allActions[i]][option];\n                }\n            }\n\n            return ret;\n        },\n\n\n        /*\\\n         * Interactable.inertia\n         [ method ]\n         **\n         * Deprecated. Add an `inertia` property to the options object passed\n         * to @Interactable.draggable or @Interactable.resizable instead.\n         *\n         * Returns or sets if and how events continue to run after the pointer is released\n         **\n         = (boolean | object) `false` if inertia is disabled; `object` with inertia properties if inertia is enabled\n         **\n         * or\n         **\n         - options (object | boolean | null) #optional\n         = (Interactable) this Interactable\n         > Usage\n         | // enable and use default settings\n         | interact(element).inertia(true);\n         |\n         | // enable and use custom settings\n         | interact(element).inertia({\n         |     // value greater than 0\n         |     // high values slow the object down more quickly\n         |     resistance     : 16,\n         |\n         |     // the minimum launch speed (pixels per second) that results in inertia start\n         |     minSpeed       : 200,\n         |\n         |     // inertia will stop when the object slows down to this speed\n         |     endSpeed       : 20,\n         |\n         |     // boolean; should actions be resumed when the pointer goes down during inertia\n         |     allowResume    : true,\n         |\n         |     // boolean; should the jump when resuming from inertia be ignored in event.dx/dy\n         |     zeroResumeDelta: false,\n         |\n         |     // if snap/restrict are set to be endOnly and inertia is enabled, releasing\n         |     // the pointer without triggering inertia will animate from the release\n         |     // point to the snaped/restricted point in the given amount of time (ms)\n         |     smoothEndDuration: 300,\n         |\n         |     // an array of action types that can have inertia (no gesture)\n         |     actions        : ['drag', 'resize']\n         | });\n         |\n         | // reset custom settings and use all defaults\n         | interact(element).inertia(null);\n        \\*/\n        inertia: function (options) {\n            var ret = this.setOptions('inertia', options);\n\n            if (ret === this) { return this; }\n\n            return ret.drag;\n        },\n\n        getAction: function (pointer, event, interaction, element) {\n            var action = this.defaultActionChecker(pointer, interaction, element);\n\n            if (this.options.actionChecker) {\n                return this.options.actionChecker(pointer, event, action, this, element, interaction);\n            }\n\n            return action;\n        },\n\n        defaultActionChecker: defaultActionChecker,\n\n        /*\\\n         * Interactable.actionChecker\n         [ method ]\n         *\n         * Gets or sets the function used to check action to be performed on\n         * pointerDown\n         *\n         - checker (function | null) #optional A function which takes a pointer event, defaultAction string, interactable, element and interaction as parameters and returns an object with name property 'drag' 'resize' or 'gesture' and optionally an `edges` object with boolean 'top', 'left', 'bottom' and right props.\n         = (Function | Interactable) The checker function or this Interactable\n         *\n         | interact('.resize-drag')\n         |   .resizable(true)\n         |   .draggable(true)\n         |   .actionChecker(function (pointer, event, action, interactable, element, interaction) {\n         |\n         |   if (interact.matchesSelector(event.target, '.drag-handle') {\n         |     // force drag with handle target\n         |     action.name = drag;\n         |   }\n         |   else {\n         |     // resize from the top and right edges\n         |     action.name  = 'resize';\n         |     action.edges = { top: true, right: true };\n         |   }\n         |\n         |   return action;\n         | });\n        \\*/\n        actionChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.options.actionChecker = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.actionChecker;\n\n                return this;\n            }\n\n            return this.options.actionChecker;\n        },\n\n        /*\\\n         * Interactable.getRect\n         [ method ]\n         *\n         * The default function to get an Interactables bounding rect. Can be\n         * overridden using @Interactable.rectChecker.\n         *\n         - element (Element) #optional The element to measure.\n         = (object) The object's bounding rectangle.\n         o {\n         o     top   : 0,\n         o     left  : 0,\n         o     bottom: 0,\n         o     right : 0,\n         o     width : 0,\n         o     height: 0\n         o }\n        \\*/\n        getRect: function rectCheck (element) {\n            element = element || this._element;\n\n            if (this.selector && !(isElement(element))) {\n                element = this._context.querySelector(this.selector);\n            }\n\n            return getElementRect(element);\n        },\n\n        /*\\\n         * Interactable.rectChecker\n         [ method ]\n         *\n         * Returns or sets the function used to calculate the interactable's\n         * element's rectangle\n         *\n         - checker (function) #optional A function which returns this Interactable's bounding rectangle. See @Interactable.getRect\n         = (function | object) The checker function or this Interactable\n        \\*/\n        rectChecker: function (checker) {\n            if (isFunction(checker)) {\n                this.getRect = checker;\n\n                return this;\n            }\n\n            if (checker === null) {\n                delete this.options.getRect;\n\n                return this;\n            }\n\n            return this.getRect;\n        },\n\n        /*\\\n         * Interactable.styleCursor\n         [ method ]\n         *\n         * Returns or sets whether the action that would be performed when the\n         * mouse on the element are checked on `mousemove` so that the cursor\n         * may be styled appropriately\n         *\n         - newValue (boolean) #optional\n         = (boolean | Interactable) The current setting or this Interactable\n        \\*/\n        styleCursor: function (newValue) {\n            if (isBool(newValue)) {\n                this.options.styleCursor = newValue;\n\n                return this;\n            }\n\n            if (newValue === null) {\n                delete this.options.styleCursor;\n\n                return this;\n            }\n\n            return this.options.styleCursor;\n        },\n\n        /*\\\n         * Interactable.preventDefault\n         [ method ]\n         *\n         * Returns or sets whether to prevent the browser's default behaviour\n         * in response to pointer events. Can be set to:\n         *  - `'always'` to always prevent\n         *  - `'never'` to never prevent\n         *  - `'auto'` to let interact.js try to determine what would be best\n         *\n         - newValue (string) #optional `true`, `false` or `'auto'`\n         = (string | Interactable) The current setting or this Interactable\n        \\*/\n        preventDefault: function (newValue) {\n            if (/^(always|never|auto)$/.test(newValue)) {\n                this.options.preventDefault = newValue;\n                return this;\n            }\n\n            if (isBool(newValue)) {\n                this.options.preventDefault = newValue? 'always' : 'never';\n                return this;\n            }\n\n            return this.options.preventDefault;\n        },\n\n        /*\\\n         * Interactable.origin\n         [ method ]\n         *\n         * Gets or sets the origin of the Interactable's element.  The x and y\n         * of the origin will be subtracted from action event coordinates.\n         *\n         - origin (object | string) #optional An object eg. { x: 0, y: 0 } or string 'parent', 'self' or any CSS selector\n         * OR\n         - origin (Element) #optional An HTML or SVG Element whose rect will be used\n         **\n         = (object) The current origin or this Interactable\n        \\*/\n        origin: function (newValue) {\n            if (trySelector(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n            else if (isObject(newValue)) {\n                this.options.origin = newValue;\n                return this;\n            }\n\n            return this.options.origin;\n        },\n\n        /*\\\n         * Interactable.deltaSource\n         [ method ]\n         *\n         * Returns or sets the mouse coordinate types used to calculate the\n         * movement of the pointer.\n         *\n         - newValue (string) #optional Use 'client' if you will be scrolling while interacting; Use 'page' if you want autoScroll to work\n         = (string | object) The current deltaSource or this Interactable\n        \\*/\n        deltaSource: function (newValue) {\n            if (newValue === 'page' || newValue === 'client') {\n                this.options.deltaSource = newValue;\n\n                return this;\n            }\n\n            return this.options.deltaSource;\n        },\n\n        /*\\\n         * Interactable.restrict\n         [ method ]\n         **\n         * Deprecated. Add a `restrict` property to the options object passed to\n         * @Interactable.draggable, @Interactable.resizable or @Interactable.gesturable instead.\n         *\n         * Returns or sets the rectangles within which actions on this\n         * interactable (after snap calculations) are restricted. By default,\n         * restricting is relative to the pointer coordinates. You can change\n         * this by setting the\n         * [`elementRect`](https://github.com/taye/interact.js/pull/72).\n         **\n         - options (object) #optional an object with keys drag, resize, and/or gesture whose values are rects, Elements, CSS selectors, or 'parent' or 'self'\n         = (object) The current restrictions object or this Interactable\n         **\n         | interact(element).restrict({\n         |     // the rect will be `interact.getElementRect(element.parentNode)`\n         |     drag: element.parentNode,\n         |\n         |     // x and y are relative to the the interactable's origin\n         |     resize: { x: 100, y: 100, width: 200, height: 200 }\n         | })\n         |\n         | interact('.draggable').restrict({\n         |     // the rect will be the selected element's parent\n         |     drag: 'parent',\n         |\n         |     // do not restrict during normal movement.\n         |     // Instead, trigger only one restricted move event\n         |     // immediately before the end event.\n         |     endOnly: true,\n         |\n         |     // https://github.com/taye/interact.js/pull/72#issue-41813493\n         |     elementRect: { top: 0, left: 0, bottom: 1, right: 1 }\n         | });\n        \\*/\n        restrict: function (options) {\n            if (!isObject(options)) {\n                return this.setOptions('restrict', options);\n            }\n\n            var actions = ['drag', 'resize', 'gesture'],\n                ret;\n\n            for (var i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                if (action in options) {\n                    var perAction = extend({\n                            actions: [action],\n                            restriction: options[action]\n                        }, options);\n\n                    ret = this.setOptions('restrict', perAction);\n                }\n            }\n\n            return ret;\n        },\n\n        /*\\\n         * Interactable.context\n         [ method ]\n         *\n         * Gets the selector context Node of the Interactable. The default is `window.document`.\n         *\n         = (Node) The context Node of this Interactable\n         **\n        \\*/\n        context: function () {\n            return this._context;\n        },\n\n        _context: document,\n\n        /*\\\n         * Interactable.ignoreFrom\n         [ method ]\n         *\n         * If the target of the `mousedown`, `pointerdown` or `touchstart`\n         * event or any of it's parents match the given CSS selector or\n         * Element, no drag/resize/gesture is started.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to not ignore any elements\n         = (string | Element | object) The current ignoreFrom value or this Interactable\n         **\n         | interact(element, { ignoreFrom: document.getElementById('no-action') });\n         | // or\n         | interact(element).ignoreFrom('input, textarea, a');\n        \\*/\n        ignoreFrom: function (newValue) {\n            if (trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            if (isElement(newValue)) {              // specific element\n                this.options.ignoreFrom = newValue;\n                return this;\n            }\n\n            return this.options.ignoreFrom;\n        },\n\n        /*\\\n         * Interactable.allowFrom\n         [ method ]\n         *\n         * A drag/resize/gesture is started only If the target of the\n         * `mousedown`, `pointerdown` or `touchstart` event or any of it's\n         * parents match the given CSS selector or Element.\n         *\n         - newValue (string | Element | null) #optional a CSS selector string, an Element or `null` to allow from any element\n         = (string | Element | object) The current allowFrom value or this Interactable\n         **\n         | interact(element, { allowFrom: document.getElementById('drag-handle') });\n         | // or\n         | interact(element).allowFrom('.handle');\n        \\*/\n        allowFrom: function (newValue) {\n            if (trySelector(newValue)) {            // CSS selector to match event.target\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            if (isElement(newValue)) {              // specific element\n                this.options.allowFrom = newValue;\n                return this;\n            }\n\n            return this.options.allowFrom;\n        },\n\n        /*\\\n         * Interactable.element\n         [ method ]\n         *\n         * If this is not a selector Interactable, it returns the element this\n         * interactable represents\n         *\n         = (Element) HTML / SVG Element\n        \\*/\n        element: function () {\n            return this._element;\n        },\n\n        /*\\\n         * Interactable.fire\n         [ method ]\n         *\n         * Calls listeners for the given InteractEvent type bound globally\n         * and directly to this Interactable\n         *\n         - iEvent (InteractEvent) The InteractEvent object to be fired on this Interactable\n         = (Interactable) this Interactable\n        \\*/\n        fire: function (iEvent) {\n            if (!(iEvent && iEvent.type) || !contains(eventTypes, iEvent.type)) {\n                return this;\n            }\n\n            var listeners,\n                i,\n                len,\n                onEvent = 'on' + iEvent.type,\n                funcName = '';\n\n            // Interactable#on() listeners\n            if (iEvent.type in this._iEvents) {\n                listeners = this._iEvents[iEvent.type];\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            // interactable.onevent listener\n            if (isFunction(this[onEvent])) {\n                funcName = this[onEvent].name;\n                this[onEvent](iEvent);\n            }\n\n            // interact.on() listeners\n            if (iEvent.type in globalEvents && (listeners = globalEvents[iEvent.type]))  {\n\n                for (i = 0, len = listeners.length; i < len && !iEvent.immediatePropagationStopped; i++) {\n                    funcName = listeners[i].name;\n                    listeners[i](iEvent);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.on\n         [ method ]\n         *\n         * Binds a listener for an InteractEvent or DOM event.\n         *\n         - eventType  (string | array | object) The types of events to listen for\n         - listener   (function) The function to be called on the given event(s)\n         - useCapture (boolean) #optional useCapture flag for addEventListener\n         = (object) This Interactable\n        \\*/\n        on: function (eventType, listener, useCapture) {\n            var i;\n\n            if (isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.on(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.on(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            if (eventType === 'wheel') {\n                eventType = wheelEvent;\n            }\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (contains(eventTypes, eventType)) {\n                // if this type of event was never bound to this Interactable\n                if (!(eventType in this._iEvents)) {\n                    this._iEvents[eventType] = [listener];\n                }\n                else {\n                    this._iEvents[eventType].push(listener);\n                }\n            }\n            // delegated event for selector\n            else if (this.selector) {\n                if (!delegatedEvents[eventType]) {\n                    delegatedEvents[eventType] = {\n                        selectors: [],\n                        contexts : [],\n                        listeners: []\n                    };\n\n                    // add delegate listener functions\n                    for (i = 0; i < documents.length; i++) {\n                        events.add(documents[i], eventType, delegateListener);\n                        events.add(documents[i], eventType, delegateUseCapture, true);\n                    }\n                }\n\n                var delegated = delegatedEvents[eventType],\n                    index;\n\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n                        break;\n                    }\n                }\n\n                if (index === -1) {\n                    index = delegated.selectors.length;\n\n                    delegated.selectors.push(this.selector);\n                    delegated.contexts .push(this._context);\n                    delegated.listeners.push([]);\n                }\n\n                // keep listener and useCapture flag\n                delegated.listeners[index].push([listener, useCapture]);\n            }\n            else {\n                events.add(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.off\n         [ method ]\n         *\n         * Removes an InteractEvent or DOM event listener\n         *\n         - eventType  (string | array | object) The types of events that were listened for\n         - listener   (function) The listener function to be removed\n         - useCapture (boolean) #optional useCapture flag for removeEventListener\n         = (object) This Interactable\n        \\*/\n        off: function (eventType, listener, useCapture) {\n            var i;\n\n            if (isString(eventType) && eventType.search(' ') !== -1) {\n                eventType = eventType.trim().split(/ +/);\n            }\n\n            if (isArray(eventType)) {\n                for (i = 0; i < eventType.length; i++) {\n                    this.off(eventType[i], listener, useCapture);\n                }\n\n                return this;\n            }\n\n            if (isObject(eventType)) {\n                for (var prop in eventType) {\n                    this.off(prop, eventType[prop], listener);\n                }\n\n                return this;\n            }\n\n            var eventList,\n                index = -1;\n\n            // convert to boolean\n            useCapture = useCapture? true: false;\n\n            if (eventType === 'wheel') {\n                eventType = wheelEvent;\n            }\n\n            // if it is an action event type\n            if (contains(eventTypes, eventType)) {\n                eventList = this._iEvents[eventType];\n\n                if (eventList && (index = indexOf(eventList, listener)) !== -1) {\n                    this._iEvents[eventType].splice(index, 1);\n                }\n            }\n            // delegated event\n            else if (this.selector) {\n                var delegated = delegatedEvents[eventType],\n                    matchFound = false;\n\n                if (!delegated) { return this; }\n\n                // count from last index of delegated to 0\n                for (index = delegated.selectors.length - 1; index >= 0; index--) {\n                    // look for matching selector and context Node\n                    if (delegated.selectors[index] === this.selector\n                        && delegated.contexts[index] === this._context) {\n\n                        var listeners = delegated.listeners[index];\n\n                        // each item of the listeners array is an array: [function, useCaptureFlag]\n                        for (i = listeners.length - 1; i >= 0; i--) {\n                            var fn = listeners[i][0],\n                                useCap = listeners[i][1];\n\n                            // check if the listener functions and useCapture flags match\n                            if (fn === listener && useCap === useCapture) {\n                                // remove the listener from the array of listeners\n                                listeners.splice(i, 1);\n\n                                // if all listeners for this interactable have been removed\n                                // remove the interactable from the delegated arrays\n                                if (!listeners.length) {\n                                    delegated.selectors.splice(index, 1);\n                                    delegated.contexts .splice(index, 1);\n                                    delegated.listeners.splice(index, 1);\n\n                                    // remove delegate function from context\n                                    events.remove(this._context, eventType, delegateListener);\n                                    events.remove(this._context, eventType, delegateUseCapture, true);\n\n                                    // remove the arrays if they are empty\n                                    if (!delegated.selectors.length) {\n                                        delegatedEvents[eventType] = null;\n                                    }\n                                }\n\n                                // only remove one listener\n                                matchFound = true;\n                                break;\n                            }\n                        }\n\n                        if (matchFound) { break; }\n                    }\n                }\n            }\n            // remove listener from this Interatable's element\n            else {\n                events.remove(this._element, eventType, listener, useCapture);\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.set\n         [ method ]\n         *\n         * Reset the options of this Interactable\n         - options (object) The new settings to apply\n         = (object) This Interactable\n        \\*/\n        set: function (options) {\n            if (!isObject(options)) {\n                options = {};\n            }\n\n            this.options = extend({}, defaultOptions.base);\n\n            var i,\n                actions = ['drag', 'drop', 'resize', 'gesture'],\n                methods = ['draggable', 'dropzone', 'resizable', 'gesturable'],\n                perActions = extend(extend({}, defaultOptions.perAction), options[action] || {});\n\n            for (i = 0; i < actions.length; i++) {\n                var action = actions[i];\n\n                this.options[action] = extend({}, defaultOptions[action]);\n\n                this.setPerAction(action, perActions);\n\n                this[methods[i]](options[action]);\n            }\n\n            var settings = [\n                    'accept', 'actionChecker', 'allowFrom', 'deltaSource',\n                    'dropChecker', 'ignoreFrom', 'origin', 'preventDefault',\n                    'rectChecker', 'styleCursor'\n                ];\n\n            for (i = 0, len = settings.length; i < len; i++) {\n                var setting = settings[i];\n\n                this.options[setting] = defaultOptions.base[setting];\n\n                if (setting in options) {\n                    this[setting](options[setting]);\n                }\n            }\n\n            return this;\n        },\n\n        /*\\\n         * Interactable.unset\n         [ method ]\n         *\n         * Remove this interactable from the list of interactables and remove\n         * it's drag, drop, resize and gesture capabilities\n         *\n         = (object) @interact\n        \\*/\n        unset: function () {\n            events.remove(this._element, 'all');\n\n            if (!isString(this.selector)) {\n                events.remove(this, 'all');\n                if (this.options.styleCursor) {\n                    this._element.style.cursor = '';\n                }\n            }\n            else {\n                // remove delegated events\n                for (var type in delegatedEvents) {\n                    var delegated = delegatedEvents[type];\n\n                    for (var i = 0; i < delegated.selectors.length; i++) {\n                        if (delegated.selectors[i] === this.selector\n                            && delegated.contexts[i] === this._context) {\n\n                            delegated.selectors.splice(i, 1);\n                            delegated.contexts .splice(i, 1);\n                            delegated.listeners.splice(i, 1);\n\n                            // remove the arrays if they are empty\n                            if (!delegated.selectors.length) {\n                                delegatedEvents[type] = null;\n                            }\n                        }\n\n                        events.remove(this._context, type, delegateListener);\n                        events.remove(this._context, type, delegateUseCapture, true);\n\n                        break;\n                    }\n                }\n            }\n\n            this.dropzone(false);\n\n            interactables.splice(indexOf(interactables, this), 1);\n\n            return interact;\n        }\n    };\n\n    function warnOnce (method, message) {\n        var warned = false;\n\n        return function () {\n            if (!warned) {\n                window.console.warn(message);\n                warned = true;\n            }\n\n            return method.apply(this, arguments);\n        };\n    }\n\n    Interactable.prototype.snap = warnOnce(Interactable.prototype.snap,\n         'Interactable#snap is deprecated. See the new documentation for snapping at http://interactjs.io/docs/snapping');\n    Interactable.prototype.restrict = warnOnce(Interactable.prototype.restrict,\n         'Interactable#restrict is deprecated. See the new documentation for resticting at http://interactjs.io/docs/restriction');\n    Interactable.prototype.inertia = warnOnce(Interactable.prototype.inertia,\n         'Interactable#inertia is deprecated. See the new documentation for inertia at http://interactjs.io/docs/inertia');\n    Interactable.prototype.autoScroll = warnOnce(Interactable.prototype.autoScroll,\n         'Interactable#autoScroll is deprecated. See the new documentation for autoScroll at http://interactjs.io/docs/#autoscroll');\n    Interactable.prototype.squareResize = warnOnce(Interactable.prototype.squareResize,\n         'Interactable#squareResize is deprecated. See http://interactjs.io/docs/#resize-square');\n\n    Interactable.prototype.accept = warnOnce(Interactable.prototype.accept,\n         'Interactable#accept is deprecated. use Interactable#dropzone({ accept: target }) instead');\n    Interactable.prototype.dropChecker = warnOnce(Interactable.prototype.dropChecker,\n         'Interactable#dropChecker is deprecated. use Interactable#dropzone({ dropChecker: checkerFunction }) instead');\n    Interactable.prototype.context = warnOnce(Interactable.prototype.context,\n         'Interactable#context as a method is deprecated. It will soon be a DOM Node instead');\n\n    /*\\\n     * interact.isSet\n     [ method ]\n     *\n     * Check if an element has been set\n     - element (Element) The Element being searched for\n     = (boolean) Indicates if the element or CSS selector was previously passed to interact\n    \\*/\n    interact.isSet = function(element, options) {\n        return interactables.indexOfElement(element, options && options.context) !== -1;\n    };\n\n    /*\\\n     * interact.on\n     [ method ]\n     *\n     * Adds a global listener for an InteractEvent or adds a DOM event to\n     * `document`\n     *\n     - type       (string | array | object) The types of events to listen for\n     - listener   (function) The function to be called on the given event(s)\n     - useCapture (boolean) #optional useCapture flag for addEventListener\n     = (object) interact\n    \\*/\n    interact.on = function (type, listener, useCapture) {\n        if (isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.on(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (isObject(type)) {\n            for (var prop in type) {\n                interact.on(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        // if it is an InteractEvent type, add listener to globalEvents\n        if (contains(eventTypes, type)) {\n            // if this type of event was never bound\n            if (!globalEvents[type]) {\n                globalEvents[type] = [listener];\n            }\n            else {\n                globalEvents[type].push(listener);\n            }\n        }\n        // If non InteractEvent type, addEventListener to document\n        else {\n            events.add(document, type, listener, useCapture);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.off\n     [ method ]\n     *\n     * Removes a global InteractEvent listener or DOM event from `document`\n     *\n     - type       (string | array | object) The types of events that were listened for\n     - listener   (function) The listener function to be removed\n     - useCapture (boolean) #optional useCapture flag for removeEventListener\n     = (object) interact\n     \\*/\n    interact.off = function (type, listener, useCapture) {\n        if (isString(type) && type.search(' ') !== -1) {\n            type = type.trim().split(/ +/);\n        }\n\n        if (isArray(type)) {\n            for (var i = 0; i < type.length; i++) {\n                interact.off(type[i], listener, useCapture);\n            }\n\n            return interact;\n        }\n\n        if (isObject(type)) {\n            for (var prop in type) {\n                interact.off(prop, type[prop], listener);\n            }\n\n            return interact;\n        }\n\n        if (!contains(eventTypes, type)) {\n            events.remove(document, type, listener, useCapture);\n        }\n        else {\n            var index;\n\n            if (type in globalEvents\n                && (index = indexOf(globalEvents[type], listener)) !== -1) {\n                globalEvents[type].splice(index, 1);\n            }\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.enableDragging\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether dragging is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableDragging = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.drag = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.drag;\n    }, 'interact.enableDragging is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableResizing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether resizing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableResizing = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.resize = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.resize;\n    }, 'interact.enableResizing is deprecated and will soon be removed.');\n\n    /*\\\n     * interact.enableGesturing\n     [ method ]\n     *\n     * Deprecated.\n     *\n     * Returns or sets whether gesturing is enabled for any Interactables\n     *\n     - newValue (boolean) #optional `true` to allow the action; `false` to disable action for all Interactables\n     = (boolean | object) The current setting or interact\n    \\*/\n    interact.enableGesturing = warnOnce(function (newValue) {\n        if (newValue !== null && newValue !== undefined) {\n            actionIsEnabled.gesture = newValue;\n\n            return interact;\n        }\n        return actionIsEnabled.gesture;\n    }, 'interact.enableGesturing is deprecated and will soon be removed.');\n\n    interact.eventTypes = eventTypes;\n\n    /*\\\n     * interact.debug\n     [ method ]\n     *\n     * Returns debugging data\n     = (object) An object with properties that outline the current state and expose internal functions and variables\n    \\*/\n    interact.debug = function () {\n        var interaction = interactions[0] || new Interaction();\n\n        return {\n            interactions          : interactions,\n            target                : interaction.target,\n            dragging              : interaction.dragging,\n            resizing              : interaction.resizing,\n            gesturing             : interaction.gesturing,\n            prepared              : interaction.prepared,\n            matches               : interaction.matches,\n            matchElements         : interaction.matchElements,\n\n            prevCoords            : interaction.prevCoords,\n            startCoords           : interaction.startCoords,\n\n            pointerIds            : interaction.pointerIds,\n            pointers              : interaction.pointers,\n            addPointer            : listeners.addPointer,\n            removePointer         : listeners.removePointer,\n            recordPointer        : listeners.recordPointer,\n\n            snap                  : interaction.snapStatus,\n            restrict              : interaction.restrictStatus,\n            inertia               : interaction.inertiaStatus,\n\n            downTime              : interaction.downTimes[0],\n            downEvent             : interaction.downEvent,\n            downPointer           : interaction.downPointer,\n            prevEvent             : interaction.prevEvent,\n\n            Interactable          : Interactable,\n            interactables         : interactables,\n            pointerIsDown         : interaction.pointerIsDown,\n            defaultOptions        : defaultOptions,\n            defaultActionChecker  : defaultActionChecker,\n\n            actionCursors         : actionCursors,\n            dragMove              : listeners.dragMove,\n            resizeMove            : listeners.resizeMove,\n            gestureMove           : listeners.gestureMove,\n            pointerUp             : listeners.pointerUp,\n            pointerDown           : listeners.pointerDown,\n            pointerMove           : listeners.pointerMove,\n            pointerHover          : listeners.pointerHover,\n\n            eventTypes            : eventTypes,\n\n            events                : events,\n            globalEvents          : globalEvents,\n            delegatedEvents       : delegatedEvents,\n\n            prefixedPropREs       : prefixedPropREs\n        };\n    };\n\n    // expose the functions used to calculate multi-touch properties\n    interact.getPointerAverage = pointerAverage;\n    interact.getTouchBBox     = touchBBox;\n    interact.getTouchDistance = touchDistance;\n    interact.getTouchAngle    = touchAngle;\n\n    interact.getElementRect         = getElementRect;\n    interact.getElementClientRect   = getElementClientRect;\n    interact.matchesSelector        = matchesSelector;\n    interact.closest                = closest;\n\n    /*\\\n     * interact.margin\n     [ method ]\n     *\n     * Deprecated. Use `interact(target).resizable({ margin: number });` instead.\n     * Returns or sets the margin for autocheck resizing used in\n     * @Interactable.getAction. That is the distance from the bottom and right\n     * edges of an element clicking in which will start resizing\n     *\n     - newValue (number) #optional\n     = (number | interact) The current margin value or interact\n    \\*/\n    interact.margin = warnOnce(function (newvalue) {\n        if (isNumber(newvalue)) {\n            margin = newvalue;\n\n            return interact;\n        }\n        return margin;\n    },\n    'interact.margin is deprecated. Use interact(target).resizable({ margin: number }); instead.') ;\n\n    /*\\\n     * interact.supportsTouch\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports touch input\n    \\*/\n    interact.supportsTouch = function () {\n        return supportsTouch;\n    };\n\n    /*\\\n     * interact.supportsPointerEvent\n     [ method ]\n     *\n     = (boolean) Whether or not the browser supports PointerEvents\n    \\*/\n    interact.supportsPointerEvent = function () {\n        return supportsPointerEvent;\n    };\n\n    /*\\\n     * interact.stop\n     [ method ]\n     *\n     * Cancels all interactions (end events are not fired)\n     *\n     - event (Event) An event on which to call preventDefault()\n     = (object) interact\n    \\*/\n    interact.stop = function (event) {\n        for (var i = interactions.length - 1; i >= 0; i--) {\n            interactions[i].stop(event);\n        }\n\n        return interact;\n    };\n\n    /*\\\n     * interact.dynamicDrop\n     [ method ]\n     *\n     * Returns or sets whether the dimensions of dropzone elements are\n     * calculated on every dragmove or only on dragstart for the default\n     * dropChecker\n     *\n     - newValue (boolean) #optional True to check on each move. False to check only before start\n     = (boolean | interact) The current setting or interact\n    \\*/\n    interact.dynamicDrop = function (newValue) {\n        if (isBool(newValue)) {\n            //if (dragging && dynamicDrop !== newValue && !newValue) {\n                //calcRects(dropzones);\n            //}\n\n            dynamicDrop = newValue;\n\n            return interact;\n        }\n        return dynamicDrop;\n    };\n\n    /*\\\n     * interact.pointerMoveTolerance\n     [ method ]\n     * Returns or sets the distance the pointer must be moved before an action\n     * sequence occurs. This also affects tolerance for tap events.\n     *\n     - newValue (number) #optional The movement from the start position must be greater than this value\n     = (number | Interactable) The current setting or interact\n    \\*/\n    interact.pointerMoveTolerance = function (newValue) {\n        if (isNumber(newValue)) {\n            pointerMoveTolerance = newValue;\n\n            return this;\n        }\n\n        return pointerMoveTolerance;\n    };\n\n    /*\\\n     * interact.maxInteractions\n     [ method ]\n     **\n     * Returns or sets the maximum number of concurrent interactions allowed.\n     * By default only 1 interaction is allowed at a time (for backwards\n     * compatibility). To allow multiple interactions on the same Interactables\n     * and elements, you need to enable it in the draggable, resizable and\n     * gesturable `'max'` and `'maxPerElement'` options.\n     **\n     - newValue (number) #optional Any number. newValue <= 0 means no interactions.\n    \\*/\n    interact.maxInteractions = function (newValue) {\n        if (isNumber(newValue)) {\n            maxInteractions = newValue;\n\n            return this;\n        }\n\n        return maxInteractions;\n    };\n\n    interact.createSnapGrid = function (grid) {\n        return function (x, y) {\n            var offsetX = 0,\n                offsetY = 0;\n\n            if (isObject(grid.offset)) {\n                offsetX = grid.offset.x;\n                offsetY = grid.offset.y;\n            }\n\n            var gridx = Math.round((x - offsetX) / grid.x),\n                gridy = Math.round((y - offsetY) / grid.y),\n\n                newX = gridx * grid.x + offsetX,\n                newY = gridy * grid.y + offsetY;\n\n            return {\n                x: newX,\n                y: newY,\n                range: grid.range\n            };\n        };\n    };\n\n    function endAllInteractions (event) {\n        for (var i = 0; i < interactions.length; i++) {\n            interactions[i].pointerEnd(event, event);\n        }\n    }\n\n    function listenToDocument (doc) {\n        if (contains(documents, doc)) { return; }\n\n        var win = doc.defaultView || doc.parentWindow;\n\n        // add delegate event listener\n        for (var eventType in delegatedEvents) {\n            events.add(doc, eventType, delegateListener);\n            events.add(doc, eventType, delegateUseCapture, true);\n        }\n\n        if (supportsPointerEvent) {\n            if (PointerEvent === win.MSPointerEvent) {\n                pEventTypes = {\n                    up: 'MSPointerUp', down: 'MSPointerDown', over: 'mouseover',\n                    out: 'mouseout', move: 'MSPointerMove', cancel: 'MSPointerCancel' };\n            }\n            else {\n                pEventTypes = {\n                    up: 'pointerup', down: 'pointerdown', over: 'pointerover',\n                    out: 'pointerout', move: 'pointermove', cancel: 'pointercancel' };\n            }\n\n            events.add(doc, pEventTypes.down  , listeners.selectorDown );\n            events.add(doc, pEventTypes.move  , listeners.pointerMove  );\n            events.add(doc, pEventTypes.over  , listeners.pointerOver  );\n            events.add(doc, pEventTypes.out   , listeners.pointerOut   );\n            events.add(doc, pEventTypes.up    , listeners.pointerUp    );\n            events.add(doc, pEventTypes.cancel, listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, pEventTypes.move, listeners.autoScrollMove);\n        }\n        else {\n            events.add(doc, 'mousedown', listeners.selectorDown);\n            events.add(doc, 'mousemove', listeners.pointerMove );\n            events.add(doc, 'mouseup'  , listeners.pointerUp   );\n            events.add(doc, 'mouseover', listeners.pointerOver );\n            events.add(doc, 'mouseout' , listeners.pointerOut  );\n\n            events.add(doc, 'touchstart' , listeners.selectorDown );\n            events.add(doc, 'touchmove'  , listeners.pointerMove  );\n            events.add(doc, 'touchend'   , listeners.pointerUp    );\n            events.add(doc, 'touchcancel', listeners.pointerCancel);\n\n            // autoscroll\n            events.add(doc, 'mousemove', listeners.autoScrollMove);\n            events.add(doc, 'touchmove', listeners.autoScrollMove);\n        }\n\n        events.add(win, 'blur', endAllInteractions);\n\n        try {\n            if (win.frameElement) {\n                var parentDoc = win.frameElement.ownerDocument,\n                    parentWindow = parentDoc.defaultView;\n\n                events.add(parentDoc   , 'mouseup'      , listeners.pointerEnd);\n                events.add(parentDoc   , 'touchend'     , listeners.pointerEnd);\n                events.add(parentDoc   , 'touchcancel'  , listeners.pointerEnd);\n                events.add(parentDoc   , 'pointerup'    , listeners.pointerEnd);\n                events.add(parentDoc   , 'MSPointerUp'  , listeners.pointerEnd);\n                events.add(parentWindow, 'blur'         , endAllInteractions );\n            }\n        }\n        catch (error) {\n            interact.windowParentError = error;\n        }\n\n        // prevent native HTML5 drag on interact.js target elements\n        events.add(doc, 'dragstart', function (event) {\n            for (var i = 0; i < interactions.length; i++) {\n                var interaction = interactions[i];\n\n                if (interaction.element\n                    && (interaction.element === event.target\n                        || nodeContains(interaction.element, event.target))) {\n\n                    interaction.checkAndPreventDefault(event, interaction.target, interaction.element);\n                    return;\n                }\n            }\n        });\n\n        if (events.useAttachEvent) {\n            // For IE's lack of Event#preventDefault\n            events.add(doc, 'selectstart', function (event) {\n                var interaction = interactions[0];\n\n                if (interaction.currentAction()) {\n                    interaction.checkAndPreventDefault(event);\n                }\n            });\n\n            // For IE's bad dblclick event sequence\n            events.add(doc, 'dblclick', doOnInteractions('ie8Dblclick'));\n        }\n\n        documents.push(doc);\n    }\n\n    listenToDocument(document);\n\n    function indexOf (array, target) {\n        for (var i = 0, len = array.length; i < len; i++) {\n            if (array[i] === target) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    function contains (array, target) {\n        return indexOf(array, target) !== -1;\n    }\n\n    function matchesSelector (element, selector, nodeList) {\n        if (ie8MatchesSelector) {\n            return ie8MatchesSelector(element, selector, nodeList);\n        }\n\n        // remove /deep/ from selectors if shadowDOM polyfill is used\n        if (window !== realWindow) {\n            selector = selector.replace(/\\/deep\\//g, ' ');\n        }\n\n        return element[prefixedMatchesSelector](selector);\n    }\n\n    function matchesUpTo (element, selector, limit) {\n        while (isElement(element)) {\n            if (matchesSelector(element, selector)) {\n                return true;\n            }\n\n            element = parentElement(element);\n\n            if (element === limit) {\n                return matchesSelector(element, selector);\n            }\n        }\n\n        return false;\n    }\n\n    // For IE8's lack of an Element#matchesSelector\n    // taken from http://tanalin.com/en/blog/2012/12/matches-selector-ie8/ and modified\n    if (!(prefixedMatchesSelector in Element.prototype) || !isFunction(Element.prototype[prefixedMatchesSelector])) {\n        ie8MatchesSelector = function (element, selector, elems) {\n            elems = elems || element.parentNode.querySelectorAll(selector);\n\n            for (var i = 0, len = elems.length; i < len; i++) {\n                if (elems[i] === element) {\n                    return true;\n                }\n            }\n\n            return false;\n        };\n    }\n\n    // requestAnimationFrame polyfill\n    (function() {\n        var lastTime = 0,\n            vendors = ['ms', 'moz', 'webkit', 'o'];\n\n        for(var x = 0; x < vendors.length && !realWindow.requestAnimationFrame; ++x) {\n            reqFrame = realWindow[vendors[x]+'RequestAnimationFrame'];\n            cancelFrame = realWindow[vendors[x]+'CancelAnimationFrame'] || realWindow[vendors[x]+'CancelRequestAnimationFrame'];\n        }\n\n        if (!reqFrame) {\n            reqFrame = function(callback) {\n                var currTime = new Date().getTime(),\n                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),\n                    id = setTimeout(function() { callback(currTime + timeToCall); },\n                  timeToCall);\n                lastTime = currTime + timeToCall;\n                return id;\n            };\n        }\n\n        if (!cancelFrame) {\n            cancelFrame = function(id) {\n                clearTimeout(id);\n            };\n        }\n    }());\n\n    /* global exports: true, module, define */\n\n    // http://documentcloud.github.io/underscore/docs/underscore.html#section-11\n    if (typeof exports !== 'undefined') {\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = interact;\n        }\n        exports.interact = interact;\n    }\n    // AMD\n    else if (typeof define === 'function' && define.amd) {\n        define('interact', function() {\n            return interact;\n        });\n    }\n    else {\n        realWindow.interact = interact;\n    }\n\n} (typeof window === 'undefined'? undefined : window));\n"]},"metadata":{},"sourceType":"script"}